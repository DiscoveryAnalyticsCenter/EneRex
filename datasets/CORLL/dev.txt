We O
ran O
all O
the O
experiments O
on O
an O
ordinary O
workstation U-hardware_platform
: O
Intel(R B-hardware_resources
) I-hardware_resources
Core(TM I-hardware_resources
) I-hardware_resources
i7 I-hardware_resources
- I-hardware_resources
2600 I-hardware_resources
K I-hardware_resources
CPU L-hardware_resources
at O
3.40GHz U-hardware_resources
with O
16Gb B-hardware_resources
of I-hardware_resources
RAM. L-hardware_resources
We O
tested O
four O
different O
online O
algorithms O
for O
classification O
10 O
and O
one O
batch O
classification O
algorithm O
: O
• O
ALMA O
# O
b11 O
: O
is O
a O
fast O
classifier O
which O
try O
to O
approximate O
the O
maximal O
margin O
hyperplane O
between O
the O
two O
classes O
. O

We O
use O
the O
SOS O
module O
of O
the O
YALMIP B-p_library
toolbox L-p_library
# O
b20 O
to O
manipulate O
and O
express O
polynomial O
constraints O
at O
a O
high O
level O
in O
MATLAB U-p_language
. O

To O
check O
the O
code O
performance O
it O
is O
used O
of O
HP B-hardware_platform
cluster L-hardware_platform
Intel B-hardware_resources
Xeon I-hardware_resources
E5410 I-hardware_resources
@ I-hardware_resources
2.33GHz L-hardware_resources
. O

Hence O
, O
the O
actual O
number O
of O
parameters O
is O
p O
+ O
1.A O
restricted O
set O
of O
eleven O
Java U-p_language
bytecode O
instructions O
is O
considered O
in O
# O
b24 O
. O

With O
eval O
we O
can O
turn O
this O
name O
into O
a O
living O
object O
, O
without O
the O
usual O
if O
or O
case O
statements O
in O
factory O
functions O
that O
would O
be O
necessary O
in O
C O
, O
C++ U-p_language
, O
Fortran U-p_language
, O
and O
Java U-p_language
. O

Recall O
that O
JML U-p_language
is O
a O
modular O
verification O
system O
: O
for O
each O
Java U-p_language
method O
, O
the O
method O
's O
implementation O
is O
checked O
against O
its O
own O
specifications O
and O
the O
specifications O
of O
referenced O
types O
and O
methods O
, O
but O
without O
reference O
to O
other O
methods O
' O
implementations O
. O

Finally O
, O
we O
report O
the O
performance O
comparison O
with O
a O
traditional O
Intel B-hardware_resources
Xeon I-hardware_resources
CPU L-hardware_resources
. O

We O
implemented O
all O
our O
algorithms O
as O
well O
as O
the O
baseline O
KR O
method O
in O
Matlab U-p_language
. O

For O
ease O
of O
exposition O
, O
we O
consider O
a O
simplification O
of O
the O
Java U-p_language
bytecode O
where O
values O
can O
only O
be O
integers O
, O
locations O
or O
null O
. O

Timing O
of O
our O
CPU U-hardware_resources
and O
GPU U-hardware_resources
APD U-hardware_resources
tree O
implementations O
on O
three O
data O
sets O
. O

As O
in O
the O
paper O
, O
we O
can O
see O
that O
on O
the O
more O
complex O
model O
StocPy O
manages O
to O
be O
more O
succint O
, O
largely O
thanks O
to O
the O
Python U-p_language
in O
- O
built O
operators O
. O

We O
developed O
python U-p_language
script O
for O
distributed O
support O
vector O
machine O
algorithm O
with O
scikit U-p_library
, O
scipy U-p_library
, O
numpy U-p_library
, O
mrjob U-p_library
, O
matplotlib U-p_library
and O
libsvm U-p_library
. O

Each O
call O
to O
the O
GQS O
was O
run O
serially O
on O
a O
single B-hardware_resources
CPU L-hardware_resources
. O

Note O
that O
performance O
may O
be O
boosted O
even O
fur O
- O
ther O
by O
using O
tools O
such O
as O
[ O
Cython U-p_library
] O
, O
[ O
Theano U-p_library
] O
or O
[ O
numexpr O
] O
, O
which O
lessen O
the O
load O
on O
the O
memory O
bus O
. O

On O
the O
CPU U-hardware_resources
, O
the O
Fortran U-p_language
algorithm O
was O
used O
as O
reference O
. O

Conventional O
approaches O
to O
embedding O
database O
queries O
within O
a O
general O
- O
purpose O
language O
, O
such O
as O
Java B-p_library
's I-p_library
JDBC L-p_library
, O
provide O
the O
programmer O
with O
precise O
control O
over O
performance O
but O
are O
subject O
to O
typing O
errors O
and O
security O
vulnerabilities O
such O
as O
SQL U-p_language
injection O
attacks O
# O
b34 O
. O

OpenJML U-p_library
follows O
a O
design O
adapted O
from O
ESC O
/ O
Java2 U-p_language
and O
commonly O
used O
for O
software O
verification O
systems O
# O
b16 O
# O
b34 O
# O
b26 O
# O
b0 O
) O
.• O
The O
procedure O
specifications O
are O
translated O
into O
assumptions O
and O
assertions O
interleaved O
with O
the O
Java U-p_language
code O
, O
based O
on O
the O
semantics O
of O
the O
specification O
language O
. O

The O
model O
data O
and O
MATLAB U-p_language
programs O
can O
be O
downloaded O
from O
# O
b32 O
.All O
simulations O
have O
been O
run O
on O
a O
mini B-hardware_platform
Mac L-hardware_platform
intel B-hardware_resources
core I-hardware_resources
Duo I-hardware_resources
2 L-hardware_resources
, O
2.53 B-hardware_resources
GHz I-hardware_resources
processor L-hardware_resources
, O
with O
4 B-hardware_resources
GB I-hardware_resources
1067 I-hardware_resources
MhZ I-hardware_resources
DDR3 I-hardware_resources
RAM. L-hardware_resources
Randomly O
generated O
models O
have O
been O
previously O
adopted O
as O
a O
validation O
method O
for O
synchronizing O
sequence O
construction O
also O
by O
Roman O
# O
b40 O
.For O
selected O
values O
of O
m O
places O
, O
q O
transitions O
and O
k O
= O
1 O
, O
2 O
tokens O
, O
we O
randomly O
generate O
100 O
deterministic O
and O
strongly O
connected O
synchronized O
SMs O
having O
m O
= O
2÷7 O
places O
, O
q O
= O
m÷15 O
transitions O
and O
k O
= O
1 O
, O
2 O
tokens O
. O

We O
report O
the O
average O
CPU O
time O
per O
iteration O
after O
T O
= O
500 O
iterations O
, O
which O
practically O
ensures O
that O
GS O
and O
FGS O
converge O
in O
terms O
of O
training O
perplexity O
. O

For O
instance O
, O
a O
Service O
Provider O
may O
distribute O
proxies O
for O
Java U-p_language
, O
Visual O
Basic O
, O
and O
Delphi O
if O
those O
are O
the O
most O
likely O
platforms O
for O
Service O
Consumers O
. O

Table B-compute_time
I L-compute_time
shows O
wall O
times O
( O
average O
elapsed O
time O
per O
timestep O
) O
to O
run O
the O
application O
in O
a O
full O
domain O
with O
1024x1024x40 O
array O
size O
and O
100 O
different O
variables O
representing O
the O
physics O
fields O
present O
in O
a O
meteorological O
numerical O
simulation O
, O
with O
and O
without O
concurrent O
asynchronous O
GPU U-hardware_resources
jobs O
. O

The O
following O
set O
of O
rules O
, O
defined O
here O
in O
natural O
language O
, O
is O
associated O
to O
each O
agent:• O
if O
the O
agent O
is O
in O
and O
does O
not O
belong O
to O
G O
, O
then O
the O
agent O
joins O
G,• O
if O
the O
agent O
is O
not O
in O
and O
belongs O
to O
G O
, O
then O
the O
agent O
leaves O
G.The O
observation O
system O
( O
o O
b O
s O
) O
only O
probes O
the O
agents O
of O
G. O
Figure O
5 O
presents O
the O
CPU U-hardware_resources
time O
difference O
between O
simulations O
observed O
with O
self-observation O
and O
brute-force O
methods O
as O
a O
function O
of O
the O
number O
of O
agents O
in O
the O
simulation O
, O
N O
, O
and O
the O
mean O
rate O
of O
observed O
agents O
, O
E(Z)/N O
. O

We O
have O
also O
implemented O
pPITC O
and O
pPIC O
in O
the O
MapReduce O
framework O
for O
running O
in O
a O
Linux B-hardware_platform
server L-hardware_platform
with O
2 B-hardware_resources
Intel I-hardware_resources
Xeon I-hardware_resources
CPU I-hardware_resources
E5 I-hardware_resources
- I-hardware_resources
2670 L-hardware_resources
at O
2.60 B-hardware_resources
GHz L-hardware_resources
and O
96 B-hardware_resources
GB I-hardware_resources
memory I-hardware_resources
( I-hardware_resources
i.e. I-hardware_resources
, I-hardware_resources
16 I-hardware_resources
cores I-hardware_resources
) L-hardware_resources
; O
due O
to O
shared O
memory O
, O
they O
incur O
slightly O
longer O
time O
than O
that O
in O
a O
cluster B-hardware_platform
of I-hardware_platform
16 I-hardware_platform
computing I-hardware_platform
nodes L-hardware_platform
. O

All O
the O
simulations O
for O
the O
HSR O
, O
GSRC O
and O
SRC O
algorithms O
are O
carried O
out O
in O
Matlab B-p_language
7.8 L-p_language
environment O
running O
in O
an O
Intel B-hardware_resources
Xeon I-hardware_resources
E5 I-hardware_resources
- I-hardware_resources
1650 I-hardware_resources
CPU L-hardware_resources
. O

The O
source O
of O
the O
training O
data O
was O
the O
handwritten O
numerical O
data O
available O
along O
with O
the O
OCR O
system O
in O
Statistical B-p_library
Pattern I-p_library
Recognition I-p_library
Toolbox I-p_library
( I-p_library
STPRTools I-p_library
) L-p_library
in O
Matlab U-p_language
. O

All O
three O
models O
are O
implemented O
using O
Theano U-p_library
# O
b22 O
, O
have O
a O
temporal O
dependancy O
of O
6 O
frames O
and O
were O
trained O
using O
minibatches O
of O
100 O
samples O
for O
500 O
epochs O
3 O
4 O
. O

The O
single-threaded O
CPU U-hardware_resources
baseline O
method O
is O
LibSVM O
# O
b8 O
, O
a O
popular O
implementation O
of O
SMO O
, O
which O
we O
use O
as O
the O
baseline O
for O
classification O
accuracy O
. O

A O
compute O
node O
comprises O
two B-hardware_resources
Intel I-hardware_resources
Sandy I-hardware_resources
Bridge I-hardware_resources
( I-hardware_resources
" I-hardware_resources
SNB I-hardware_resources
" I-hardware_resources
) I-hardware_resources
EP I-hardware_resources
( I-hardware_resources
Xeon I-hardware_resources
E5 I-hardware_resources
- I-hardware_resources
2680 I-hardware_resources
) I-hardware_resources
eight-core I-hardware_resources
processors L-hardware_resources
with O
a O
base O
clock O
frequency O
of O
2.7 B-hardware_resources
GHz L-hardware_resources
. O

To O
implement O
Procedure O
1 O
, O
we O
used O
SOSTOOLS U-p_library
which O
is O
a O
free O
MATLAB U-p_language
® O
toolbox O
for O
formulating O
and O
solving O
sum O
- O
of O
- O
squares O
optimizations O
# O
b24 O
. O

The O
interaction O
between O
the O
host O
programming O
language O
( O
e.g. O
Java U-p_language
, O
C B-p_language
# L-p_language
, O
F B-p_language
# L-p_language
, O
Haskell U-p_language
or O
some O
other O
general O
- O
purpose O
language O
) O
running O
on O
the O
server O
and O
the O
query O
language O
( O
e.g. O
SQL U-p_language
) O
running O
on O
the O
database O
is O
particularly O
important O
, O
because O
the O
relational O
model O
and O
query O
language O
provided O
by O
the O
database O
differ O
from O
the O
data O
structures O
of O
most O
host O
languages O
. O

For O
example O
, O
it O
is O
possible O
to O
compute O
the O
derivative O
of O
a O
Theano U-p_library
expression O
, O
while O
it O
is O
not O
possible O
to O
compute O
the O
derivative O
of O
the O
process O
that O
generated O
a O
numerical O
value O
given O
only O
the O
value O
itself O
. O

Tables B-compute_time
1 I-compute_time
and I-compute_time
2 L-compute_time
show O
the O
running O
times O
of O
our O
Lagrangian O
relaxation O
branch-and-bound O
approach O
and O
the O
CPLEX O
based O
method O
using O
default O
settings O
on O
the O
resulting O
instances O
on O
a O
compute B-hardware_platform
cluster L-hardware_platform
with O
two O
2.26 B-hardware_resources
GHz I-hardware_resources
Intel I-hardware_resources
Quad I-hardware_resources
Core I-hardware_resources
processors L-hardware_resources
with O
24 B-hardware_resources
GB L-hardware_resources
of O
RAM U-hardware_resources
on O
each O
node O
, O
running O
64 B-hardware_platform
bit I-hardware_platform
Linux L-hardware_platform
. O

There O
, O
we O
started O
from O
the O
results O
introduced O
in O
a O
preliminary O
version O
of O
# O
b24 O
where O
the O
original O
Java U-p_language
bytecode O
program O
P O
is O
translated O
into O
a O
constraint O
logic O
program O
PCLP O
whose O
termination O
entails O
that O
of O
P O
. O

FABHMM O
was O
compared O
with O
VBHMM O
, O
iHMM O
, O
and O
HMMs O
with O
ML O
estimation O
and O
BIC O
model O
selection O
( O
MLHMMs).We O
implemented O
FABHMM O
and O
MLHMM O
by O
Python U-p_language
, O
while O
we O
used O
Matlab U-p_language
softwares O
for O
iHMM O
5 O
and O
VBHMM O
6 O
. O

An O
implementation O
of O
the O
methods O
( O
in O
C O
with O
interface O
to O
Matlab U-p_language
) O
is O
available O
for O
download O
from O
http://www2.imm.dtu.dk/ O
∼ O
pch O
/ O
TVReg/. O
We O
compare O
the O
proposed O
methods O
with O
the O
standard O
gradient O
method O
, O
applied O
to O
a O
3D O
test O
problem O
with O
synthetic O
few O
- O
view O
data O
. O

We O
used O
a O
Java U-p_language
utility O
called O
Html B-p_library
Parser L-p_library
to O
extract O
the O
static O
hyperlinks O
in O
the O
page O
by O
looking O
at O
HTML U-p_language
elements O
. O

MATLAB U-p_language
R O
has O
been O
used O
to O
simulate O
the O
operation O
of O
the O
proposed O
systems O
, O
using O
the O
assumptions O
set O
forth O
for O
the O
wireless O
channel O
in O
section O
I. O
Fig O
. O

Table O
IV O
reports O
the O
speed O
of O
the O
generators O
discussed O
in O
the O
paper O
and O
of O
their O
xorshift O
* O
counterparts O
on O
an O
an O
Intel B-hardware_resources
R I-hardware_resources
Core I-hardware_resources
TM I-hardware_resources
i7 I-hardware_resources
- I-hardware_resources
4770 I-hardware_resources
CPU I-hardware_resources
@3.40GHz I-hardware_resources
( I-hardware_resources
Haswell I-hardware_resources
) L-hardware_resources
. O

• O
the O
volatile O
, O
transient O
, O
and O
native O
modifiers O
( O
and O
details O
of O
memory O
models O
) O
Java B-p_language
5 L-p_language
: O
These O
are O
the O
new O
features O
in O
Java B-p_language
5 L-p_language
:• O
Generic O
types O
-partially O
implemented O
• O
enhanced O
for O
loop O
-implemented O
• O
autoboxing O
and O
unboxing O
-implemented O
• O
typesafe O
enums O
-simple O
enum O
classes O
are O
implemented O
• O
static O
import O
-implemented O
( O
but O
JML O
model O
imports O
are O
treated O
just O
like O
Java U-p_language
imports)• O
varargs O
-partially O
modeled O
• O
Java U-p_language
annotations O
-No O
checks O
on O
annotations O
are O
modeled O
by O
ESC O
or O
compiled O
by O
RAC O
Java U-p_language
6 O
: O
No O
language O
changes O
Java B-p_language
7 L-p_language
: O
New B-p_language
Java I-p_language
7 L-p_language
language O
elements:• O
binary O
literals O
-implemented O
• O
literals O
with O
underscores O
-implemented O
• O
Strings O
in O
switch O
statements O
-Compiled O
in O
RAC O
, O
but O
not O
modeled O
or O
checked O
by O
ESC O
• O
try O
with O
resources O
-Compiled O
in O
RAC O
, O
but O
not O
modeled O
or O
checked O
by O
ESC O
• O
Catching O
multiple O
exception O
types O
-Compiled O
in O
RAC O
, O
but O
not O
modeled O
or O
checked O
by O
ESC O
• O
Type O
inference O
-not O
implemented O
in O
JML U-p_language
• O
Runtime O
errors O
associated O
with O
varargs O
parameter O
lists O
-not O
implemented O
in O
ESC O
Java B-p_language
8 L-p_language
: O
( O
OpenJML U-p_library
is O
only O
implemented O
at O
present O
for O
Java B-p_language
7 L-p_language
) O
. O

From O
now O
on O
, O
a O
Java U-p_language
bytecode O
program O
will O
be O
a O
graph O
of O
blocks O
, O
such O
as O
that O
in O
Fig O
. O

Likewise O
, O
we O
wish O
to O
operate O
correctly O
with O
apps O
that O
have O
natively O
compiled O
code O
, O
not O
just O
Java U-p_language
code O
( O
an O
issue O
with O
traditional O
stack O
inspection O
and O
with O
TaintDroid O
) O
. O

For O
the O
proposed O
method O
, O
the O
neural O
network O
was O
implemented O
with O
GPU U-hardware_resources
acceleration O
using O
an O
open O
- O
source O
deep O
learning O
framework O
, O
Caffe U-p_library
# O
b16 O
. O

However O
, O
an O
implementation O
of O
the O
simple O
strategy O
" O
Always O
compare O
with O
the O
larger O
pivot O
first O
" O
performs O
very O
well O
both O
in O
C++ U-p_language
and O
in O
Java U-p_language
in O
our O
experimental O
setup O
. O

The O
experiments O
were O
done O
on O
a O
two O
quad-core B-hardware_platform
Intel I-hardware_platform
E5410 I-hardware_platform
computer L-hardware_platform
running O
at O
2.33 B-hardware_resources
GHz L-hardware_resources
, O
with O
32 B-hardware_resources
GB I-hardware_resources
DDR2 I-hardware_resources 
800 I-hardware_resources
MHz I-hardware_resources
RAM L-hardware_resources
, O
running O
Linux B-hardware_platform
2.6 L-hardware_platform
. O

All O
experiments O
were O
written O
using O
the O
Python U-p_language
package O
Scikit B-p_library
- I-p_library
Learn L-p_library
# O
b13 O
. O

All O
numerical O
algorithms O
were O
implemented O
in O
Matlab U-p_language
using O
TFOCS U-p_library
# O
b5 O
as O
well O
as O
modifications O
of O
TFOCS U-p_library
template O
files O
. O

We O
extracted O
the O
following O
11 O
dynamic O
features:• O
the O
number O
of O
solutions O
found O
, O
the O
number O
p O
of O
propagations O
performed O
, O
and O
the O
ratio O
p O
|C| O
; O
• O
the O
number O
e O
of O
nodes O
expanded O
in O
the O
search O
tree O
, O
the O
number O
f O
of O
failed O
nodes O
in O
the O
search O
tree O
, O
and O
the O
ratio O
f O
e O
; O
• O
the O
maximum O
depth O
of O
the O
search O
stack O
and O
the O
peak O
memory O
allocated;• O
the O
CPU U-hardware_resources
time O
needed O
for O
converting O
from O
MiniZinc O
to O
FlatZinc O
, O
the O
CPU U-hardware_resources
time O
required O
for O
static O
features O
computation O
, O
and O
the O
total O
CPU U-hardware_resources
time O
needed O
for O
extracting O
all O
the O
features O
. O

Attribute O
calculations O
are O
evaluated O
at O
runtime O
by O
Java U-p_language
's O
built O
- O
in O
JavaScript U-p_language
engine O
which O
may O
also O
call O
Java U-p_language
methods O
. O

The O
following O
code O
snippet O
, O
taken O
from O
Sun O
's O
Secure O
Coding O
Guidelines O
for O
Java U-p_language
, O
demonstrates O
how O
a O
date O
object O
is O
cloned O
before O
being O
returned O
to O
a O
caller O
: O
However O
, O
relying O
on O
calling O
a O
polymorphic O
clone O
method O
to O
ensure O
secure O
copying O
of O
objects O
may O
prove O
insufficient O
, O
for O
two O
reasons O
. O

In O
this O
chapter O
, O
we O
propose O
a O
codification O
of O
the O
focal O
elements O
based O
on O
a O
codification O
of O
Θ O
in O
order O
to O
program O
easily O
in O
Matlab U-p_language
a O
general O
belief O
function O
framework O
working O
for O
belief O
functions O
defined O
on O
2 O
Θ O
but O
also O
on O
D O
Θ O
.Hence O
, O
in O
the O
following O
section O
we O
recall O
a O
short O
background O
of O
belief O
function O
theory O
. O

All O
data O
mining O
algorithms O
are O
developed O
using O
the O
Python U-p_language
language O
and O
libraries O
including O
scikit B-p_library
- I-p_library
learn L-p_library
, O
6 O
NLTK U-p_library
, O
7 O
and O
Gensim U-p_library
topic O
modeling O
toolkit O
. O

The O
experiments O
were O
conducted O
on O
a O
workstation U-hardware_platform
with O
Intel B-hardware_resources
Core I-hardware_resources
i7 I-hardware_resources
- I-hardware_resources
4790k I-hardware_resources
CPU L-hardware_resources
, O
16 B-hardware_resources
GB I-hardware_resources
RAM L-hardware_resources
and O
Nvidia B-hardware_resources
GeForce I-hardware_resources
GTX I-hardware_resources
980 I-hardware_resources
GPU L-hardware_resources
. O

The O
performance O
was O
normalized O
to O
the O
fastest O
single O
CPU U-hardware_resources
implantation O
at O
hand O
. O

A O
scikit B-p_library
- I-p_library
learn L-p_library
model O
is O
generally O
accompanied O
by O
a O
fit O
method O
that O
is O
a O
complete O
training O
algorithm O
and O
that O
ca O
n't O
be O
applied O
to O
any O
other O
model O
. O

The O
transformations O
described O
in O
this O
paper O
act O
on O
a O
nondistributed O
Java U-p_language
program O
to O
produce O
a O
componentised O
, O
semantically O
equivalent O
version O
. O

All O
systems O
ran O
current O
Linux B-hardware_platform
kernels L-hardware_platform
. O

We O
followed O
the O
same O
experimental O
set O
up O
( O
dataset O
and O
kernels O
) O
as O
described O
in O
# O
b40 O
. O

