An Online Development Environment for Answer Set Programming

Abstract
Recent progress in logic programming (e.g., the development of the Answer Set Programming paradigm) has made it possible to teach it to general undergraduate and even high school students. Given the limited exposure of these students to computer science, the complexity of downloading, installing and using tools for writing logic programs could be a major barrier for logic programming to reach a much wider audience. We developed an online answer set programming environment with a self contained file system and a simple interface, allowing users to write logic programs and perform several tasks over the programs.

Introduction
Answer Set Programming (ASP)  #b7  is becoming a dominating language in the knowledge representation community  #b13  #b10  because it has offered elegant and effective solutions not only to classical Artificial Intelligence problems but also to many challenging application problems. Thanks to its simplicity and clarity in both informal and formal semantics, Answer Set Programming provides a "natural" modeling of many problems. At the same time, the fully declarative nature of ASP also cleared a major barrier to teach logic programming, as the procedural features of classical logic programming systems such as PROLOG are taken as the source of misconceptions in students' learning of Logic Programming  #b14 .ASP has been taught to undergraduate students, in the course of Artificial Intelligence, at Texas Tech for more than a decade. We believe ASP has become mature enough to be a language for us to introduce programming and problem solving to high school students. We have offered many sessions to students at New Deal High School and a three week long ASP course to high school students involved in the TexPREP program (http://www.math.ttu.edu/texprep/). In our teaching practice, we found that ASP is well accepted by the students and the students were able to focus on problem solving, instead of the language itself. The students were able to write programs to answer questions about the relationships (e.g., parent, ancestor) amongst family members and to find solutions for Sudoku problems.However, we have some major issues while using existing tools: installation of the tools to computers at a lab or at home is complex, and the existing tools are sensitive to the local settings of a computer. As a result, the flow of teaching the class was often interrupted by the problems associated with the use of the tools. Strong technical support needed for the management and use of the tools is prohibitive for teaching ASP to general undergraduate students or K-12 students.During our teaching practice, we also found the need for a more vivid presentation of the results of a logic program (more than just querying the program or getting the answer sets of the program). We also noted observations in literature that multimedia and visualization play a positive role in promoting students' learning  #b8  #b2 .To overcome the issues related to software tool management and use, we have designed and built an online development environment for Answer Set Programming. The environment provides an editor for users to edit their programs, an online file system for them to store and retrieve their program and a few simple buttons allows querying the program inside the editor or getting answer sets of the program. The environment uses SPARC  #b1  as the ASP language. SPARC is designed to further facilitate the teaching of logic programming by introducing sorts (or types) which simplify the difficult programming concept of domain variables in classical ASP systems such as Clingo  #b6  and help programmers to identify errors early thanks to sort information. Initial experiment of teaching SPARC to high school students is promising  #b16 . To promote students' interests and learning, our environment also introduces predicates for students to present their solutions to problems in a more visually straightforward and exciting manner (instead of the answer sets which are simply a set of literals). The URL for the online environment is http://goo.gl/ukSZET.The rest of the paper is organized as follows. Section 2 recalls SPARC. The design and implementation of the online environment are presented in Section 3. The design and rendering of the drawing and animation predicates are presented in Section 4. The paper is concluded by Section 5.

Answer Set Programming Language -SPARC
SPARC is an Answer Set Programming language which allows for the explicit representation of sorts. A SPARC program consists of three sections: sorts, predicates and rules. We will use the map coloring problem as an example to illustrate SPARC: can the USA map be colored using red, green and blue such that no two neighboring states have the same color?The first step is to identify the objects and their sorts in the problem. For example, the three colors are important and they form the sort of color for this problem. In SPARC syntax, we use #color = {red, green, blue} to represent the objects and their sort. The sorts section of the SPARC program is sorts % the keyword to start the sorts section #color = {red,green,blue}. #state = {texas, colorado, newMexico, ......}.The next step is to identify relations in the problem and declare in the predicates section the sorts of the parameters of the predicates corresponding to the relations. The predicates section of the program is predicates % the keyword to start the predicates section % neighbor(X, Y) denotes that state X is a neighbor of state Y. neighbor(#state, #state). % ofColor(X, C) denotes that state X has color C ofColor(#state, #color).The last step is to identify the knowledge needed in the problem and translate it into rules. The rules section of a SPARC program consists of rules in the typical ASP syntax. The rules section of a SPARC program will include the following.rules % the keyword to start the rules section % Texas is a neighor of Colorado neighbor(texas, colorado). % The neighbor relation is symetric neighbor(S1, S2) :-neighbor(S2, S1). % Any state has one of the three colors: red, green and blue ofColor(S, red) | ofColor(S, green) | ofColor(S, blue). % No two neighbors have the same color :-ofColor(S1, C), ofColor(S2, C), neighbor(S1, S2), S1 != S2.

Online Development Environment Design and Implementation


Environment Design
The principle of the design is that the environment, with the simplest possible interface, should provide full support, from writing programming to getting the answer sets of the program, for teaching Answer Set Programming. The design of the interface is shown in Figure 1. It consists of 3 components: 1) the editor to edit a program, 2) the file navigation system and 3) the operations over the program. One can edit a SPARC program directly inside the editor which has syntax highlighting features (area 1). The file inside the editor can be saved by clicking the "Save" button (2.4). The files and folders are displayed in the area 2.1. The user can traverse them using the mouse like traversing a file system on a typical operating system. Files can be deleted and their names can be changed. To create a folder or a file, one clicks the "New" button (2.3). The panel showing files/folders can be toggled by clicking the "Directory" button (2.2) (so that users can have more space for the editing or result area (4)). To ask queries to the program inside the editor, one can type a query (a conjunction of literals) in the text box (3.1) and then press the "Submit" button (3.1). The answer to the query will be shown in area 4. For a ground query (i.e., a query without variables), the answer is yes if every literal in the query is in every answer set of the program, is no if the complement (p and ¬p, where p is an atom, are complements) of some literal is in every answer set of the program, and unknown otherwise. An answer to a query with variables is a set of ground terms for the variables in the query such that the answer to the query resulting from replacing the variables by the corresponding ground terms is yes. Formal definitions of queries and answers to queries can be found in Section 2.2 of  #b7 . To see the answer sets of a program, click the "Get Answer Sets" button (3.2). When "Execute" button (3.3) is clicked, the atoms with drawing and animation in the answer set of the program will be rendered in the display area (4). (For now, when there is more than one answer set, the environment displays an error.)A user can only access the full interface discussed above after login. The user will log out by clicking the "Logout" button  #b4 . Without login, the interface is much simpler, with all the file navigation related functionalities invisible. Such an interface is convenient for testing or doing a quick demo of a SPARC program.

Implementation
.The architecture of the online environment follows that of a typical web application. Is consists of a front end component and a back end component. The front end provides the user interface and sends users' request to the back end, and the back end fulfills the request and returns results, if needed, back to the front end. After getting the results from the back end, the front end will update the interface correspondingly (e.g., display query answers to the result area). Details about the components and their interactions are given below.Front End. The front end is implemented by HTML and JavaScript. The editor in our front end uses ACE which is an embeddable (to any web page) code editor written in JavaScript (https://ace.c9.io/). The panel for file/folder navigation is based on JavaScript code by Yuez.me.

Back End and Interactions between the Front End and the Back End.
The back end is mainly implemented using PHP and is hosted on the server side. It has three components: 1) file system management, 2) inference engine and 3) drawing/animation rendering.The file system management uses a database to manage the files and folders of all users of the environment. The ER diagram of the system is shown below: The SPARC files are saved in the server file system, not in a database table. The sharing is managed by the sharing information in the relevant database tables. In our implementation, we use mySQL database system. The file management system gets request such as creating a new file/folder, deleting a file, saving a file, getting the files and folders, etc, from the front end. It then updates the tables and local file system correspondingly and returns the needed results to the front end. After the front end gets the results, it will update the graphical user interface (e.g., display the program returned from the back end inside the editor) if needed.The inference engine gets the request of answering a query or obtaining all answer sets of a program. It calls the SPARC solver  #b1  to find all answer sets. Then in terms of these answer sets, it returns requested information to the front end. After the front end gets the response from the back end, it will show the result in the display area of the web page.Details of the design and implementation of drawing/animation rendering can be found in Section 4.2.

Drawing and Animation Design and Implementation


Drawing and Animation Design
To allow programmers to create drawings and animations using SPARC, we simply design two predicates, called display predicates: one for drawing and one for animation. The atoms using these predicates are called display atoms. To use these atoms in a SPARC program, a programmer needs to include sorts (e.g., sort of colors, fonts and numbers) and the corresponding predicate declaration which are predefined. In the following, we only focus on the atoms and their use for drawing and animation.

Drawing.
A drawing predicate is of the form: draw(c) where c is called a drawing command. Intuitively the atom containing this predicate draws texts and graphics as instructed by the command c. By drawing a picture, we mean a shape is drawn with a style. We define a shape as either text or a geometric line or curve. Also, a style specifies the physical visual properties of the shape it is applied to. For example, visual properties include color, thickness, and font. For modularity, we introduce style names, which are labels that can be associated with different styles so that the style may be reused without being redefined. A drawing is completed by associating this shape and style to a certain position in the canvas, which is simply the display board. Note, the origin of the coordinate system is at the top left corner of the canvas.Here is a an example of drawing a red line from point (0, 0) to  #b1  #b1 . First, we introduce a style name redline and associate it to the red color by the style command line color(redline, red). With this defined style we then draw the red line by the shape command draw line(redline, 0, 0, 2, 2). Style commands and shape commands form all drawing commands. The SPARC program rules to draw the given line are draw(line color(redline, red)). draw(draw line(redline, 0, 0, 2, 2)).The style commands of our system include the following: linewidth(sn, t) specifies that lines drawn with style name sn should be drawn with a line thickness t. textfont(sn, fs, ff) specifies that text drawn with style name sn should be drawn with a font size fs and a font family ff. linecap(sn, c) specifies that lines drawn with style name sn should be drawn with a capping c, such as an arrowhead. textalign(sn, al) specifies that text drawn with style name sn should be drawn with an alignment on the page al. line color(sn, c) specifies that lines drawn with style name sn should be drawn with a color c. textcolor(sn, c) specifies that text drawn with style name sn should be drawn with a color c.The shape commands include the following: draw line(sn, xs, ys, xe, ye) draws a line from starting point (xs, ys) to ending point (xe, ye) with style name sn; draw quad curve(sn, xs, ys, bx, by, xe, ye) draws a quadratic Bezier curve, with style name sn, from the current point (xs, ys) to the end point (xe, ye) using the control point (bx, by); draw bezier curve(sn, xs, ys, b1x, b1y, b2x, b2y, xe, ye) draws a cubic Bezier curve, using style name sn, from the current point (xs, ys) to the end point (xe, ye) using the control points (b1x, b1y) and (b2x, b2y); draw arc curve(sn, xs, ys, r, sa, se) draws an arc using style name sn and the arc is centered at (x, y) with radius r starting at angle sa and ending at angle se going in the clockwise direction; draw text(sn, x, xs, ys) prints value of x as text to screen from point (xs, ys) using style name sn.

Animation.
A frame, a basic concept in animation, is defined as a drawing. When a sequence of frames, whose content is normally relevant, is shown on the screen in rapid succession (usually 24, 25, 30, or 60 frames per second), a fluid animation is seemingly created. To design an animation, a designer will specify the drawing for each frame. Given that the order of frames matters, we give a frame a value equal to its index in a sequence of frames. We introduce the animate predicate animate(c, i) which indicates a desire to draw a picture at the i th frame using drawing command c and i starts from 0. The frames will be shown on the screen at a rate of 60 frames per second, and the i th frame will be showed at time (i * 1/60) (in a unit of second) from the start of the animation for a duration of 1/60 of a second.As an example, we would like to elaborate on an animation where a red box (with side length of 10 pixels) moves from the point (1, 70) to (200, 70). We will create 200 frames with the box (whose bottom left corner is) at point (i + 1, 70) in i th frame.Let the variable I be of a sort called frame, defined from 0 to some large number. In every frame I, we specify the drawing styling redline: animate(line color(redline, red), I).To make a box at the I th frame, we need to draw the box's four sides using the style associated with style name redline. The following describes the four sides of a box at any frame: bottom -(I +1, 70) to (I +1+10, 70), left -(I +1, 70) to (I + 1, 60), top -(I + 1, 60) to (I + 1 + 10, 60) and right -(I + 1 + 10, 60) to (I + 1 + 10, 70). Hence we have the rules Note that the drawing predicate produces the intended drawing throughout all the frames creating a static drawing. On the other hand, the animate predicate produces a drawing only for a specific frame.

Algorithm and Implementation
We first define our input and output: The input to the main algorithm is a SPARC program P . The output is an HTML5 program segment containing a canvas element which will be rendered by an Internet browser. A key part of our algorithm is to render the display atoms (specified in the answer set of P ) using canvas methods.HTML5 canvas element is used to draw graphics via scripting using JavaScript. In the following, we will use an example to demonstrate how a drawing command is implemented by JavaScript code using canvas methods. Consider again draw(line color(redline, red)). draw(draw line(redline, 0, 0, 2, 2)).When we render the shape command draw line, we need to know the meaning of the redline style. From the style command line color, we know it means red. We first create an object ctx for a given canvas (simply identified by a name) where we would like to render the display atoms. The object offers methods to render the graphics in the canvas. We then use the following JavaScript code to implement the shape command to draw a line from (0,0) to (2,2): ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(2,2); ctx.stroke();To make the line in red color, we have to insert the following JavaScript statement before the ctx.stroke() in the code above: ctx.strokeStyle="red";The meaning of the canvas methods in the code above is straightforward. We don't explain them further. Now we are in a position to present the algorithm.

Algorithm:
-Input: a SPARC program P with display predicates.-Output: a HTML program segment which allows the rendering of the display atoms in the answer set of P in an Internet Browser. -Steps:1. Call SPARC solver to obtain an answer set S of P . 2. Let script be an array of empty strings. script[i] will hold the JavaScript statements to render the graphics for i th frame. 3. For each display atom a in S,• If any error is found in the display atoms, present an error to the user detailing the incorrect usage of the atoms. • If a contains a shape command, let its style name be sn, find all style commands defining sn. For each style command, translate it into the corresponding JavaScript code P s on modifying the styling of the canvas pen. Then translate the shape command into JavaScript code P r that renders that command. Let P d be the proper combination of P s and P r to render a. * if a is an drawing atom, append P d to script[i] for every frame i of the animation. * if a is an animation atom, let i be the frame referred to in a.Append P d to script[i]. 4. Formulate the output program P as follows:• add, to P , the canvas element <canvas id="myCanvas" width="500" height="500"> </canvas>. • add, to P , the script element <script> </script> whose content includes * the JavaScript code to associate the drawings in this script element with the canvas element above. * an array drawings initialized by the content of script array. * Javascript code executing the statements in drawings[i] when the time to show frame i starts.End of algorithm.Implementation. The "Execute" button in the webpage (front end) of the online SPARC environment is for programmers to render the display atoms in the answer set of their programs. The Java program implementing our algorithm above is at the server side. When the "Execute" button is clicked, the programmer's SPARC program will be sent to the server side and the algorithm will be invoked with the program. The output (i.e., the canvas and script elements) of the algorithm will be sent back to the front end and the JavaScript in the front end will catch the output and insert it into the result display area of the front web page (See Figure 1). The Internet browser will then automatically render the updated web page and the drawing or animation will be rendered as a result. Example SPARC programs with drawing and animation can be found at https://goo.gl/nLD4LD.

Discussion and Related Work
As ASP has been applied to more and more problems, the importance of ASP software development tools has been realized by the community. Some integrated development environment (IDE) tools, e.g., APE  #b17 , ASPIDE  #b5 , iGROM [10] and SeaLion  #b15  have previously been developed. They provide a graphical user interface for users to carry out a sequence of tasks from editing an ASP program to debugging that program, easing the use of ASP significantly. However, the target audience of these tools is experienced software developers. Compared with the existing environments, our environment is online, self contained (i.e., fully independent of the users' local computers) and provides a very simple interface, focusing on teaching only. The interface is operable by any person who is able to use a typical web site and traverse a local file system.As for drawing and animation, our work is based on the work of Cliffe et al.  #b3 . They are the first to introduce, to ASP, a design of display predicates and to render drawings and animations using the program ASPviz. Our drawing commands are similar to theirs. The syntax of their animation atoms is not clear from their paper. It seems (from examples on github at goo.gl/kgUzJK accessed on 4/30/2017) that multiple answer sets may be needed to produce an animation. In our work we use a design where the programmers are allowed to draw at any frame (specifying a range of the frames) and the real time difference between two neighboring frames is 1/60 second. Another clear difference is that our implementation is online while theirs is a standalone software. A more recent system, Kara, a standalone software by Kloimullner et al.  #b9 , deals with drawing only. Another system ARVis  #b0  offers method to visualize the relations between answer sets of a given program. We also note an online environment for IDP (which is a knowledge representation paradigm close to ASP) by Dasseville and Janssens  #b4 . It also utilizes a very simple interface for the IDP system and allows drawing and animation using IDP through IDPD3 (a library to visualize models of logic theories) by Lapauw et al.  #b12 . In addition to drawing and animation, IDPD3 allows users' interaction with the IDP program (although in a limited manner in its current implementation), which is absent from most other systems including ours. Our environment is also different from the online IDP environment in that ours targets ASP and offers an online file system. Both DLV and Clingo offer online environments (http://asptut.gibbi.com/ and http://potassco.sourceforge.net/clingo.html respectively) which provide an editor and a window to show the output of the execution of dlv and clingo command, but provide no other functionalities. We also noted the SWISH (http://lpsdemo.interprolog.com) which offers an online environment for Prolog and a more recent computer language Logic-based Production Systems  #b11 . A unique functionality of our online environment is to query a program. It allows to teach (particular to general students) basics of Logic Programming without first touching the full concept of answer sets.When we outreached to a local high school before, we needed an experienced student to communicate with the school lab several times before the final installation of the software on their computers could be completed. A carefully drafted document is prepared for students to install the software on their computers. There are still unexpected issues during lab or when students use/install the software at home. These difficulties made it almost impossible to outreach to the high school with success. With the availability of our online environment, we only need to focus on the teaching content of ASP without worrying about the technical support. We hope our environment, and other online environments, for knowledge representation systems will expand the teaching of knowledge repre-sentation to a much wider audience in the future. The drawing and animation are new features of the online environment and was not tested in high school teaching. We have used the drawing and animation in a senior year coursespecial topics in AI -in spring 2017. Students demonstrated interests in drawing and animation and they were able to produce interesting animation. We also noted that it can be very slow for ASP solvers to produce the answer set of an animation program when the ground program is big.In the future, it will be interesting to have a more rigorous evaluation of the online environment.