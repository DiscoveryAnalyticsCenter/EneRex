Sum-of-Squares Proofs and the Quest toward Optimal Algorithms

Abstract
In order to obtain the best-known guarantees, algorithms are traditionally tailored to the particular problem we want to solve. Two recent developments, the Unique Games Conjecture (UGC) and the Sum-of-Squares (SOS) method, surprisingly suggest that this tailoring is not necessary and that a single efficient algorithm could achieve best possible guarantees for a wide range of different problems. The Unique Games Conjecture (UGC) is a tantalizing conjecture in computational complexity, which, if true, will shed light on the complexity of a great many problems. In particular this conjecture predicts that a single concrete algorithm provides optimal guarantees among all efficient algorithms for a large class of computational problems. The Sum-of-Squares (SOS) method is a general approach for solving systems of polynomial constraints. This approach is studied in several scientific disciplines, including real algebraic geometry, proof complexity, control theory, and mathematical programming, and has found applications in fields as diverse as quantum information theory, formal verification, game theory and many others. We survey some connections that were recently uncovered between the Unique Games Conjecture and the Sum-of-Squares method. In particular, we discuss new tools to rigorously bound the running time of the SOS method for obtaining approximate solutions to hard optimization problems, and how these tools give the potential for the sum-of-squares method to provide new guarantees for many problems of interest, and possibly to even refute the UGC. Mathematics Subject Classification (2010). Primary 68Q25; Secondary 90C22.

Introduction
A central mission of theoretical computer science is to understand which computational problems can be solved efficiently, which ones cannot, and what it is about a problem that makes it easy or hard. To illustrate these kind of questions, let us consider the following parameters of an undirected d-regular graph 1 G = (V, E):• The smallest connected component of G is the size of the smallest non-empty set S ⊆ V such that E(S, V \ S) = ∅.• The independent-set number of G is the size of the largest set S ⊆ V such that E(S, S) = ∅.• The (edge) expansion 2 of G, denoted φ G , is the minimum expansion φ G (S) of a vertex set S ⊆ V with size 1 ≤ |S| ≤ |V |/2, whereφ G (S) = |E(S, V \ S)| d|S| .The expansion φ G (S) measures the probability that a step of the random walk on G leaves S conditioned on starting in S.All these parameters capture different notions of well-connectedness of the graph G. Computing these can be very useful in many of the settings in which we use graphs to model data, whether it is communication links between servers, social connections between people, genes that are co-expressed together, or transitions between states of a system.The computational complexity of the first two parameters is fairly well understood. The smallest connected component is easy to compute in time linear in the number n = |V | of vertices by using, for example, breadth-first search from every vertex in the graph. The independent-set number is NP-hard to compute, which means that, assuming the widely believed conjecture that P = NP, it cannot be computed in time polynomial in n. In fact, under stronger (but still widely believed) quantitative versions of the P = NP conjecture, for every k it is infeasible to decide whether or not the maximum independent set is larger than k in time n o(k)  #b22  #b17  and hence we cannot significantly beat the trivial O(n k )-time algorithm for this problem. Similarly, while we can approximate the independent-set number trivially within a factor of n, assuming such conjectures, there is no polynomial-time algorithm to approximate it within a factor of n 1−ε(n) where ε(n) is some function tending to zero as n grows  #b28  #b29 .So, connectivity is an easy problem and independent set a hard one, but what about expansion? Here the situation is more complicated. We know that we can't efficiently compute φ G exactly, and we can't even get an arbitrarily good approximation  #b3 , but we actually do have efficient algorithms with nontrivial approximation guarantees for φ G . Discrete versions of Cheeger's inequality [Che70, Dod84, AM85, Alo86] yield such an estimate, namelyd−λ2 2d ≤ φ G ≤ 2 d−λ2 2d ,(1)E(S, T ) denote the set of edges {s, t} ∈ E with s ∈ S and t ∈ T . 2 The expansion of a graph is closely related to other quantities, known as isoperimetric constant, conductance or sparsest cut. These quantities are not identical but are the same up to scaling and a multiplicative factor of at most 2. Hence, they are computationally equivalent for our purposes. We also remark that expansion is often not normalized by the degree. However for our purposes this normalization is useful.where λ 2 (G) denotes the (efficiently computable) second largest eigenvalue of the G's adjacency matrix. 3 In particular, we can use (1) to efficiently distinguish between graphs with φ G close to 0 and graphs with φ G bounded away from 0. But can we do better? For example, could we efficiently compute a quantity c G such that c G ≤ φ G ≤ O(c 0.51 G )? We simply don't know. 4 This is not an isolated example, but a pattern that keeps repeating. Over the years, computer scientists have developed sophisticated tools to come up with algorithms on one hand, and hardness proofs showing the limits of efficient algorithms on the other hand. But those two rarely match up. Moreover, the cases where we do have tight hardness results are typically in settings, such as the independent set problem, where there is no way to significantly beat the trivial algorithm. In contrast, for problems such as computing expansion, where we already know of an algorithm giving non-trivial guarantees, we typically have no proof that this algorithm is optimal. In other words, the following is a common theme:If you already know an algorithm with non-trivial approximation guarantees for a problem, it's very hard to rule out that cleverer algorithms couldn't get even better guarantees.In 2002, Subhash Khot formulated a conjecture, known as the Unique Games Conjecture (UGC)  #b30 . A large body of follow up works has shown that this conjecture (whose description is deferred to Section 1.1 below) implies many hardness results that overcome the above challenge and match the best-known algorithms even in cases when they achieve non-trivial guarantees. In fact, beyond just resolving particular questions, this line of works obtained far-reaching complementary meta algorithmic and meta hardness results. By this we mean results that give an efficient meta algorithm A (i.e., an algorithm that can be applied to a family of problems, and not just a single one) that is optimal within a broad domain C, in the sense that (assuming the UGC) there is no polynomial-time algorithm that performs better than A on any problem in C. It is this aspect of the Unique Games Conjecture result that we find most exciting, and that shows promise of going beyond the current state where the individual algorithmic and hardness results form "isolated islands of knowledge surrounded by a sea of ignorance" 5 into a more unified theory of complexity.The meta-algorithm that the UGC predicts to be optimal is based on semidefinite programming and it uses this technique in a very particular and quite restricted way. (In many settings, this meta-algorithm can be implemented in near-linear time  #b58 .) We will refer to this algorithm as the UGC meta-algorithm. It can be viewed as a common generalization of several well known algorithms, including those that underlie Cheeger's Inequality, Grothendieck's Inequality  #b27 , the Goemans-Williamson Max Cut algorithm  #b23 , and the Lovász ϑ function  #b40 . As we've seen for the example of Cheeger's Inequality, in many of those settings this meta-algorithm gives non-trivial approximation guarantees which are the best known, but there are no hardness results ruling out the existence of better algorithms. The works on the UGC has shown that this conjecture (and related ones) imply that this meta-algorithm is optimal for a vast number of problems, including all those examples above. For example, a beautiful result of Raghavendra  #b46  showed that for every constraint-satisfaction problem (a large class of problems that includes many problems of interest such as Max k-SAT, k-Coloring, and Max-Cut), the UGC meta-algorithm gives the best estimate on the maximum possible fraction of constraints one can satisfy. Similarly, the UGC (or closely related variants) imply there are no efficient algorithms that give a better estimate for the sparsest cut of a graph than the one implied by Cheeger's Inequality  #b51  and no better efficient estimate for the maximum correlation of a matrix with ±1-valued vectors than the one given by Grothendieck's Inequality. 6 To summarize:If true, the Unique Games Conjecture tells us not only which problems in a large class are easy and which are hard, but also why this is the case. There is a single unifying reason, captured by a concrete meta-algorithm, that explains all the easy problem in this class. Moreover, in many cases where this meta-algorithm already gives non-trivial guarantees, the UGC implies that no further efficient improvements are possible.All this means that the Unique Games Conjecture is certainly a very attractive proposition, but the big question still remains unanswered-is this conjecture actually true? While some initial results supported the UGC, more recent works, although still falling short of disproving the conjecture, have called it into question. In this survey we discuss the most promising current approach to refute the UGC, which is based on the Sum of Squares (SOS) method  #b55  #b42  #b45  #b36 . The SOS method could potentially refute the Unique Games Conjecture by beating the guarantees of the UGC meta-algorithm on problems on which the conjecture implies the latter's optimality. This of course is interesting beyond the UGC, as it means we would be able to improve the known guarantees for many problems of interest. Alas, analyzing the guarantees of the SOS method is a very challenging problem, and we still have relatively few tools to do so. However, as we will see, we already know that at least in some contexts, the SOS method can yield better results than what was known before. The SOS method is itself a meta algorithm, so even if it turns out to refute the UGC, this does not mean we need to give up on the notion of explaining the complexity of wide swaths of problems via a single algorithm; we may just need to consider a different algorithm. To summarize, regardless of whether it refutes the UGC or not, understanding the power of the SOS method is an exciting research direction that could advance us further towards the goal of a unified understanding of computational complexity.1.1. The UGC and SSEH conjectures. Instead of the Unique Games Conjecture, in this survey we focus on a related conjecture known as the Small-Set Expansion Hypothesis (SSEH)  #b49 . The SSEH implies the UGC  #b49 , and while there is no known implication in the other direction, there are several results suggesting that these two conjectures are probably equivalent [RS10, RST10, RS09a, ABS10, BBH + 12]. At any rate, most (though not all) of what we say in this survey applies equally well to both conjectures, but the SSEH is, at least in our minds, a somewhat more natural and simpler-to-state conjecture.Recall that for a d-regular graph G = (V, E) and a vertex set S ⊆ V , we defined its expansion as φ G (S) = |E(S, V \ S)|/(d|S|). By Cheeger's inequality (1), the second largest eigenvalue yields a non-trivial approximation for the minimum expansion φ G = min 1≤|S|≤|V |/2 φ G (S), but it turns out that eigenvalues and similar methods do not work well for the problem of approximating the minimum expansion of smaller sets. The Small-Set Expansion Hypothesis conjectures that this problem is inherently difficult.Conjecture 1.1 (Small-Set Expansion Hypothesis  #b49 ). For every ε > 0 there exists δ > 0 such that given any graph G = (V, E), it is NP-hard to distinguish between the case (i) that there exists a subset S ⊆ V with |S| = δ|V | such that φ G (S) ≤ ε and the case (ii) that φ G (S) ≥ 1 − ε for every S with |S| ≤ δ|V |.As mentioned above, the SSEH implies that (1) yields an optimal approximation for φ G . More formally, assuming the SSEH, there is some absolute constant c > 0 such that for every φ ≥ 0, it is NP-hard to distinguish between the case that a given graph G satisfies φ G ≤ φ and the case that φ G ≥ c √ φ  #b51 . Given that the SSEH conjectures the difficulty of approximating expansion, the reader might not be so impressed that it also implies the optimality of Cheeger's Inequality. However, we should note that the SSEH merely conjectures that the problem becomes harder as δ becomes smaller, without postulating any quantitative relation between δ and ε, and so it is actually surprising (and requires a highly non-trivial proof) that it implies such quantitatively tight bounds. Even more surprising is that (through its connection with the UGC) the SSEH implies tight hardness result for a host of other problems, including every constraint satisfaction problem, Grothendieck's problem, and many others, which a priori seem to have nothing to do with graph expansion.Remark 1.2. While we will stick to the SSEH in this survey, for completeness we present here the definition of the Unique Games Conjecture. We will not use this definition in the proceeding and so the reader can feel free to skip this remark. The UGC can be thought of as a more structured variant of the SSEH where we restrict to graphs and sets that satisfy some particular properties. Because we restrict both the graphs and the sets, a priori it is not clear which of these conjectures should be stronger. However it turns out that the SSEH implies the UGC  #b49 . It is an open problem whether the two conjectures are equivalent, though the authors personally suspect that this is the case.We say that an n-vertex graph G = (V, E) is δ-structured if there is a partition of V into δn sets V 1 , . . . , V δn each of size 1/δ, such that for every i = j, eitherE(V i , V j ) = ∅ or E(V i , V j ) is a matching (namely for every u ∈ V i there is exactly one v ∈ V j such that {u, v} ∈ E). We say a set S ⊆ V is δ-structured if |S ∩ V i | = 1for all i (and so in particular, |S| = δn). The Unique Games Conjecture states that for every ε > 0 there exists a δ > 0 such that it is NP hard, given a δ-structured G, to distinguish between the case (i) that there exists a δ-structured S such that φ G (S) ≤ ε and the case (ii) that every δ-structured S satisfies φ G (S) ≥ 1 − ε. The conjecture can also be described in the form of so-called "two prover one round games" (hence its name); see Khot's surveys  #b31  #b32 .1.2. Organization of this survey and further reading. In the rest of this survey we describe the Sum of squares algorithm, some of its applications, and its relation to the Unique Games and Small-Set Expansion Conjectures. We start by defining the Sum of Squares algorithm, and how it relates to classical questions such as Hilbert 17 th problem. We will demonstrate how the SOS algorithm is used, and its connection to the UGC/SSEH, by presenting Cheeger's Inequality (1) as an instance of this algorithm. The SSEH implies that the SOS algorithm cannot yield better estimates to φ G than those obtained by (1). While we do not know yet whether this is true or false, we present two different applications where the SOS does beat prior works-finding a planted sparse vector in a random subspace, and sparse coding-learning a set of vectors A given samples of random sparse linear combinations of vectors in A. We then discuss some of the evidence for the UGC/SSEH, how this evidence is challenged by the SOS algorithm and the relation between the UGC/SSEH and the problem of (approximately) finding sparse vectors in arbitrary (not necessarily random) subspaces. Much of our discussion is based on the papers [ABS10, BGH + 12, BBH + 12,  #b14  #b13 . See also  #b8  #b10  #b9  for informal overviews of some of these issues.For the reader interested in learning more about the Unique Games Conjecture, there are three excellent surveys on this topic. Khot's CCC survey  #b32  gives a fairly comprehensive overview of the state of knowledge on the UGC circa 2010, while his ICM survey  #b31  focuses on some of the techniques and connections that arose in the works around the UGC. Trevisan  #b59  gives a wonderfully accessible introduction to the UGC, using the Max-Cut problem as a running example to explain in detail the UGC's connection to semidefinite programming. As a sign of how rapidly research in this area is progressing, this survey is almost entirely disjoint from  #b31  #b32  #b59 . While the former surveys mostly described the implications of the UGC for obtaining very strong hardness and "meta hardness" results, the current manuscript is focused on the question of whether the UGC is actually true, and more generally understanding the power of the SOS algorithm to go beyond the basic LP and SDP relaxations.Our description of the SOS algorithm barely scratches the surface of this fascinating topic, which has a great many applications that have nothing to do with the UGC or even approximation algorithms at large. The volume  #b15  and the monograph  #b38  are good sources for some of these topics. The SOS algorithm was developed in slightly different forms by several researchers, including Shor  #b55 , Nesterov  #b42 , Parrilo  #b45 , and Lasserre  #b36 . It can be viewed as a strengthening of other "meta-algorithms" proposed by  #b54  #b41  (also known as linear and semi-definite programming hierarchies). 7 Our description of the SOS meta algorithm follows Parrilo's, while the description of the dual algorithm follows Lasserre, although we use the pseudoexpectation notation introduced in [BBH + 12] instead of Lasserre's notion of "moment matrices". The Positivstellensatz/SOS proof system was first studied by Grigoriev and Vorobjov  #b26  and Grigoriev  #b25  proved some degree lower bounds for it, that were later rediscovered and expanded upon by  #b53  #b60 . All these are motivated by the works in real geometry related to Hilbert's 17 th problem; see Reznick's survey  #b52  for more on this research area. One difference between our focus here and much of the other literature on the SOS algorithm is that we are content with proving that the algorithm supplies an approximation to the true quantity, rather than exact convergence, but on the other hand are much more stringent about using only very low degree (preferably constant or polylogarithmic in the number of variables).

Sums of Squares Proofs and Algorithms
One of the most common ways of proving that a quantity is non-negative is by expressing it as a Sum of Squares (SOS). For example, we can prove the Arithmetic-Mean Geometric-Mean inequality ab ≤ a 2 /2 + b 2 /2 by the identity a 2 + b 2 − 2ab = (a − b) 2 . Thus a natural question, raised in the late 19 th century, was whether any non-negative (possibly multivariate) polynomial can be written as a sum of squares of polynomials. This was answered negatively by Hilbert in 1888, who went on to ask as his 17 th problem whether any such polynomial can be written as a sum of squares of rational functions. A positive answer was given by Artin  #b7 , and considerably strengthened by Krivine and Stengle. In particular, the following theorem is a corollary of their results, which captures much of the general case. Q 1 , . . . , Q m ∈ R[x] such that S ∈ R[x] is a sum of squares of polynomials and − 1 = S + Q i · P i .(2)We say that the polynomials S, Q 1 , . . . , Q m in the conclusion of the theorem form an SOS proof refuting the system of polynomial equations 8 E. Clearly the 7 See [Lau03] for a comparison. 8 In this survey we restrict attention to polynomial equalities as opposed to inequalities, which turns out to be without loss of generality for our purposes. If we have a system of polynomial inequalities {P 1 ≥ 0, . . . , Pm ≥ 0} for P i ∈ R[x], the Positivstellensatz certificates of infeasibility take the form −1 = α⊆[n] QαPα, where each Qα ∈ R[X] is a sum of squares and Pα = i∈α P i . existence of such polynomials implies that E is unsatisfiable-the interesting part of Theorem 2.1 is the other direction. We say that a SOS refutation S 1 , Q 1 , ..., Q m has degree ℓ if the maximum degree of the polynomials Q i P i involved in the proof is at most ℓ  #b26 . By writing down the coefficients of these polynomials, we see that a degree-ℓ SOS proof can be written using mn O(ℓ) numbers. 9 In the following lemma, we will prove a special case of Theorem 2.1, where the solution set of E is a subset of the hypercube {±1} n . Here, the degree of SOS refutations is bounded by 2n. (This bound is not meaningful computationally because the size of degree-Ω(n) refutations is comparable to the number of points in {±1} n .)Lemma 2.2. Let E = {P 0 = 0, x 2 1 − 1 = 0, . . . , x 2 n − 1 = 0} for some P 0 ∈ R[x]. Then, either the system E is satisfiable or it has a degree-2n SOS refutation.Proof. Suppose the system is not satisfiable, which means that P 0 (x) = 0 for all x ∈ {±1} n . Since {±1} n is a finite set, we may assume P 2 0 ≥ 1 over {±1} n . Now interpolate the real-valued function P 2 0 − 1 on {±1} n as a multilinear (and hence degree at most n) polynomial in R ∈ R[x]. Then, P 2 0 − 1 − R 2 is a polynomial of degree at most 2n that vanishes over {±1} n . (Since we can replace x 2 i by 1 in any monomial, we can assume without loss of generality that P 0 is multilinear and hence has degree at most n.) This means that we can writeP 2 0 − 1 − R 2 in the form n i=1 Q i ·(x 2 i −1) for polynomials Q i with Q i ≤ deg 2n−2.(This fact can be verified either directly or by using that x 2 1 − 1, . . . , x 2 n − 1 is a Gröbner basis for {±1} n .) Putting things together, we see that−1 = R 2 + (−P 0 ) · P 0 + n i=1 Q i · (x 2 i − 1), which is a SOS refutation for E of the form in Theorem 2.1.2.1. From proofs to algorithms. The Sum of Squares algorithm is based on the following theorem, which was discovered in different forms by several researchers:Theorem 2.3 (SOS Theorem [Sho87, Nes00, Par00, Las01], informally stated).If there is a degree-ℓ SOS proof refuting E = {P 1 = 0, . . . , P m = 0}, then such a proof can be found in mn O(ℓ) time.Proof sketch. We can view a degree-ℓ SOS refutation −1 = S + i Q i P i for E as a system of linear equations in mn O(ℓ) variables corresponding to the coefficients of the unknown polynomials S, Q 1 , . . . , Q m . We only need to incorporate the nonlinear constraint that S is a sum of squares. But it is not hard to see that a degree-ℓ polynomial S is a sum of squares if and only if there exists a positivesemidefinite matrix M such that S = α,α ′ M α,α ′ x α x α ′ , where α and α ′ range over all monomials x α and x α ′ of degree at most ℓ/2. Thus, the task of finding a However, we can transform inequalities {P i ≥ 0} to equivalent equalities {P ′ i = P i − y 2 i = 0}, where y 1 , . . . , ym are fresh variables. This transformation makes it only easier to find certificates, becauseα⊆[n] QαPα = S ′ + i Q ′ i P ′ i for S ′ = α⊆[n]Qαy 2 α , where yα = i∈α y i . It also follows that the transformation can only reduce the degree of SOS refutations.9 It can be shown that the decomposition of S into sums of squares will not require more than n ℓ terms; also in all the settings we consider, there are no issues of accuracy in representing real numbers, and so a degree ℓ-proof can be written down using mn O(ℓ) bits. degree-ℓ SOS refutation reduces to the task of solving linear systems of equations with the additional constraint that matrix formed by some of the variables is positive-semidefinite. Semidefinite programming solves precisely this task and is computationally efficient. 10 Remark 2.4 (What does "efficient" mean? ). In the applications we are interested in, the number of variables n corresponds to our "input size". The equation systems E we consider can always be solved via a "brute force" algorithm running in exp(O(n)) time, and so degree-ℓ SOS proofs become interesting when ℓ is much smaller than n. Ideally we would want ℓ = O(1), though ℓ = polylog(n) or even, say, ℓ = √ n, is still interesting.Theorem 2.3 yields the following meta algorithm that can be applied on any problem of the form minx∈R n : P1(x)=···=Pm(x)=0 P 0 (x)(3)where P 0 , P 1 , . . . , P m ∈ R[x] are polynomials. The algorithm is parameterized by a number ℓ called its degree and operates as follows:The degree-ℓ Sum-of-Squares AlgorithmInput: Polynomials P 0 , . . . , P m ∈ R[x] Goal: Estimate min P 0 (x) over all x ∈ R n such that P 1 (x) = . . . = P m (x) = 0Operation: Output the smallest value ϕ (ℓ) such that there does not exist a degree-ℓ SOS proof refuting the system,{P 0 = ϕ (ℓ) , P 1 = 0, . . . , P m (x) = 0} . 11We call ϕ (ℓ) the degree-ℓ SOS estimate for (3), and by Theorem 2.3 it can be computed in n O(ℓ) time. For the actual minimum value ϕ of (3), the corresponding system of equations {P 0 = ϕ, P 1 = 0, . . . , P m = 0} is satisfiable, and hence in particular cannot be refuted by an SOS proof. Thus, ϕ (ℓ) ≤ ϕ for any ℓ. Since higher degree proofs are more powerful (in the sense that they can refute more equations), it holds thatϕ (2) ≤ ϕ (4) ≤ ϕ (6) ≤ · · · ≤ min x∈R n : P1(x)=···=Pm(x)=0 P 0 (x) .(We can assume degrees of SOS proofs to be even.) As we've seen in Lemma 2.2, for the typical domains we are interested in Computer Science, such as when the 10 In this survey we ignore issues of numerical accuracy which turn out to be easily handled in our setting.11 As in other cases, we are ignoring here issues of numerical accuracy. Also, we note that when actually executing this algorithm, we will not need to check all the (uncountably many) values ϕ (ℓ) ∈ R, but it suffices to enumerate over a sufficiently fine discretization of the interval [−M, +M ] for some number M depending on the polynomials P 0 , . . . , Pm. This step can be carried out in polynomial time in all the settings we consider. set of solutions of {P 1 = 0, . . . , P m = 0} is equal to {±1} n , this sequence is finite in the sense that ϕ (2n) = min x∈{±1} n P 0 (x).The SOS algorithm uses semidefinite programming in a much more general way than many previous algorithms such as  #b40  #b23 . In fact, the UGC meta-algorithm is the same as the base case (i.e., ℓ = 2) of the SOS algorithm.Recall that the UGC and SSEH imply that in many settings, one cannot improve on the approximation guarantees of the UGC meta-algorithm without using exp(n Ω(1) ) time. Thus in particular, if those conjectures are true then in those settings, using the SOS meta algorithm with degree, say, ℓ = 10 (or even ℓ = polylog(n) or ℓ = n o(1) ) will not yield significantly better guarantees than ℓ = 2.Remark 2.5 (Comparison with local-search based algorithms). Another approach to optimize over non-linear problems such as (3) is to use local-search algorithms such as gradient descent that make local improvement steps, e.g., in the direction of the gradient, until a local optimum is reached. One difference between such local search algorithms and the SOS algorithm is that the latter sometimes succeeds in optimizing highly non-convex problems that have exponential number of local optima. As an illustration, consider the polynomialP (x) = n 4 n i=1 (x 2 i − x i ) 2 + ( n i=1 x i ) 2 .Its unique global minimum is the point x = 0, but it is not hard to see that it has an exponential number of local minima (for every x ∈ {0, 1} n , P (x) < P (y) for every y with y − x ∈ [1/n, 2/n], and so there must be a local minima in the ball of radius 1/n around x). Hence, gradient descent or other such algorithms are extremely likely to get stuck in one of these suboptimal local minima. However, since P is in fact a sum of squares with constant term 0, the degree-4 SOS algorithm will output P 's correct global minimum value.

Pseudodistributions and pseudoexpectations.
Suppose we want to show that the level-ℓ SOS meta-algorithm achieves a good approximation of the minimum value of P 0 over the set Z = {x ∈ R n | P 1 (x) = · · · = P m (x) = 0} for a particular kind of polynomials P 0 , P 1 , . . . , P m ∈ R[x]. Since the estimate ϕ (ℓ) always lower bounds this quantity, we are to show thatmin Z P 0 ≤ f (ϕ (ℓ) )(4)for some particular function f (satisfying f (ϕ) ≥ ϕ) which captures our approximation guarantee. (E.g., a factor c approximation corresponds to the function f (ϕ) = cϕ.) If we expand out the definition of ϕ (ℓ) , we see that to prove Equation (4) we need to show that for every ϕ if there does not exists a degree-ℓ proof that P 0 (x) = ϕ for all x ∈ Z, then there exists an x ∈ Z such that P 0 (x) ≤ f (ϕ). So, to prove a result of this form, we need to find ways to use the non-existence of a proof. Here, duality is useful.Pseudodistributions are the dual object to SOS refutations, and hence the non-existence of a refutation implies the existence of a pseudodistribution.We now elaborate on this, and explain both the definition and intuition behind pseudodistributions. In Section 3 we will give a concrete example, by showing how one can prove that degree-2 SOS proofs capture Cheeger's Inequality using such an argument. Results such as the analysis of the Goemans-Williamson Max Cut algorithm  #b23 , and the proof of Grothendieck's Inequality  #b27  can be derived using similar methods.Definition 2.6. Let R[x] ℓ denote the set of polynomials in R[x] of degree at most ℓ. A degree-ℓ pseudoexpectation operator for R[x] is a linear operator L that maps polynomials in R[x] ℓ into R and satisfies that L(1) = 1 and L(P 2 ) ≥ 0 for every polynomial P of degree at most ℓ/2.The term pseudoexpectation stems from the fact that for every distribution D over R n , we can obtain such an operator by choosing L(P ) = E D P for all P ∈ R[x]. Moreover, the properties L(1) = 1 and L(P 2 ) ≥ 0 turn out to capture to a surprising extent the properties of distributions and their expectations that we tend to use in proofs. Therefore, we will use a notation and terminology for such pseudoexpectation operators that parallels the notation we use for distributions. In fact, all of our notation can be understood by making the thought experiment that there exists a distribution as above and expressing all quantities in terms of low-degree moments of that distribution (so that they also make sense if we only have a pseudoexpectation operator that doesn't necessarily correspond to a distribution).In the following, we present the formal definition of our notation. We denote pseudoexpectation operators asẼ D , where D acts as index to distinguish different operators. IfẼ D is a degree-ℓ pseudoexpectation operator for R[x], we say that D is a degree-ℓ pseudodistribution for the indeterminates x. In order to emphasize or change indeterminates, we use the notationẼ y∼D P (y). In case we have only one pseudodistribution D for indeterminates x, we denote it by {x}. In that case, we also often drop the subscript for the pseudoexpectation and writeẼ P forẼ {x} P .We say that a degree-ℓ pseudodistribution {x} satisfies a system of polynomial equations {P 1 = 0, . . . , P m = 0} ifẼ Q · P i = 0 for all i ∈ [m] and all polynomials Q ∈ R[x] with deg Q · P i ≤ ℓ. We also say that {x} satisfies the constraint {P (x) ≥ 0} if there exists some sum-of-squares polynomial S ∈ R[x] such that {x} satisfies the polynomial equation {P = S}. It is not hard to see that if {x} was an actual distribution, then these definitions imply that all points in the support of the distribution satisfy the constraints. We write P 0 to denote that P is a sum of squares of polynomials, and similarly we write P Q to denote P − Q 0.The duality between SOS proofs and pseudoexpectations is expressed in the following theorem. We say that a system E of polynomial equations is explicitly bounded if there exists a linear combination of the constraints in E that has the form { i x 2 i + S = M } for M ∈ R and S ∈ R[x] a sum-of-squares polynomial. (Note that in this case, every solution x ∈ R n of the system E satisfies i x 2 i ≤ M .)Theorem 2.7. Let E = {P 1 = 0, . . . , P m = 0} be a set of polynomial equations withP i ∈ R[x].Assume that E is explicitly bounded in the sense above. Then, exactly one of the following two statements holds: (a) there exists a degree-ℓ SOS proof refuting E, or (b) there exists a degree-ℓ pseudodistribution {x} that satisfies E.Proof. First, suppose there exists a degree-ℓ refutation of the system E, i.e., there exists polynomials Q 1 , . . . , Q m ∈ R[x] and a sum-of-squares polynomial R ∈ R[x] so that −1 = R + i Q i P i and deg Q i P i ≤ ℓ. Let {x} be any pseudodistribution.We are to show that {x} does not satisfy E. Indeed,Ẽ i Q i P i = −Ẽ 1−Ẽ R ≤ −1, which means thatẼ Q i P i = 0 for at least one i ∈ [m]. Therefore, {x} does not satisfy E.Next, suppose there does not exist a degree-ℓ refutation of the system E. We are to show that there exists a pseudodistribution that satisfies E. Let C be the cone of all polynomials of the form R + i Q i P i for sum-of-squares R and polynomials Q i with deg Q i P i ≤ ℓ. Since E does not have a degree-ℓ refutation, the constant polynomial −1 is not contained in C. We claim that from our assumption that the system E is explicitly bounded it follows that −1 also cannot lie on the boundary of C. Assuming this claim, the hyperplane separation theorem implies that there exists a linear form L such that L(−1) < 0 but L(P ) ≥ 0 for all P ∈ C. By rescaling, we may assume that L(1) = 1. Now this linear form satisfies all conditions of a pseudoexpectation operator for the system E.Proof of claim. We will show that if −1 lies on the boundary of C, then also −1 ∈ C. If −1 is on the boundary of C, then there exists a polynomial P ∈ R[X] ℓ such that −1 + εP ∈ C for all ε > 0 (using the convexity of C). Since E is explicitly bounded, for every polynomial P ∈ R[X] ℓ , the cone C contains a polynomial of form N − P − R for a sum-of-square R and a number N . (Here, the polynomial N − P − R ∈ C is a certificate that P ≤ N over the solution set of E. Such a certificate is easy to obtain when E is explicitly bounded. We are omitting the details.) At this point, we see that −1 is a nonnegative combination of the polynomials −1 + εP , N − P − R, and R for ε < 1/N . Since these polynomials are contained in C, their nonnegative combination −1 is also contained in the cone C.Recipe for using pseudoexpectations algorithmically. In many applications we will use the following dual form of the SOS algorithm:The degree-ℓ Sum-of-Squares Algorithm (dual form) Input: Polynomials P 0 , . . . , P m ∈ R[x] Goal: Estimate min P 0 (x) over all x with P 1 (x) = . . . = P m (x) = 0 Operation: Output the smallest value ϕ (ℓ) such that there is a degree-ℓ pseudodistribution {x} satisfying the system,{P 0 = ϕ (ℓ) , P 1 = 0, . . . , P m (x) = 0} .Theorem 2.7 shows that in the cases we are interested in, both variants of the SOS algorithm will output the same answer. Regardless, a similar proof to that of Theorem 2.3 shows that the dual form of the SOS algorithm can also be computed in time n O(ℓ) . Thus, when using the SOS meta-algorithm, instead of trying to argue from the non-existence of a proof, we will use the existence of a pseudodistribution. Specifically, to show that the algorithm provides an f (·) approximation in the sense of (4), what we need to show is that given a degree-ℓ pseudodistribution {x} satisfying the system {P = ϕ, P 1 = 0, . . . , P m = 0}, we can find some particular x * that satisfies P (x * ) ≤ f (ϕ). Our approach to doing so (based on the authors' paper with Kelner  #b14 ) can be summarized as follows:Solve the problem pretending that {x} is an actual distribution over solutions, and if all the steps you used have low-degree SOS proofs, the solution still works even when {x} is a low-degree pseudodistribution.It may seem that coming up with an algorithm for the actual distribution case is trivial, as any element in the support of the distribution would be a good solution. However note that even in the case of a real distribution, the algorithm does not get sampling access to the distribution, but only access to its low-degree moments. Depending on the reader's temperament, the above description of the algorithm, which "pretends" pseudodistributions are real ones, may sound tautological or just wrong. Hopefully it will be clearer after the next two sections, where we use this approach to show how the SOS algorithm can match the guarantee of Cheeger's Inequality for computing the expansion, to find planted sparse vectors in random subspaces, and to approximately recover sparsely used dictionaries.

Approximating expansion via sums of squares
Recall that the expansion, φ G , of a d-regular graph G = (V, E) is the minimum of φ G (S) = |E(S, V \ S)||/(d|S|) over all sets S of size at most |V |/2. Letting x = 1 S be the characteristic vector 12 of the set S the expression |E(S, V \S)| can be written as {i,j}∈E (x i − x j ) 2 which is a quadratic polynomial in x. Therefore, for every k, computing the value φ G (k) = min |S|=k |E(S, V \ S)|/(dk) can be phrased as the question of minimizing a polynomial P 0 over the set of x's satisfying the equations{x 2 i − x i = 0} n i=1 and { n i=1 x i = k}. Let φ (ℓ(k))G be the degree-ℓ SOS estimate for φ G (k). We call φ (ℓ) G = min k≤n/2 φ G (k) the degree-ℓ SOS estimate for φ G . Note that φ (ℓ) G can be computed in n O(ℓ) time. For the case ℓ = 2, the following theorem describes the approximation guarantee of the estimate φ (ℓ) G .Theorem 3.1. There exists an absolute constant c such that for every graph G φ G ≤ c φ Before we prove Theorem 3.1, let us discuss its significance. Theorem 3.1 is essentially a restatement of Cheeger's Inequality in the SOS language-the degree 2-SOS algorithm is the UGC meta algorithm which is essentially the same as the algorithm based on the second-largest eigenvalue. 13 There are examples showing that (5) is tight, and so we cannot get better approximation using degree 2 proofs. But can we get a better estimate using degree 4 proofs? Or degree log n proofs? We don't know the answer, but if the Small-Set Expansion Hypothesis is true, then beating the estimate (5) is NP -hard, which means (under standard assumptions) that to do so we will need to use proofs of degree at least n Ω(1) .This phenomenon repeats itself in other problems as well. For example, for both the Grothendieck Inequality and the Max Cut problems, the SSEH (via the UGC) predicts that beating the estimate obtained by degree-2 proofs will require degree ℓ = n Ω(1) . As in the case of expansion, we have not been able to confirm or refute these predictions. However, we will see some examples where using higher degree proofs does help, some of them suspiciously close in nature to the expansion problem.One such example comes from the beautiful work of Arora, Rao and Vazirani  #b6  who showed thatφ G ≤ O( log n) · φ (6) G ,which is better than the guarantee of Theorem 3.1 for φ G ≪ 1/ log n. However, this is not known to contradict the SSEH or UGC, which apply to the case when φ G is a small constant.As we will see in Section 5, for the small set expansion problem of approximating φ G (S) for small sets S, we can beat the degree 2 bounds with degree ℓ = n τ proofs where τ is a parameter tending to zero with the parameter ε of the SSEH  #b4 . This yields a sub-exponential algorithm for the small-set expansion problem (which can be extended to the Unique Games problem as well) that "barely misses" refuting the SSEH and UGC. We will also see that degree O(1) proofs have surprising power in other settings that are closely related to the SSEH/UGC, but again at the moment still fall short of refuting those conjectures.3.1. Proof of Theorem 3.1. This proof is largely a reformulation of the standard proof of a discrete variant of Cheeger's Inequality, phrased in the SOS language of pseudodistributions, and hence is included here mainly to help clarify these notions, and to introduce a tool-sampling from a distribution matching first two moments of a pseudodistribution-that will be useful for us later on. By the dual formulation, to prove Theorem 3.1 we need to show that given a pseudodistribution {x} over characteristic vectors of size-k sets S of size k ≤ n/2 with |E(S, V \ S)| = ϕdk, we can find a particular set S * of size at most n/2 such that E(S * , V \S * ) ≤ O( √ ϕ)d|S * |. For simplicity, we consider the case k = n/2 (the other cases can be proven in a very similar way). The distribution {x} satisfies 13 The second-largest eigenvalue is directly related to the minimum value of ϕ such that there exists a degree-2 pseudodistribution satisfying the more relaxed system{ {ij}∈E (x i − x j ) 2 = ϕ · dn/2, i x i = n/2, i x 2 i = n/2}. the constraints { x i = n/2}, {x 2 i = x i } for all i, and { {i,j}∈E (x i − x j ) 2 = ϕd i x i }.The algorithm to find S * is quite simple:1. Choose (y 1 , . . . , y n ) from a random Gaussian distribution with the same quadratic moments as {x} so that E y i =Ẽ x i and E y i y j =Ẽ x i x j for all i, j ∈ [n]. (See details below.) 2. Output the set S * = {i | y i ≥ 1/2} (which corresponds to the 0/1 vector closest to y).We remark that the set produces by the algorithm might have cardinality larger than n/2, in which case we will take the complement of S * .Sampling from a distribution matching two moments. We will first give a constructive proof the well-known fact that for every distribution over R n , there exists an n-dimensional Gaussian distribution with the same quadratic moments. Given the moments of a distribution {x} over R n , we can sample a Gaussian distribution {y} matching the first two moments of {x} as follows. First, we can assume E x i = 0 for all i by shifting variables if necessary. Next, let v 1 , . . . , v n and λ 1 , . . . , λ n be the eigenvectors and eigenvalues of the matrix M i,j = E x i x j . (Note that M is positive semidefinite and so λ 1 , . . . , λ n ≥ 0.) Choose i.i.d random standard Gaussian variables w 1 , . . . , w n and define y = k √ λ k w k v k . Since E w k w k ′ equals 1 if k = k ′ and equals 0 otherwise,E y i y j = k λ k (v k ) i (v k ) j = M i,j .One can verify that if {x} is a degree-2 pseudodistribution then the second moment matrix M of the shifted version of x (such thatẼ x i = 0 for all i) is positivesemidefinite, and hence the above can be carried for pseudodistributions of degree at least 2 as well. Concretely, if we letx =Ẽ x be the mean of the pseudodistribution, then M =Ẽ(x −x)(x −x) ⊤ . This matrix is positive semidefinite because every test vector z ∈ R n satisfies z ⊤ M z =Ẽ z ⊤ (x −x) 2 ≥ 0.Analyzing the algorithm. The analysis is based on the following two claims: (i) the set S * satisfies n/3 ≤ |S * | ≤ 2n/3 with constant probability and (ii) inexpectation |E(S * , V \ S * )| ≤ O( √ ϕdn).We will focus on two extreme cases that capture the heart of the arguments for the claims. In the first case, all variables y i have very small variance so that E y 2 i ≈ (E y i ) 2 . In this case, because our constraints imply that E y 2 i = E y i , every variable satisfies either E y 2 i ≈ 0 or E y 2 i ≈ 1, which means that the distribution of the set S * produced by the algorithm is concentrated around a particular set, and it is easy to verify that this set satisfies the two claims. In the second, more interesting case, all variables y i have large variance, which means E y 2 i = 1/2 in our setting.In this case, each event {y i ≥ 1/2} has probability 1/2 and therefore E|S * | = n/2. Using that the quadratic moments of {y} satisfy E i y i = n/2 and E( i y i ) 2 = (n/2) 2 , one can show that these events cannot be completely correlated, which allows us to control the probability of the event n/3 ≤ |S * | ≤ 2n/3 and establishes (i). For the second claim, it turns out that by convexity considerations it suffices to analyze the case that all edges contribute equally to the term1 |E| {i,j}∈EẼ (x i − x j ) 2 = ϕ , so thatẼ(x i − x j ) 2 = ϕ for all {i, j} ∈ E.So we see that {y i , y j } is a 2-dimensional Gaussian distribution with mean ( 1 2 , 1 2 ) and covariance 14 1 1−2ϕ 1−2ϕ 1Thus, in order to bound the expected value of |E(S * , V \ S * )| , we need to bound the probability of the event "y i ≥ 1/2 and y j < 1/2" for this particular Gaussian distribution, which amounts to a not-too-difficult calculation that indeed yields an upper bound of O( √ ϕ) on this probability.

Machine learning with Sum of Squares
In this section, we illustrate the computational power of the sum-of-squares method with applications to two basic problems in unsupervised learning. In these problems, we are given samples of an unknown distribution from a fixed, parametrized family of distributions and the goal is to recover the unknown parameters from these samples. Despite the average-case nature of these problems, most of the analysis in these applications will be for deterministic problems about polynomials that are interesting in their own right.The first problem is sparse vector recovery. Here, we are given a random basis of a d-dimensional linear subspace U ⊆ R n of the formU = Span{x (0) , x (1) , . . . , x (d) } ,where x (0) is a sparse vector and x (1) , . . . , x (d) are independent standard Gaussian vectors. The goal is to reconstruct the vector x (0) . This is a natural problem in its own right, and is also a useful subroutine in various settings; see  #b19 . Demanet and Hand  #b19  gave an algorithm (based on  #b56 ) that recovers x (0) by searching for the vector x in U that maximizes x ∞ / x 1 (which can be done efficiently by n linear programs). It is not hard to show that x (0) has to have less than |n|/ √ d coordinates for it to be maximize this ratio, 14 and hence this was a limitation of prior techniques. In contrast, as long as d is not too large (namely, d = O( √ n)), the SOS method can recover x (0) as long as it has less than εn coordinates for some constant ε > 0  #b14 . The second problem we consider is sparse dictionary learning, also known as sparse coding. Here, we are given independent samples y (1) , . . . , y (R) ∈ R n from an unknown distribution of the form {y = Ax}, where A ∈ R n×m is a matrix and x is a random m-dimensional vector from a distribution over sparse vectors. This problem, initiated by the work Olshausen and Field  #b44  in computational neuroscience, has found a variety of uses in machine learning, computer vision, and image processing (see, e.g. [AAJ + 13] and the references therein). The appeal of this problem is that intuitively data should be sparse in the "right" representation (where every coordinate corresponds to a meaningful feature), and finding this representation can be a useful first step for further processing, just as representing sound or image data in the Fourier or Wavelet bases is often a very useful primitive. While there are many heuristics use to solve this problem, prior works giving rigorous recovery guarantees such as [SWW12, AAJ + 13, AGM13] all required the vector x to be very sparse, namely less than √ n nonzero entries. 15 In contrast, the SOS method can be used to approximately recover the dictionary matrix A as long as x has o(n) nonzero (or more generally, significant) entries  #b13 .4.1. Sparse vector recovery. We say a vector x is µ-sparse if the 0/1 indicator 1 supp x of the support of x has norm-squared µ = 1 supp x 2 2 . The ratio µ/ 1 2 2 is the fraction of non-zero coordinates in x. Theorem 4.1. There exists a polynomial-time approximation algorithm for sparse vector recovery with the following guarantees: Suppose the input of the algorithm is an arbitrary basis of a d + 1-dimensional linear subspace U ⊆ R n of the form U = Span{x (0) , x (1) . . . , x (d) } such that x (0) is a µ-sparse unit vector with µ ≤ ε · 1 2 2 and x (1) , . . . , x (d) are standard Gaussian vectors orthogonal to x (0) with d ≪ √ n. Then, with probability close to 1, the algorithm outputs a unit vector x that has correlation x,x (0) 2 ≥ 1 − O(ε) with x (0) .Our algorithm will follow the general recipe we described in Section 2.2:Find a system of polynomial equations E that captures the intended solution x (0) , then pretend you are given a distribution {u} over solutions of E and show how you could recover a single solution u * from the low order moments of {u}.Specifically, we come up with a system E so that desired vector x (0) satisfies all equations, and it is essentially the only solution to E. Then, using the SOS algorithm, we compute a degree-4 pseudodistribution {u} that satisfies E. Finally, as in Section 3.1, we sample a vector u * from a Gaussian distribution that has the same quadratic moments as the pseudodistribution {u}.How to encode this problem as a system of polynomial equations? By Cauchy-Schwarz, any µ-sparse vector x satisfies x 2 2 ≤ x 2 2p · 1 supp x q = x 2 2p · µ 1−1/p for all p, q ≥ 1 with 1/p + 1/q = 1. In particular, for p = 2, such vectors satisfy x 4 4 ≥ x 4 2 /µ. This fact motivates our encoding of sparse vector recovery as a system of polynomial equations. If the input specifies subspace U ⊆ R n , then we compute the projector P into the subspace U and choose the following polynomial equations: u 2 2 = 1 and P u 4 4 = 1/µ 0 , where µ 0 = x (0) 4 2 / x (0) 4 4 . (We assume here the algorithm is given µ 0 ≤ µ as input, as we can always guess a sufficiently close approximation to it.) 15 If the distribution x consists of m independent random variables then better guarantees can be achieved using Independent Component Analysis (ICA)  #b18 . See  #b24  for the current state of art in this setting. However we are interested here in the more general case.Why does the sum-of-squares method work? The analysis of algorithm has two ingredients. The first ingredient is a structural property about projectors of random subspaces.Lemma 4.2. Let U ′ ⊆ R n be a random d-dimensional subspace with d ≪ √ n and let P ′ be the projector into U ′ . Then, with high probability, the following sum-of-squares relation over R[u] holds for µ ′ ≥ Ω(1) · 1 2 2 ,P ′ u 4 4 u 4 2 /µ ′ .Proof outline. We can write P ′ = B ⊤ B where B is a d × n matrix whose rows are an orthogonal basis for the subspace U ′ . Therefore, P ′ u = B ⊤ x where x = Bu, and so to prove Lemma 4.2 it suffices to show that under these conditions, B ⊤ x 4 4 O( x 4 2 / 1 4 2 ). The matrix B ⊤ will be very close to having random independent Gaussian entries, and hence, up to scaling, B ⊤ x 4 4 will be (up to scaling), close to Q(x) = 1 n w i , x 4 where w 1 , . . . , w d ∈ R d are chosen independently at random from the standard Gaussian distribution. The expectation of w, x 4 is equal 3 i,j x 2 i x 2 j = 3 x 4 2 . Therefore, to prove the lemma, we need to show that for n ≫ d 2 , the polynomial Q(x) is with high probability close to its expectation, in the sense that the d 2 × d 2 matrix corresponding to Q's coefficients is close to its expectation in the spectral norm. This follows from standard matrix concentration inequalities, see [BBH + 12, Theorem 7.1 16 ]).The following lemma is the second ingredient of the analysis of the algorithm. Note that the conclusion of Lemma 4.3 implies that a vector u * sampled from a Gaussian distribution with the same quadratic moments as the computed pseudodistribution also satisfies E u * P ′ u * 2 2 ≤ 4(µ/µ ′ ) 1/4 and E u * 2 2 = 1. By Markov inequality, u * − x (0) 2 2 ≤ 16(µ/µ ′ ) 1/4 holds with probability at least 3/4. Since u * is Gaussian, it satisfies u * 2 2 ≥ 1/4 with probability at least 1/2. If both events occur, which happens with probability at least 1/4, then u * , x (0) 2 ≥ (1 − O(µ/µ ′ )) u * 2 2 , thus establishing Theorem 4.1.Proof of Lemma 4.3 There are many ways in which pseudodistributions behave like actual distributions, as far as low degree polynomials are concerned. To prove Lemma 4.3, we need to establish the following two such results:Lemma 4.4 (Hölder's inequality for pseudoexpectation norms). Suppose a and b are nonnegative integers that sum to a power of 2. Then, every degree-(a + b) pseudodistribution {u, v} satisfiesE E i u a i v b i ≤ Ẽ E i u a+b i a/(a+b) · Ẽ E i v a+b i b/(a+b).Proof sketch. The proof of the general case follows from the case a = b = 2 by an inductive argument. The proof for the case a = b = 1 follows from the fact that the polynomial α Proof. The inequality is invariant with respect to the measure used for the inner norm · 4 . For simplicity, supposeE i u 2 i + β E i v 2 i − √ αβ E i u i v i ∈ R[u, v] isx 4 4 = E x 4 i . Then, u + v 4 4 = E i u 4 i + 4 E i u 3 i v i + 6 E i u i v 3 i + E i v 4 i . Let A =Ẽ E i u 4 i and B =Ẽ E i v 4 i .Then, Lemma 4.5 allows us to bound the pseudoexpectations of the terms E i u a i v b i , so that as desiredE u + v 4 4 ≤ A + 4A 3/4 B 1/4 + 6A 1/2 B 1/2 + 4A 1/3 B 3/4 + B = (A 1/4 + B 1/4 ) 4 .We By the premises of the lemma, A =Ẽ α 4 0 /µ 0 and B ≤ 1/µ ′ . Together with the previous bound, it follows that (Ẽ α 4 0 ) 1/4 ≥ 1 − (µ 0 /µ ′ ) 1/4 . Since α 2 0 u 2 2 and {u} satisfies u 2 2 = 1, we haveẼ α 2 0 ≥Ẽ α 4 0 ≥ 1 − 4(µ 0 /µ ′ ) 1/4 . Finally, using u − x (0) 2 2 = u 2 2 − α 2 0 , we derive the desired boundẼ u − x (0) 2 2 = 1 −Ẽ α 2 0 ≤ 4(µ 0 /µ ′ ) 1/4 thus establishing Lemma 4.5 and Theorem 4.1.

Sparse dictionary learning.
A κ-overcomplete dictionary is a matrix A ∈ R n×m with κ = m/n ≥ 1 and isotropic unit vectors as columns (so thatA ⊤ u 2 2 = κ u 2 2 ). We say a distribution {x} over R m is (d, τ )-nice if it satisfies E i x d i = 1 and E i x d/2 i x d/2 j ≤ τ for all i = j ∈ [m], and it satisfies that non-square monomial degree-d moments vanish so that E x α = 0 for all non-square degree-d monomials Theorem 4.6. For every ε > 0 and κ ≥ 1, there exists d and τ and a quasipolynomialtime algorithm algorithm for sparse dictionary learning with the following guarantees: Suppose the input consists of n O(1) independent samples 17 from a distribution {y = Ax} over R n , where A ∈ R n×m is a κ-overcomplete dictionary and the distribution {x} over R m is (d, τ )-nice. Then, with high probability, the algorithm outputs a set of vectors with Hausdorff distance 18 at most ε from the set of columns of A.Encoding as a system of polynomial equations. Let y (1) , . . . , y (R) be independent samples from the distribution {y = Ax}. Then, we consider the poly-nomial P = 1 R i y (i) , u d ∈ R[u] d .Using the properties of nice distributions, a direct computation shows that with high probability P satisfies the relationA ⊤ u d d − τ u d 2 P A ⊤ u d d + τ u d 2 .(Here, we are omitting some constant factors, depending on d, that are not important for the following discussion.) It follows that P (a (i) ) = 1 ± τ for every column a (i) of A. It's also not hard to show that every unit vector a * with P (a * ) ≈ 1 is close to one of the columns of A. (Indeed, every unit vector satisfies P (a * ) ≤ max i a (i) , a * d−2 κ + τ . Therefore, P (a * ) ≈ 1 implies that a (i) , a * 2 ≥ κ −Ω(1/d) , which is close to 1 for d ≫ log κ.) What we will show is that pseudodistributions of degree O(log n) allow us to find all such vectors.Why does the sum-of-squares method work? In the following, ε > 0 and κ ≥ 1 are arbitrary constants that determine constants d = d(ε, κ) ≥ 1 and τ = τ (ε, κ) > 0 (as in the theorem). 1 ED W 2Ẽ D W 2 · u 2 − a (i) , u 2 ≤ ε .IfẼ D is a pseudoexpectation operator, thenẼ D ′ : P →Ẽ W 2 P/Ẽ W 2 is also a pseudoexpectation operator (as it satisfies linearity, normalization, and nonnegativity). (This transformation corresponds to reweighing the pseudodistribution 17 Here, we also make the mild assumption that the degree-2d moments of x are bounded by n O(1) . 18 The Hausdorff distance between two sets of vectors upper bounds the maximum distance of a point in one of the sets to its closest point in the other set. Due to the innate symmetry of the sparse dictionary problem (replacing a column a (i) of A by −a (i) might not affect the input distribution), we measure the Hausdorff distance after symmetrizing the sets, i.e., replacing the set S by S ∪ −S. 19 Here, a random linear form means a polynomial u, v ∈ R[u] where v is a random unit vector in R n . D by the polynomial W 2 .) Hence, the conclusion of the lemma gives us a new pseudodistribution D ′ such thatẼ D ′ u 2 2 − a (i) , u 2 ≤ ε. Therefore, if we sample a Gaussian vector a * with the same quadratic moments as D ′ , it satisfies a * 2 2 − a (i) , a * 2 ≤ 4ε with probability at least 3/4. At the same time, it satisfies a * 2 ≥ 1/4 with probability at least 1/2. Taking these bounds together, a * satisfies a (i) , a * 2 ≥ (1 − 16ε) a * 2 with probability at least 1/4. Lemma 4.7 allows us to reconstruct one of the columns of A. Using similar ideas, we can iterate this argument and recover one-by-one all columns of A. We omit the proof of Lemma 4.7, but the idea behind it is to first give an SOS proof version of our argument above that maximizers of P must be close to one of the a (i) 's. We then note that if a distribution D is supported (up to noise) on at most m different vectors, then we can essentially isolate one of these vectors by re-weighing D using the product of the squares of O(log m) random linear forms.It turns out, this latter argument has a low degree SOS proof as well, which means that in our case that given D satisfying the constraint {P (u) = 1 − τ }, we can isolate one of the a (i) 's even when D is not an actual distribution but merely a pseudodistribution.

Hypercontractive norms and small-set expansion
So far we have discussed the Small-Set Expansion Hypothesis and the Sum of Squares algorithm. We now discuss how these two notions are related. One connection, mentioned before, is that the SSEH predicts that in many settings the guarantees of the degree-2 SOS algorithm are best possible, and so in particular it means that going from degree 2 to say degree 100 should not give any substantial improvement in terms of guarantees. Another, perhaps more meaningful connection is that there is a candidate approach for refuting the SSEH using the SOS algorithm. At the heart of this approach is the following observation:The small-set expansion problem is a special case of the problem of finding "sparse" vectors in a linear subspace.This may seem strange, as a priori, the following two problem seem completely unrelated: (i) Given a graph G = (V, E), find a "small" subset S ⊆ V with low expansion φ G (S), and (ii) Given a subspace W ⊆ R n , find a "sparse" vector in W . The former is a combinatorial problem on graphs, and the latter a geometric problem on subspaces. However, for the right notions of "small" and "sparse", these turn out to be essentially the same problem. Intuitively, the reason is the following: the expansion of a set S is proportional to the quantity x ⊤ Lx where x is the characteristic vector of S (i.e. x i equals 1 if i ∈ S and equals 0 otherwise), and L is the Laplacian matrix of G (defined as L = I − d −1 A where I is the identity, d is the degree, and A is G's adjacency matrix). Let v 1 , . . . , v n be the eigenvectors of L and λ 1 , . . . , λ n the corresponding eigenvalues. Thenx ⊤ Lx = n i=1 λ i v i , x 2 .Therefore if x ⊤ Lx is smaller than ϕ x 2 and c is a large enough constant, then most of the mass of x is contained in the subspace W = Span{v i : λ i ≤ cϕ}.Since S is small, x is sparse, and so we see that there is a sparse vector that is "almost" contained in W . Moreover, by projecting x into W we can also find a "sparse" vector that is actually contained in W , if we allow a slightly softer notion of "sparseness", that instead of stipulating that most coordinates are zero, only requires that the distribution of coordinates is very "spiky" in the sense that most of its mass is dominated by the few "heavy hitters".Concretely, for p > 1 and δ ∈ (0, 1), we say that a vector x ∈ R n is (δ, p)-sparseif E i x 2p i ≥ δ 1−p (E i x 2 i ) p .Note that a characteristic vector of a set of measure δ is (δ, p)-sparse for any p. The relation between small-set-expansion and finding sparse vectors in a subspace is captured by the following theorem: The first direction of Theorem 5.1 follows from the above reasoning, and was known before the work of [BBH + 12]. The second direction is harder, and we omit the proof here. The theorem reduces the question of determining whether there for small sets S, the minimum of φ G (S) is close to one or close to zero, into the question of bounding the maximum of E i x 2p i over all unit vectors in some subspace. The latter question is a polynomial optimization problem of the type the SOS algorithm is designed for! Thus, we see that we could potentially resolve the SSEH if we could answer the following question:What is the degree of SOS proofs needed to certify that the 2p-norm is bounded for all (Euclidean norm) unit vectors in some subspace W ?We still don't know the answer to this question in full generality, but we do have some interesting special cases. Lemma 4.2 of Section 4.1 implies that if W is a random subspace of dimension ≪ √ n then we can certify that E i x 4 i ≤ O(E i x 2 i ) 2 for all x ∈ W via a degree-4 SOS proof. This is optimal, as the 4-norm simply won't be bounded for dimensions larger than √ n:Lemma 5.2. Let W ⊆ R n have dimension d and p ≥ 2, then there exists a unit vector x ∈ W such thatE i x 2p i ≥ d p n (E i x 2 i ) pHence in particular any subspace of dimension d ≫ n 1/p contains a (o(1), p)sparse vector.Proof of Lemma 5.2. Let P be the matrix corresponding to the projection operator to the subspace W . Note that P has d eigenvalues equalling 1 and the rest equal 0, and hence Tr(P ) = d and the Frobenius norm squared of P , defined as P 2 i,j , also equals d. Let x i = P e i where e i is the i th standard basis vector. Thenx i i is the trace of P which equals d and hence using Cauchy-Schwarz(x i i ) 2 ≥ 1 n x i 2 = Tr(P ) 2 n = d 2 n .On the other hand,i j (x i ) 2 j = i,j (P e i ) 2 j = P 2 i,j = d .Therefore, by the inequality ( a i )/( b i ) ≤ max a i /b i , there exists an i such that if we let x = x i then x 2 i ≥ d n j x 2 j = d E x 2 j . Hence, just the contribution of the i th coordinate to the expectation achieves E j x 2p j ≥ d p n E j x 2 j p .Lemma 5.2 implies the following corollary:Corollary 5.3. Let p, n ∈ N, and W be subspace of R n . IfE i x 2p i ≤ O(E i x 2 i ) p ), then there is an O(n 1/p )-degree SOS proof for this fact. (The constants in the O(·) notation can depend on p but not on n.) Proof sketch. By Lemma 5.2, the condition implies that d = dim W ≤ O(n 1/p ), and it is known that approximately bounding a degree-O(1) polynomial on the ddimensional sphere requires an SOS proof of at most O(d) degree (e.g., see  #b21  and the references therein).Combining Corollary 5.3 with Theorem 5.1 implies that for every ε, δ there exists some τ (tending to zero with ε), such that if we want to distinguish between the case that an n-vertex graph G satisfies φ G (S) ≤ ε for every |S| ≤ δn, and the case that there exists some S of size at most δn with φ G (S) ≥ 1 − ε, then we can do so using a degree n τ SOS proofs, and hence in exp(O(n τ )) time. This is much better than the trivial n δn time algorithm that enumerates all possible sets. Similar ideas can be used to achieve an algorithm with a similar running time for the problem underlying the Unique Games Conjecture  #b4 . If these algorithms could be improved so the exponent τ tends to zero with n for a fixed ε, this would essentially refute the SSEH and UGC.Thus, the question is whether Corollary 5.3 is the best we could do. As we've seen, Lemma 4.2 shows that for random subspaces we can do much better, namely certify the bound with a constant degree proof. Two other results are known of that flavor. Barak, Kelner and Steurer  #b14  showed that if a d-dimensional subspace W does not contain a (δ, 2)-sparse vector, then there is an O(1)-degree SOS proof that it does not contain (or even almost contains) a vector with O( δn d 1/3 ) nonzero coordinates. If the dependence on d could be eliminated (even at a significant cost to the degree), then this would also refute the SSEH. Barak, Brandão, Harrow, Kelner, Steurer and Zhou [BBH + 12] gave an O(1)-degree SOS proof for the so-called "Bonami-Beckner-Gross (2, 4) hypercontractivity theorem" (see [O'D14, Chap. 9]). This is the statement that for every constant k, the subspace W k ⊆ R 2 t containing the evaluations of all degree ≤ k polynomials on the points {±1} t does not contain an (o(1), 2)-sparse vector, and specifically satisfies for all x ∈ W k ,E x 4 i ≤ 9 k (E x 2 i ) 2 .(6)On its own this might not seem so impressive, as this is just one particular subspace. However, this particular subspace underlies much of the evidence that has been offered so far in support of both the UGC and SSEH conjectures. The main evidence for the UGC/SSEH consists of several papers such as [KV05, KS09, RS09a, BGH + 12] that verified the predictions of these conjectures by proving that various natural algorithms indeed fail to solve some of the computational problems that are hard if the conjectures are true. These results all have the form of coming up with a "hard instance" G on which some algorithm A fails, and so to prove such a result one needs to do two things: (i) compute (or bound) the true value of the parameter on G, and (ii) show that the value that A outputs on G is (sufficiently) different than this true value. It turns out that all of these papers, the proof of (i) can be formulated as low degree SOS proof, and in fact the heart of these proofs is the bound (6). Therefore, the results of [BBH + 12] showed that all these "hard instances" can in fact be solved by the SOS algorithm using a constant degree. This means that at the moment, we don't even have any example of an instance for the problems underlying the SSEH and UGC that can be reasonably conjectured (let alone proved) hard for the constant degree SOS algorithm. This does not mean that such instances do not exist, but is suggestive that we have not yet seen the last algorithmic word on this question.

Footnote
1 : An undirected d-regular graph G = (V, E) consists of a set of vertices V , which we sometimes identify with the set [n] = {1, . . . , n} for some integer n, and a set of edges E, which are 
3 : The adjacency matrix of a graph G is the |V | × |V | matrix A with 0/1 entries such thatAu,v = 1 iff {u, v} ∈ E.
6 : See[RS09b] for the precise statement of Grothendieck's Inequality and this result. Curiously, the UGC implies that Grothendieck's Inequality yields the best efficient approximation factor for the correlation of a matrix with ±1-valued vectors even though we don't actually know the numerical value of this factor (known as Grothendieck's constant).
14 : See Lemma 5.2 below for a related statement.
16 : The reference is for the arxiv version arXiv:1205.4484v2 of the paper.
2 : -element subsets of V , such that every vertex is part of exactly d edges. The assumption that G is regular is not important and made chiefly for notational simplicity. For vertex sets S, T ⊆ V , we let
4 :  As we will mention later, there are algorithms to approximate φ G up to factors depending on the number n of vertices, which give better guarantees than (1) for graphs where φ G is sufficiently small as a function of n.
5 :  Paraphrasing John Wheeler.