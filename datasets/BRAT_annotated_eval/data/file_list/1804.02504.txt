SCALABLE SENTIMENT FOR SEQUENCE-TO-SEQUENCE CHATBOT RESPONSE WITH PERFORMANCE ANALYSIS

Abstract
Conventional seq2seq chatbot models only try to find the sentences with the highest probabilities conditioned on the input sequences, without considering the sentiment of the output sentences. Some research works trying to modify the sentiment of the output sequences were reported. In this paper, we propose five models to scale or adjust the sentiment of the chatbot response: persona-based model, reinforcement learning, plug and play model, sentiment transformation network and cycleGAN, all based on the conventional seq2seq model. We also develop two evaluation metrics to estimate if the responses are reasonable given the input. These metrics together with other two popularly used metrics were used to analyze the performance of the five proposed models on different aspects, and reinforcement learning and cycleGAN were shown to be very attractive. The evaluation metrics were also found to be well correlated with human evaluation.

INTRODUCTION
Unlike goal-oriented dialogue systems  #b0  #b1 , a chatbot is aimed to chat with human users on any subject domain of daily lives  #b2  #b3 . The conventional chatbot is based on a seq2seq model  #b4  to generate meaningful responses given the user input. It is in general emotionless, and this is a major limitation of chatbots today because the emotion plays a critical role in human social interactions especially in chatting  #b5 . So we wish to train the chatbot to generate responses with scalable sentiment by setting the mode for chatting. For example, for an input, "How was your day today?", the chatbot may respond, "It is wonderful today" or "It is terrible today" depending on the sentiment set, in addition to simply generating a reasonable response. The mode can either be set by the developer or the user, or determined dynamically based on the context of the dialogue. The techniques mentioned here may be extended to conversational style adjustment, so the machine may imitate the conversational style of someone the user is familiar with, to make the chatbot more friendly or more personal  #b6  #b7 .Substantial effort has been made focused on the conversation fluency and content quality of the generated responses, for example, by enriching the content diversity  #b8  #b9  #b10 , considering some additional information  #b11 , addressing unknown words  #b12  #b13  and so on. Some works tried to generate responses with controllable factors. The sentiment of a given sentence was successfully modified using non-parallel data  #b14 . A chatbot which can change the style of responses by optimizing a given function related to the sentiment was also developed  #b15 . However, not too much work has been reported on scaling the sentiment of a chatbot, and how to properly evaluate a chatbot with adjustable sentiment is still a difficult problem  #b16  #b17 .In this paper, we propose five approaches to scale the sentiment of chatbot responses and a set of evaluation metrics, and use these metrics to analyze the proposed approaches. The five proposed approaches are: persona-based model, reinforcement learning, plug and play model, sentiment transformation network and cycleGAN, all based on the seq2seq model. The set of four metrics to evaluate and analyze the different aspects of the chatbot responses are: two regarding if the responses are appropriate for the input; one regarding if the sentiment of the responses are properly modified; one regarding if the responses are grammatically good without considering the input. We then analyze the proposed approaches with these metrics, and find reinforcement learning and cycleGAN are very attractive.

PROPOSED APPROACHES
Section 2.1 briefly reviews the conventional seq2seq chatbot which was the basic model used by all the five proposed approaches presented in Section 2.2. Below we assume we wish to make the chatbot response positive conditioned on the input, although it is easy to generalize the approaches to scalable sentiment.

Seq2seq Model (baseline)
Here we use attention-based seq2seq model  #b18  as in Figure 1 to train a simple chatbot using a corpus of dialogue pairs. In all discussions here, x is the input sentence to the seq2seq chatbot, and y is the output of the seq2seq model.ŷ is the reference response in the training corpus. In training phase, we input the sentence x (a sequence of one-hot vectors) to the encoder, and the seq2seq model learns to maximize the probability of generating the sentenceŷ given x. 

The Five Proposed Approaches


Persona-Based Model
Persona-based model was originally proposed to generate sentences mimicking the responses of specific speakers  #b11 . It is very close to the seq2seq model, except adding extra information to the input of arXiv:1804.02504v1 [cs.CL] 7 Apr 2018 In the original work  #b11 , this extra information is the trained speaker embedding. Here we replace the speaker embedding with a sentiment score (a scalar between 0 and 1) from a sentiment classifier as in Figure 2. This sentiment classifier  #b19  is trained with a corpus of sentences with labeled sentiments to determine a sentence is positive or not. The input of the classifier is a sentence z, and the output is a score SC(z) between 0 and 1 indicating how positive the input is. The input of the decoder at every time step is then the concatenation of the word embedding and a sentiment score. During training the sentiment score of the reference sentence SC(ŷ) is used, and the decoder learns to generate the reference sentence. For testing given the same input, we are able to scale the sentiment of the output by entering the desired sentiment score.

Reinforcement Learning
Here exactly the same seq2seq chatbot as in Figure 1 is used, except we design a set of reward functions to scale the response sentiment with reinforcement learning. Three components of the reward functions are developed as follow.(1) Semantic Coherence 1: The response y should be semantically coherent to the input x, in addition to being a good sentence. So we pre-trained a different seq2seq model on a large dialogue corpus to estimate this semantic coherence with a probability P coh (y|x). The first reward is therefore:R1 = 1 Ny · logP coh (y|x),(1)where x and y denote the input and response of the baseline seq2seq chatbot (not the pre-trained seq2seq model), and Ny is the length of y for normalization.(2) Semantic Coherence 2: The semantic coherence mentioned above can be estimated in a completely different way. We use the same dialogue corpus to train a RNN discriminator, in which two RNN encoders are used to represent the input x and output y as two embeddings, and these two embeddings are concatenated and followed by a fully connected layer to produce a score DRNN (x, y) between 0 and 1, to indicate if x and y are good dialogue pairs. This score is therefore the second reward,R2 = DRNN (x, y),(2)(3) Sentiment Score: The third reward is based on the sentiment classifier mentioned above in Section 2.2.1,R3 = SC(y),(3)where y is the seq2seq chatbot response.The total reward is then the linear interpolation of the three rewards mentioned above,R = α · R1 + β · R2 + (1 − α − β) · R3(4)where α and β are hyper-parameters ranging from 0 to 1. We employ the reinforcement learning algorithm with policy gradient  #b20 .

Plug and Play Model


Fig. 3. Plug and play model. VRAE denotes variational recurrent auto-encoder
We borrow the concept of plug and play previously used to generate images  #b21  to generate dialogue response here, as shown in Figure 3. Here we pre-train a variational recurrent auto-encoder (VRAE)  #b22  in addition using the same dialogue corpus. The encoder of VRAE on the left transforms a sentence y into a fixed-length latent vector h0, while the decoder of VRAE on the middle right generates a sentence y based on a vector h . The encoder and decoder of VRAE is also jointly learned from the dialogue corpus for the chatbot.The following steps happens on-line when the user enters a sentence. Given an input x, the seq2seq baseline first generates a response y, which is then encoded into a latent code h0 by the VRAE encoder. Then the latent code h0 is modified into h , based on the following equation:h = argmax h [γ · SC(Decoder(h)) − δ · M SE(h, h0)],(5)where SC denotes the sentiment classifier, γ and δ are the weights of the loss function term and the regularization term. The first term on the right-hand side of Eq.(5), means we are looking for a code h such that when it is decoded into a sentence Decoder(h) using VRAE decoder, whose sentiment score SC(Decoder(h)) should be maximized. The second term of Eq.(5) prevents the code h being drifted too far from h0. To solve Eq.(5), we calculate the gradient of the sentiment score with respect to the latent code h and apply gradient ascent to the latent code iteratively 1 , until the sentiment score output reaches a pre-defined value. Because Eq.(5) has to be solved on-line after the user enters an input sentence, this approach is more time consuming.

Sentiment Transformation Network
This is very similar to the plug and play model previously mentioned in Section 2.2.3 and Figure 3, except here a sentiment transformation network T θ with parameter set θ is learned, and h = T θ (h0), or T θ maps the latent code h0 to a vector h , or to maximize the objective function with respect to θ instead of h. So Eq.(5) is replaced by:θ = argmax θ [ ·SC(Decoder(T θ (h0)))−δ·M SE(h, h0)],(6)where and δ are the weights of the loss function term and regularization term. During training, we fix the weights of pre-trained VRAE and sentiment classifier but randomly initialize and then update the sentiment transformation network. During testing, the code h0 is adjusted by the sentiment transformation network T θ learned in Eq.  #b5 , which generates the response. Here we adopt the very powerful cycleGAN, which was shown very successful in image style transformation even without paired data  #b24 . Here we show the way to use cycleGAN to transform the sentiment of sentences from negative to positive as in Figure 4. The model is trained with two sets of sentences in a corpus with labeled sentiments: positive sentiment set P and negative sentiment set N . The sentences in the two sets are unpaired, or for a given sentence in P, it is not known which sentence in N corresponds to it. We train two seq2seq translators, G transforming a negative sentence yn into positive and F from positive yp to negative. We also train two discriminators, DP and DN . DP and DN takes a sequence of word embeddings as input and learn to distinguish whether this sequence is the word embeddings of a real sentence or generated by G or F . With the continuous word embeddings as the translator output, the gradient can be back-propagated from the discriminator to the translator. It's worth mentioning that F and G transform sequences of word embeddings to sequences of word embeddings. We pre-train the word embedding model with Word2Vec  #b25  and it is fixed during training the cycleGAN here. To transform the output sequence of word embeddings into a sentence, we simply select those words whose embedding has the highest cosine-similarity to each given word embedding in the sequence.The concept of W-GAN  #b26  is used to train DP and DN . The loss function of the discriminator DP is:L(DP ) = DP (G(yn)) − DP (yp),(7)Where yn is a negative sentence sampled from N , and G(yn) is the output of the translator G taking yn as the input. DP learns to minimize Eq.(7), or to give as low score to the translated output as possible (the first term on the right) and give as high score to real positive sentence yp as possible (the second term). The loss function of the discriminators DN is parallel to Eq.(7),L(DN ) = DN (F (yp)) − DN (yn).(8)As in Improved W-GAN, gradient penalty is applied here. The loss functions for training the translators G and F are: G(F (yp))) + M SE(yn, F (G(yn)))]L(F ) = 2[M SE(yp,− DN (F (yp)),

L(G) = 2[M SE(yp, G(F (yp))) + M SE(yn, F (G(yn)))]
− DP (G(yn)).The first terms on the right-hand side of Eqs.  #b8  and (10) are the same. Given a positive sentence yp, after transformed into a negative sentence by F and then transformed back to positive by G, it should be very close to the original sentence yp. Similar for the second terms. The last terms of Eqs.(9) and (10) are different. F learns to generate output F (yp) considered by DN as a real negative sentence, while G learns to generate output G(yn) considered by DP as a real positive sentence. In this way the translators F , G learn to transform the sentences from one sentiment (positive or negative) to the other. Notice that the discriminators DP . DN are jointly trained with the translators F , G. During testing, for any chatbot output y, we simply use G to transform it into a positive sentence G(y).

EVALUATION METRICS
Evaluation is always difficult in language generation, especially for chatbot. Here we propose two metrics: sentiment coherence 1 and 2 (COH1, COH2) specially for chatbots, which give scores regarding whether the output sentence y is a proper response to the input sentence x or not. They are in fact the Semantic Coherence 1 and 2 mentioned in Reinforcement Learning in Section 2.2.2 designed for the reward function. But the seq2seq model and the RNN discriminator use to obtain these two scores were re-trained here therefore are slightly different models, although trained with the same corpus.The third metric is the Sentiment Classifier Score (SCL) used to measure how positive the output sentence is. This is in fact the sentiment classifier score SC(y) used in the Persona-based model mentioned in Section 2.2.1. But the sentiment classifier used here is re-trained therefore is slightly different, although trained with the same corpus. The fourth metric is the Language Model Score (LM) to check if the output sentence y is a good sentence in terms of a language model  #b27 . The language model used here was trained on the one billion word language modeling benchmark  #b28  using a two-layer GRU  #b29  model,LM Score = 1 Ny · logP (y),(11)which is the language model probability P (y) for a sentence y but normalized with the sentence length Ny. Note that the third and fourth metrics, SCL and LM, consider the output sentence y only but not the input x. The first and second metrics, COH1 and COH2, however, consider the output y given the input x.

EXPERIMENTS AND RESULTS


Experimental Setup
We trained all our models including the seq2seq baseline and the five proposed models using the Twitter chatting corpus available on Marsan-Ma's github repository  #b30  using tensorflow. It contains about 3.7M of dialogue pairs. The whole corpus is split into training and validation set. The latter included 28k dialogue pairs. The sentiment classifier used in this work was trained from the twitter sentiment analysis corpus  #b31 , which consists of 15M data with labeled sentiment (0 or 1). This corpus was also split into training and validation set. The trained sentiment classifier reached 87% of accuracy on validation set. We trained six models, including the seq2seq baseline and the five models proposed, using the training set and evaluated these models using the validation set. The four evaluation metrics obtained are the average over the validation data.

Experimental Results
The results are listed in Table 1. Notice that the seq2seq baseline in the first row was used in the five proposed models, therefore we didn't modify the sentiment for output of that model. 

Discussion on the Results
First consider the seq2seq baseline model. The sentiment classifier score (SCL) is 0.543 which is close to 0.5. This means the baseline model was more or less un-biased on positive or negative sentiments. So it is a reasonable baseline. Below we divide the discussions on the proposed models into two parts considering the different architectures of these models.

Persona-Based Model and Reinforcement Learning
These two models directly modified the seq2seq model's output, so the parameters of the seq2seq model were changed. For the persona-based model, the SCL score is extremely high but on the other hand its COH1 score is extremely low. This is probably because we fed the model with the sentiment distribution from a pre-trained sentiment classifier, and as a result the model overfitted on this sentiment distribution. Therefore, it tries to output sentences not necessarily coherent to input, but with correct sentiment. We noticed that its output very often contained two phrases in one sentence, hence the language model score is lower than the other models. The Reinforcement Learning model performed better than all other models in three out of the four metrics: COH1, COH2 and LM, except for the SCL score. This is because the reward R1 and R2 in Eqs.(1),  #b1  were in parallel with COH1 and COH2, and R1 in Eq.(1) also considered the word ordering which gave high LM score. Its SCL score was also high (except not as high as the overfitted Persona-based model) because its reward R3 is also in parallel with SCL, which made the output positive. Due to the sampling mechanism, the reinforcement learning model was able to generate diverse responses which other models couldn't achieve.From the data we also observed both the Persona-based and reinforcement learning models were able to make complicated changes to the output sentences which were rarely seen on other models.

Plug and Play, Sentiment Transformation Network and Cy-cleGAN
Instead of modifying the parameters of the seq2seq model, these three models modify the responses after they are generated by the seq2seq model.Plug and Play and Sentiment Transformation Network both tried to modify the latent code of the sentences and they both used the gradient of the sentiment classifier. The sentiment classifier primarily considered the sentiment without really encoding the semantics of the sentences, hence when maximizing the sentiment classifier's output, the information from original input may be lost. This is probably why COH1 and COH2 scores of these two models are both lower than most of the others.For CycleGAN, since the two translators directly output word embeddings carrying both sentiment and semantics, the translators were capable of finding the mapping between words like "bad" to "good", "sorry" to "thank", "can't" to "can". However, it could only change or delete some specific words but failed to make complex modification for the whole sentences. Since it only changes a few words of the original responses, the COH1, COH2 scores were not too far from the seq2seq baseline.Some examples are shown on the following link: goo.gl/ X1PZLM.  Table 2. Human evaluation scores on the three questions regarding Coherence, Sentiment and Grammar. The average scores were normalized to from 0 to 1. We performed subjective human evaluation with 30 subjects, all of whom were graduates students. They were asked to answer three questions about the output sentences: (1) Coherence: Is the output sentence a good response to the input? (2) Sentiment: Is the output sentence positive? (3) Grammar: Is the output sentence grammatically correct? They were asked to give scores ranging from 0 to 5, based on a few reference examples with given scores 1, 3, 5 to scale the scores. The average results (normalized to from 0 to 1) are listed in Table 2.

Human Evaluation
Since the subjective human evaluation questions are parallel to the objective machine evaluation scores, we calculate the Pearson correlation coefficients ρ between Coherence, Sentiment and Grammar scores in Table 2 with respect to COH1, SCL, and LM scores in Table 1. The results are 0.728, 0.885 and 0.543 respectively. This showed the machine evaluation metrics used here were well correlated to the human evaluation.

CONCLUSION
In this paper, we try to scale or adjust the sentiment of the chatbot response given the input. We propose five different models for this tasks, all based on the conventional seq2seq model. We also propose two metrics to evaluate if the response is good for the given input. After careful evaluation and analysis for the five proposed models on different aspects, we found among the five proposed models, Reinforcement Learning and CycleGAN were the most attractive. The reinforcement learning was able to learn properly the different design goals and offer output sentences with good diversity. The cycleGAN model primarily performed word mapping on the original response, so the output sentence quality was more or less preserved. The Plug and Play model and Sentiment Transformation Network were not as successful at the moment, probably because it is not easy to modify the latent code of the sentences while preserving the semantics and sentence quality.

Footnote
1 : Since the argmax layer between the decoder and sentiment classifier in SC(Decoder(h)) is non-differentiable, we use soft argmax[24] to approximate argmax and then the gradient can be back-propagated throughout the whole network, from the sentiment classifier to the decoder.