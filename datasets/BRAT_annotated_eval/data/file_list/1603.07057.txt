Do We Really Need to Collect Millions of Faces for Effective Face Recognition?

Abstract
Face recognition capabilities have recently made extraordinary leaps. Though this progress is at least partially due to ballooning training set sizes -huge numbers of face images downloaded and labeled for identity -it is not clear if the formidable task of collecting so many images is truly necessary. We propose a far more accessible means of increasing training data sizes for face recognition systems. Rather than manually harvesting and labeling more faces, we simply synthesize them. We describe novel methods of enriching an existing dataset with important facial appearance variations by manipulating the faces it contains. We further apply this synthesis approach when matching query images represented using a standard convolutional neural network. The effect of training and testing with synthesized images is extensively tested on the LFW and IJB-A (verification and identification) benchmarks and Janus CS2. The performances obtained by our approach match state of the art results reported by systems trained on millions of downloaded images.

Introduction
The recent impact of deep Convolutional Neural Network (CNN) based methods on machine face recognition capabilities has been nothing short of revolutionary. The conditions under which faces can now be recognized and the numbers of faces which systems can now learn to identify improved to the point where some consider machines to be better than humans at this task. This remarkable advancement is partially due to the gradual improvement of new network designs which offer better performance. However, alongside developments in network architectures, it is also the underlying ability of CNNs to learn from massive training sets that allows these techniques to be so effective.Realizing that effective CNNs can be made even more effective by increasing their training data, many begun focusing efforts on harvesting and labeling large image collections to better train their networks. In  #b34 , a standard CNN was trained by Facebook using 4.4 million labeled faces and shown to achieve what was, at the time, state of the art performance on the Labeled Faces in the Wild (LFW) benchmark  #b10 . Some time later,  #b23  proposed the VGG-Face representation, trained on 2.6 million faces, and Face++ proposed its Megvii arXiv:1603.07057v2 [cs.CV] 11 Apr 2016 Dataset #ID #Img #Img/#ID Google  #b28  8M 200M 25 Facebook  #b34  4,030 4.4M 1K VGG Face  #b23  2,622 2.6M 1K MegaFace  #b11  690,572 1.02M 1.5 CASIA  #b43  10,575 494,414 46 Aug. pose+shape  $b10   #b43  (also shown in the last two rows of (a)).System  #b44 , trained on 5 million faces. All, however, pale in comparison to the Google FaceNet  #b28  which used 200 million labeled faces for its training. Making networks better by collecting and labeling huge training sets is, unfortunately, not an easy game to play. The effort required to download, process and label millions of images from the Internet with reliable subject names is daunting. To emphasize this, the bigger sets,  #b34  and  #b28 , required the efforts of large scale commercial organizations to assemble (Facebook and Google, resp.) and none of these sets was publicly released by its owners. By comparison, the largest face recognition training set which is publicly available is the CASIA WebFace collection  #b43  weighing in at a mere 495K images, several orders of magnitudes smaller than the two bigger commercial sets 1 .But downloading and labeling so many faces is more than just financially challenging. Fig. 1a provides some statistical information on the larger face sets. Evidently, set sizes increase far faster than the numbers of images per-subject. This may imply that finding many images verified as belonging to the same subjects is difficult even when resources are abundant. Regardless of the reason, this is a serious problem: face recognition systems should learn to model not just inter-class appearance variations (differences between different people) but also intra-class variations (differences of appearance that do not change subject label) and so far this has been a challenge for data collection efforts.In light of these challenges, it is natural to ask: is there no alternative to this labor intensive, data download and labeling approach to pushing recognition performance? Beyond potentially mitigating the challenges of data collection, this question touches a more fundamental issue. Namely, should images be processed with domain specific tools before being analyzed by CNNs, and if so, how?In answer to these questions, we make the following contributions. (1) We propose synthesizing data in addition to collecting it. We inflate the size of an existing training set, the CASIA WebFace collection  #b43 , to several times its size using domain specific methods designed for face image synthesis (Fig. 1b). We generate images which introduce new intra-class facial appearance variations, including pose (Sec. 3.1), shape (Sec. 3.2) and expression (Sec.  $b3 

.3). (2)
We describe a novel matching pipeline which uses similar synthesis methods at test time when processing query images. Finally, (3), we rigorously test our approach on the LFW  #b10 , IJB-A (verification and identification) and CS2 benchmarks  #b13 . Our results show that a CNN trained using these generated faces matches state of the art performance reported by systems trained on millions of faces downloaded from the web and manually processed 2 .We note that our approach can be considered a novel face data augmentation method (Sec. 2): A domain specific data augmentation approach. Curiously, despite the success of existing generic augmentation methods, we are unaware of previous reports of applying the easily accessible approach described here to generate face image training data, or indeed training for any other class.

Related work
Face recognition: Face recognition is one of the central problems in computer vision and, as such, work on this problem is extensive. As with many other computer vision problems, face recognition performances sky rocketed with the introduction of deep learning techniques and in particular CNNs. Though CNNs have been used for face recognition as far back as  #b16 , only when massive amounts of data became available did their performance soar. This was originally demonstrated by the Facebook DeepFace system  #b34 , which used an architecture not unlike the one used by  #b16 , but with over 4 million images used for training they obtained far more impressive results.Since then, CNN based recognition systems continuously cross performance barriers with some notable examples including the Deep-ID 1-3 systems  #b33  #b31  #b32 . They and many others since, developed and trained their systems using far fewer training images, at the cost of somewhat more elaborate network architectures.Though novel network architecture designs can lead to better performance, further improvement can be achieved by collecting more training data. This has been demonstrated by the Google FaceNet team  #b28 , who developed and trained their system on 200 million images. Besides improving results, they also offered a fascinating analysis of the consequences of adding more data: apparently, there is a significant diminishing returns effect when training with increasing image numbers. Thus, the leap in performance obtained by going from thousands of images to millions is substantial but increasing the numbers further provides smaller and smaller benefits. One way to explain this is that the data they and others used suffers from a long tail phenomenon  #b43 , where most subjects in these huge datasets have very few images available for the network to learn intra-subject appearance variations from.These methods were all evaluated on the LFW dataset, which has been for some time a standard de facto for measuring face recognition performances. Many of these LFW results, however, are already reaching near-perfect performances, suggesting that LFW is no longer a challenging benchmark for today's systems. Another relevant benchmark, also frequently used to report performances, is the YouTube Faces (YTF) set  #b37 . It contains unconstrained face videos rather than images, but it too is quickly being saturated.Recently, a new benchmark was released in order to again push machine face recognition capabilities, the Janus set  #b13 . It offers several novelties compared to existing sets, including template based, rather than image based, recognition and a mix of both images and videos. It is also tougher than previous collections. Not surprisingly, dominating performance on Janus are CNN methods such as  #b3 .Data augmentation: Data augmentation techniques are transformations applied to the images used for training or testing, but without altering their labels. Such methods are well known to improve the performance of CNN based methods and prevent overfitting  #b2 . These methods, however, typically involved generic image processing operations which do not exploit knowledge of the underlying problem domain to synthesize new appearance variations.Popular augmentation methods include simple, geometric transformations such as oversampling (multiple, translated versions of the input image obtained by cropping at different offsets)  #b15  #b17 , mirroring (horizontal flipping)  #b2  #b41 , rotating  #b38  the images as well as various photometric transformations  #b15  #b29  #b6 . Surprisingly, despite being widely recognized as highly beneficial to the training of CNN systems, we are unaware of previous attempts to go beyond these simple transformations as we proposed doing. One notable exception is the recent work of  #b20  which proposes to augment training data for a person reidentification network by replacing image backgrounds. We propose a far more elaborate, yet easily accessible means of data augmentation.Finally, we note that the recent work of  #b39  describes a so-called task-specific data augmentation method. They, as well as  #b40 , do not synthesize new data as we propose to do here, but rather offer additional means of collecting images from the Internet to improve learning in fine grained recognition tasks. This is, of course, very different from our own approach.Face synthesis for face recognition: The idea that face images can be synthetically generated in order to aid face recognition systems is not new. To our knowledge, it was originally proposed in  #b8  and then effectively used by  #b34  and  #b9 . Contrary to us, they all produced frontal faces which are presumably better aligned and easier to compare. They did not use other transformations to generate new images (e.g., other poses, facial expressions). More importantly, their images were used to reduce appearance variability, whereas we propose the opposite: to dramatically increase it to improve both training and testing. 

Synthesizing faces
In this section we detail our approach to augmenting a generic face dataset. We use the CASIA WebFace collection  #b43 , enriching it with substantially more per-subject appearance variations, yet without changing subject labels or losing meaningful information. Specifically, we propose to generate (synthesize) new face images, by introducing the following face specific appearance variations:1. Pose: Simulating face image appearances across unseen 3D viewpoints. 2. Shape: Producing facial appearances using different 3D generic face shapes. 3. Expression: Specifically, simulating closed mouth expressions.As previously mentioned, (1) can be considered an extension of frontalization techniques  #b9  to multiple views. Conceptually, they rendered new views to reduce variability for better alignment whereas we do this to increase variability to better capture intra-subject appearance variations. Also noteworthy is that (2) explicitly contradicts previous assumptions on the importance of 3D facial shape in recognizing faces (e.g.,  #b34 ): Contrary to these claims -that shape carries important subject related information -we ignore these cues by rendering the same face using different underlying shapes. As we later show, this introduces subtle appearance variations which provide meaningful information at training, but by no means change perceived subject identities.

Pose variations
In order to generate unseen viewpoints given a face image I, we use a technique similar to the frontalization proposed by  #b9 . We begin by applying the facial landmark detector from  #b1 . Given these detected landmarks we estimate the six degrees of freedom pose for the face in I using correspondences between the detected landmarks p i ∈ R 2 and points P i . = S(i) ∈ R 3 , labeled on a 3D generic face model S. Here, i indexes specific facial landmarks in I and the 3D shape S.As mentioned earlier, we use CASIA faces for augmentation. These faces are roughly centered in their images, and so detecting face bounding boxes was unnecessary. Instead, we used a fixed bounding box determined once beforehand.Given the corresponding landmarks p i ↔ P i we use PnP  #b7  to estimate extrinsic camera parameters, assuming the principal point is in the image center and then refining the focal length by minimizing landmark re-projection errors. This process gives us a perspective camera model mapping the generic 3D shape S on the image such asp i ∼ M P i where M = K [R t] is the camera matrix.Given the estimated pose M, we decompose it to obtain a rotation matrix R ∈ R 3×3 containing rotation angles for the 3D head shape with respect to the image. We then create new rotation matrices R θ ∈ R 3×3 for unseen (novel) viewpoints by sampling different yaw angles θ. In particular, since CASIA images are biased towards frontal faces, given an image I we render it at the fixed yaw values θ = {0 • , ±40 • , ±75 • }. Rendering itself is derived from  #b9 , including softsymmetry. Fig. 2 shows viewpoint (pose) synthesis results for a training subject in CASIA, illustrating the 3D pose estimation process.Note that in practice, faces are rendered with a uniform black background not shown here (original background from the image was not preserved in rendering).

3D shape variations
In the past, some argued that to truthfully capture the appearance of a subject's face under different viewpoints, its true 3D form must be used for the rendering. They therefore attempted to estimate this 3D shape from the image directly prior to frontalization  #b34 . Because this reconstruction process is unstable, particularly for challenging, unconstrained images, Hassner et al.  #b9  instead used a single generic 3D face to frontalize all face images. We propose the following simple compromise between these two approaches.Rather than using a single generic 3D shape or estimating it from the image directly, we extend the procedure described in Sec. 3.1 to multiple generic 3D faces. In particular we add the set of generic 3D shapes S = {S j } 10 j=1 . We then simply repeat the pose synthesis procedure with these ten shapes rather than using only a single 3D shape. We used 3D generic shapes from the publicly available Basel 3D face set  #b24 . It includes 10 high quality 3D face scans captured from different people with different face shapes. The subjects vary in gender, age, and weight. The models are further well aligned to each other, hence requiring 3D landmarks to be selected only once, on one of these 3D faces, and then directly transferring them to the other nine models. Fig. 3 shows the ten generic models used here, along with images rendered to near profile view using each of these shapes. Clearly, subjects in these images remain identifiable, despite the different underlying 3D shape, meeting the augmentation requirement of not changing subject labels. Yet each image is slightly but noticeably different from the rest, introducing appearance variations to this subject's image set.

Expression variations
In addition to pose and shape, we also synthesize expression variations, specifically reducing deformations around the mouth. Given a face image I and its 2D detected landmarks p i , and following pose estimation (Sec. 3.1) we estimate facial expression by fitting a 3D expression Blendshape, similarly to  #b18 . This is a linear combination of 3D generic face models with various basis expressions, including mouth-closed, mouth-opened and smile. Following alignment of the 3D face model and the 2D face image in both pose and expression, we perform image-based texture mapping to register the face texture onto the model. This is useful to quickly assign texture to our face model given that only one image is available. To synthesize expression, we manipulate the 3D textured face model to exhibit new expressions and render it back to the original image. This technique allows us to render a normalized expression where other image details, including hair and background, remain unchanged. In our experiments we do this to produce images with closed mouths. Some example synthesis results are provided in Fig. 4. Though slight artifacts are sometimes introduced by this process (some can be seen in Fig. 4) these typically do not alter the general facial appearances and are less pronounced than the noise often present in unconstrained images.

Face recognition pipeline
Data augmentation techniques are not restricted to training and are often also applied at test time. Our augmentations provide opportunities to modify the matching process by using different augmented versions of the input image. We next describe our recognition pipeline including these and other novel aspects.

CNN training with our augmented data
Augmented training data: Our pipeline employs a single CNN trained on both real and augmented data generated as described in Sec. 3. Specifically, training data is produced from the original CASIA WebFace images. It consists of the following types of images: (i) original CASIA images following alignment by a simple, in-plane similarity transform to two coordinate systems:  (Fig. 1b).CNN fine-tuning: We use the very deep VGGNet  #b29  CNN with 19 layers, trained on the large scale image recognition benchmark (ILSVRC)  #b25 . We fine tune this network using our augmented data. To this end, we keep all layers{W k , b k } 19k=1 of VGGNet except for the last linear layer (FC8) which we train from scratch. This layer produces a mapping from the embedded feature x ∈ R D (FC7) to the subject labels N = 10, 575 of the augmented dataset. It computes y = W 19 x + b 19 , where y ∈ R N is the linear response of FC8. Fine-tuning is performed by minimizing the soft-max loss:L({W k , b k }) = − t ln e y l N g=1 e yg(1)where l is the ground-truth index over N subjects and t indexes all training images. Eq. (1) is optimized using Stochastic Gradient Descent (SGC) with standard L2 norm over the learned weights. When performing back-propagation, we learn FC8 faster since it is trained from scratch while other network weights are updated with a learning rate an order of magnitude lower than FC8. Specifically, we initialize FC8 with parameters drawn from a Gaussian distribution with zero mean and standard deviation 0.01. Bias is initialized with zero.The overall learning rate µ for the entire CNN is set to 0.001, except FC8 which uses learning rate of µ × 10. We decrease learning rate by an order of magnitude once validation accuracy for the fine tuned network saturates. Meanwhile, biases are learned twice as fast as the other weights. For all the other parameter settings we use the same values as originally described in  #b15 .

Face recognition with synthesized faces
General matching process: After training the CNN, we use the embedded feature vector x = f (I; {W k , b k }) from each image I as a face representation. Given two input images I p and I q , their similarity, s(x p , x q ) is simply the normalized cross correlation (NCC) of their feature vectors.The value s(x p , x q ) is the recognition score at the image level. In some cases a subject is represented by multiple images (e.g., a template, as in the Janus benchmark  #b13 ). This plurality of images can be exploited to improve recognition at test time. In such cases, image sets are defined by P = {x 1 , ..., x P } and Q = {x 1 , ..., x Q } and a similarity score is defined between them: s(P, Q).Specifically, we compute the pair-wise image level similarity scores, s(x p , x q ), for all x p ∈ P and x q ∈ Q, and pool these scores using a SoftMax operator, s β (P, Q) (Eq.(2), below). Though the use of SoftMax here is inspired by the SoftMax loss often used by CNNs, its aim is to get a robust score regression instead of a distribution over the subjects. SoftMax for set fusion can be seen as a weighted average in which the weight depends on the score when performing recognition. It is interesting to note here that the SoftMax hyper-parameter β controls the trade-off between averaging the scores or taking the maximum (or minimum). That is: .s β (·, ·) =      max(·) if β → ∞ avg(·) if β = 0 min(·) if β → −∞(2) Pair-wise scores are pooled using Eq. The use of positive values for β is motivated by the fact what we are using a score for recognition, so the higher the value, the better. In our experiments we found that the SoftMax operator reaches a remarkable trade-off between averaging the scores and taking the maximum. The improvement given by the proposed SoftMax fusion is shown in Tab. 1: we can see how the proposed method largely outperforms standard fusion techniques on IJB-A, in which subjects are described by templates. Exploiting pose augmentation at test time: The Achilles heel of many face recognition systems is cross pose face matching; particularly when one of the two images is viewed at an extreme, near profile angle  #b42  #b19  #b5 . Directly matching two images viewed from extremely different viewpoints often leads to poor accuracy as the difference in viewpoints affects the similarity more than subject identities. To mitigate this problem, we suggest rendering both images from the same view: one that is close enough to the viewpoint of both images.To this end, we leverage our pose synthesis method of Sec. 3.1 to produce images in poses better suited for recognition and matching. Cross pose rendering can, however, come at a price: Synthesizing novel views for faces runs the risk of producing meaningless images whenever facial landmarks are not accurately localized and the pose estimate is wrong. Even if pose was correctly estimated, warping images across poses involves interpolating intensities, which leads to smoothing artifacts and information loss. Though this may affect training, it is far more serious at test time where we have few images to compare and ruining one or both can directly affect recognition accuracy.Rather than commit to pose synthesis or its standard alternative, simple yet robust in-plane alignment, we propose to use both: We found that pose synthesis and in-plane alignment are complimentary and by combining the two alignment techniques recognition performance improves. For an image pair (I p , I q ) we compute two similarity scores. One score is produced using in-plane aligned images and the other using images rendered to a mutually convenient view. This view is determined as follows: If the two images are near frontal then we render them to frontal view (essentially frontalizing them  #b9 ), if they are both near profile we render to 75 • , otherwise we render both to 40 • .When matching templates (image sets), (P, Q), scores computed for in-plane aligned image pairs and pose synthesized pairs are pooled separately using Eq. (2). This is equivalent to comparing the two sets P and Q twice, once for each alignment method. These two similarities are then averaged for the final template level score.

Experiments
We tested our approach extensively on the recently released IARPA Janus benchmarks  #b13  and LFW  #b10 . We perform a minimum of database specific training, using the training images prescribed by each benchmark protocol. Specifically,  we perform Principal Component Analysis (PCA) on the training images of the target dataset with the features x extracted from the CNN trained on augmented data. This did not include dimensionality reduction; we did not cut any component after PCA projection. Following this, we apply root normalization to the new projected feature, i.e., x → x c , as previously proposed for the Fisher Vector encoding in  #b26 . We found that a value of c = 0.65 provides a good baseline across all the experiments. For each dataset we report the contribution of each augmentation technique compared with state-of-the-art methods which use millions of images to train their deep models.

Results on the IJB-A benchmarks
IJB-A is a new publicly available benchmark released by NIST 3 to raise the challenges of unconstrained face identification and verification methods. Both IJB-A and the Janus CS2 benchmark share the same subject identities, represented by images viewed in extreme conditions, including pose, expression and illumination variations, with IJB-A splits generally considered more difficult than those in CS2. The IJB-A benchmarks consist of face verification (1:1) and face identification (1:N) tests. Contrary to LFW, Janus subjects are described using templates containing mixtures of still-images and video frames.It is important to note that the Janus set has some overlap with the images in the CASIA WebFace collection. In order to provide fair comparisons, our CNNs were fine tuned on CASIA subjects that are not included in Janus (Sec. 4.1). Face detections: Our pipeline uses the facial landmark detector of  #b1  for head pose estimation and alignment. Although we found this detector quite robust, it failed to detect landmarks on some of the more challenging Janus faces. Whenever the detector failed on all the images in the same template, we use the images cropped to their facial bounding boxes as provided in the Janus data. Video pooling: We note that whenever face templates include multiple frames from a single video, we pool together CNN features extracted from the same  Table 2: Effect of each augmentation on IJB-A performance on verification (ROC) and identification (CMC), resp. Only in-plane aligned images used in these tests.video: this, by simple element wise average over all the features extracted from that video's frames. We emphasize that features are not pooled across videos but only within each video. Similar pooling techniques were very recently demonstrated to provide substantial performance enhancements (e.g.,  #b30 ) but, to our knowledge, never for faces or in the manner suggested here. We refer to this technique as video pooling and report its influence on our system, and, whenever possible, for our baselines. In all our IJB-A and Janus CS2 results this method provided noticeable performance boosts: we compare video pooling to pair-wise single image comparisons (referred as without video pooling in our results).  Table 3: Effect of in-plane alignment and pose synthesis at test-time (matching) on IJB-A dataset respectively for verification (ROC) and identification (CMC).Ablation Study: We provide a detailed analysis of each augmentation technique on the challenging IJB-A dataset. Clearly, the biggest contribution is given by pose augmentation (red curve) over the baseline (blue curve) in Fig. 5a. The improvement is especially noticeable in the rank-1 recognition rate for the identification protocol. The effect of video pooling along with each data augmentation method is provided in Tab. 2. We next evaluate the effect of pose synthesis at test time combined with the standard in-plane alignment (Sec. 4.2), in Tab 3 and in Fig. 5b. Evidently, these methods combined contribute to achieving state-of-the-art performance on the IJB-A benchmark. We conjecture that this is mainly due to three contributions: domain-specific augmentation when training the CNN, combination of SoftMax operator, video pooling and finally pose synthesis at test time.  Comparison with the state-of-the-art: Our proposed method achieves state of the art results in the IJB-A benchmark and Janus CS2 dataset. In particular, it largely improves over the off the shelf commercial systems COTS and GOTS  #b13  and Fisher Vector encoding using frontalization  #b4 . This gap can be explained by the use of deep learning alone. Even compared with deep learning based methods, however, our approach achieves superior performance and with very wide margins. This is true even comparing our results to  #b36 , who use seven networks and fuse their output with the COTS system. Moreover, our method improves in IJB-A verification over  #b36  in 15% TAR at FAR=0.01 and ∼20% TAR at FAR=0.001, also showing a better rank-1 recognition rate. It is interesting to compare our results to those reported by  #b3  and  #b27 . Both fine tuned their deep networks on the ten training splits of each benchmark, at substantial computational costs. Some idea of the impact this fine tuning can have on performance is available by considering the huge performance gap between results reported before and after fine tuning in  #b3  4 . Our own results, obtained by training our CNN once on augmented data, far outperform those of  #b27  also largely outperforming those reported by  #b3 . We conjecture that by training the CNN with augmented data we avoid further specializing all the parameters of the network on the target dataset. Tuning deep models on indomain data is computationally expensive and thus, avoiding overfitting the network at training time is preferable.

Results on Labeled Faces in the Wild
For many years LFW  #b10  was the standard benchmark for unconstrained face verification. Recent methods dominating LFW scores use millions of images collected and labeled by hand in order to obtain their remarkable performances. To test our approach, we follow the standard protocol for unrestricted, labeled outside data and report the mean classification accuracy as well as the 100%  -EER (Equal Error Rate). We prefer to use 100% -EER in general because it is not dependent on the selected classification threshold but we still report verification accuracy to be comparable with the other methods. Improvement for each augmentation: Fig. 6a provides ROC curves for each augmentation technique used in our approach. The green curve represents our baseline, that is the CNN trained on in-plane aligned images with respect to a frontal template. The ROC improves by a good margin when we inject unseen rendered images across poses into each subject. Indeed the 100% -EER improves by +1.67%. Moreover, by adding both shapes and expressions, performance improves even more, reaching 100% -EER rate of 98.00% (red curve). See Tab. 6b for a comparison with methods trained on millions of downloaded images.

Result summary
It is not easy to compare our results with those reported by others using millions of training images: Their system designs and implementation details are different from our own and it is difficult to assess how different system components contribute to their overall performance. In particular, the reluctance of commercial groups to release their code and data makes it hard to say exactly how much performance our augmentation buys in comparison to their harvesting and curating millions of face images. Nevertheless, the results throughout this section clearly show that synthesizing training images using domain tools and knowledge leads to dramatic increase in recognition accuracy. This may be attributed to the potential of domain specific augmentation to infuse training data with important intra-subject appearance variations; the very variations that seem hardest to obtain by simply downloading more images. As a bonus, it is a more accessible means of increasing training set sizes than downloading and labeling millions of additional faces.Finally, a comparison of our results on LFW to those reported by methods trained on millions of images (  #b34  #b35  #b23  and  #b28 ), shows that with the initial set of less than 500K publicly available images from  #b43 , our method surpasses those of  #b34  and  #b23  (without their metric learning, which was not applied here), falling only slightly behind the rest.

Conclusions
This paper makes several important contributions. First, we show how domain specific data augmentation can be used to generate (synthesize) valuable additional data to train effective face recognition systems, as an alternative to expensive data collection and labeling. Second, we describe a face recognition pipeline with several novel details. In particular, its use of our data augmentation for matching across poses in a natural manner. Finally, in answer to the question in the title, our extensive analysis shows that though there is certainly a benefit to downloading increasingly larger training sets, much of this effort can be substituted by simply synthesizing more face images.There are several compelling directions of extending this work. Primarily, the underlying idea of domain specific data augmentation can be extended in more ways (more facial transformations) to provide additional intra subject appearance variations. Appealing potential augmentation techniques, not used here, are facial age synthesis  #b12  or facial hair manipulations  #b21 . Finally, beyond faces there may be other domains where such approach is relevant and where the introduction of synthetically generated training data can help mitigate the many problems of data collection for CNN training.

Footnote
1 : MegaFace[12] is larger than CASIA, but was designed as a testing set and so provides few images per subject. It was consequently never used for training CNN systems.
2 : Code and data will be publicly available. Please see www.openu.ac.il/home/ hassner/projects/augmented_faces for updates.
3 : IJB-A data and splits are available under request at http://www.nist.gov/itl/ iad/ig/facechallenges.cfm
4 : The results reported in[4] with fine tuning on the training sets include system components not evaluated without fine tuning.