The Extended Littlestone's Dimension for Learning with Mistakes and Abstentions

Abstract
This paper studies classification with an abstention option in the online setting. In this setting, examples arrive sequentially, the learner is given a hypothesis class H, and the goal of the learner is to either predict a label on each example or abstain, while ensuring that it does not make more than a pre-specified number of mistakes when it does predict a label. Previous work on this problem has left open two main challenges. First, not much is known about the optimality of algorithms, and in particular, about what an optimal algorithmic strategy is for any individual hypothesis class. Second, while the realizable case has been studied, the more realistic nonrealizable scenario is not well-understood. In this paper, we address both challenges. First, we provide a novel measure, called the Extended Littlestone's Dimension, which captures the number of abstentions needed to ensure a certain number of mistakes. Second, we explore the non-realizable case, and provide upper and lower bounds on the number of abstentions required by an algorithm to guarantee a specified number of mistakes.

Introduction
Many machine learning applications, such as fraud detection in credit card transactions and medical diagnosis, involve high misclassification penalties. In these cases, it is often desirable to design a predictor which is guaranteed to make no more than a certain number of prediction mistakes, at the expense of a few abstentions; the examples on which the learner abstains are then passed on to a human, who can then take a closer look.In this paper, we study this problem -classification with an option to abstain -in an online setting. Examples arrive sequentially, the learner is given a hypothesis class H, and the goal of the learner is to either predict a label on each example or abstain, while ensuring that it does not make more than a pre-specified number of mistakes. The first formal theoretical framework to address this problem was the Knows What It Knows (KWIK) model [LLWS11]; assuming that labels are generated by a hypothesis in H (the so-called realizability assumption), this framework requires the learner to always predict correctly. [LLWS11] also provided an algorithm in this model that makes no mistakes and requires |H| − 1 abstentions for finite H.[SZB10] further extended this model to allow learners that do not always have to be correct, but are permitted to make upto a bounded number of mistakes. They showed that when k mistakes are allowed, the number of abstentions can be reduced to (k + 1)|H| 1/(k+1) .While previous work has looked at designing generic online learning algorithm in this setting, there are two remaining challenges. First not much is known about the optimality of these algorithms, and in particular, about what an optimal algorithmic strategy would be for any individual hypothesis class. The second challenge is to understand what happens in a more realistic scenario where the realizability assumption does not hold. While this has been studied in a regression setting [SS11], not much is known about the classification case.In this paper, we address both challenges. We first provide a new measure that, given a hypothesis class H, captures how many abstentions are needed to ensure a certain number of mistakes, and we provide an optimal algorithm that achieves this number. Our measure is closely related to the notion of Littlestone's dimension for online learning with no abstentions, and we call it the Extended Littlestone's dimension. Formalizing this notion additionally allows us to extend our algorithm to infinite hypothesis classes; while algorithms were previously known for some specific infinite classes [SZB10], no generic algorithm was known.Next, we focus our attention on the non-realizable case. In this case, we make an l-bias assumption, which ensures that the labels are generated by a function that disagrees with some (unknown) hypothesis h ∈ H on at most l examples. We show that (at least some form of) this assumption is necessary; there exists a finite hypothesis class H, such that when the l-bias assumption holds, any algorithm that abstains a finite number of times must make at least l mistakes. Moreover, there also exists an infinite hypothesis class H with Littlestone's dimension d such that any algorithm that abstains a finite number of times must make at least l + d mistakes. To complement these lower bounds, we show that we can run a version of our algorithm when the l-bias assumption holds, and provide an upper bound on the number of abstentions it makes.

The Setting
We consider the problem of online classification in the model of [SZB10], where the learner is allowed to occasionally abstain from prediction. The precise setting is as follows. At time t, the adversary presents an example x t in some instance space X . The learner makes its predictionŷ t , which can be either −1, +1, or ⊥ (I don't know). The adversary then reveals an outcome y t ∈ {−1, +1}. The interaction between the learner and the adversary continues, and the performance of the learner is measured by the total number of mistakes and abstentions made throughout the process.To help make decisions, the learner has access to a hypothesis class H. Each hypothesis h in H is a prediction rule mapping from X to {−1, +1}.Basic Notations. Given two hypothesis h 1 and h 2 , their product is defined as a new hypothesis h 1 · h 2 which is a function that takes x as input, and outputs h 1 (x) · h 2 (x). Given two hypothesis classes H 1 and H 2 , we define H 1 · H 2 to be the class of functions achievable by taking the product between a function in H 1 and a function in H 2 . Formally, Non-realizable Case. In the non-realizable case, we assume that the label of examples are generated by a function that disagrees with some hypothesis on at most l examples, which we call l-bias assumption. 1 Formally, define H l as the set of classifiers where its prediction differs from some classifier in H on at most l points, i.e. H l = H · C l . A sequence S = (x 1 , y 1 ), . . . , (x n , y n ) is said to have l-bias with respect to H, if and only if it is H l -realizable, i.e.∃h ∈ H l , |{t : h(x t ) = y t }| = 0 Version Space and Disagreement Region. In the realizable case, it is often convenient to consider the set of hypotheses that agree with the labeled examples revealed so far. Given an labeled set S and a set of hypotheses V , V [S] ⊆ V is defined as the set of all classifiers that classify S correctly:V [S] = {h ∈ V : for all (x, y) ∈ S, h(x) = y}At the start of time t, the version space is defined as the set of hypotheses in H that agree with the examples (x 1 , y 1 ), . . . , (x t−1 , y t−1 ) seen so far.We say that an example x is in the disagreement region of a hypothesis set V , denoted by DIS(V ), if both V [(x, +1)] and V [(x, −1)] are nonempty.Nontrivial Rounds. For deterministic learners, it is always suboptimal for the adversary to present an example on which the learner predicts correctly, since this will only impose additional constraints on examples shown in the future without changing the number of mistakes and abstentions made. A round t is called nontrivial if and only if the learner makes a mistake or abstains on that round.The Mistake Bound Model. The mistake bound model  #b3 Lit87, #b1 ] is a central model in online classification. An online learning algorithm A achieves a mistake bound M with respect to a set of sequences S ⊆ (X × {−1, +1}) * if and only if for any adversary showing sequences S = ((x 1 , y 1 ), . . . , (x n , y n )) in S, A's predictionŷ 1 , . . .,ŷ n ∈ {−1, +1} satisfies n t=1 I(ŷ t = y t ) ≤ M The k-SZB Model. In this paper, we consider k-SZB model studied by [SZB10,  #b11 , which extends the mistake bound model by additionally allowing the learner to say "Don't Know"(⊥). An online learning algorithm A achieves a (k, m)-SZB bound with respect to a set of sequences S ⊆ (X × {−1, +1}) * , if and only if for any adversary that presents sequences S = ((x 1 , y 1 ), . . . , (x n , y n )) in S, A's predictionŷ 1 , . . .,ŷ n ∈ {−1, +1, ⊥} satisfies n t=1I(ŷ t = −y t ) ≤ k n t=1 (I(ŷ t = −y t ) + I(ŷ t = ⊥)) ≤ mIn other words, the number of mistakes is at most k, and number of nontrivial rounds (where the algorithm makes a mistake or abstains) is at most d. When k = 0, this is exactly the KWIK model [LLWS11]. We will look at this model in both the realizable and non-realizable cases. Figure 1: A mistake tree with respect to set of threshold classifiers H = {h i = 2I(x ≤ i) − 1 : i = 1, 2, 3, 4}.3 −1 +1 2 4 1 2 3 4 h 1 h 2 h 3 h 4 −1 +1 −1 +1

Extended Littlestone's Dimension
We now define extended Littlestone's Dimension, which measures the difficulty of online learning a hypothesis class in the k-SZB model.

Background: Mistake Bound, Littlestone's Dimension and Standard Optimal Algorithm
[Lit87] provides a characterization of the optimal mistake bound in the realizable case, which is measured by Littlestone's dimension. We begin by describing this characterization.Mistake Trees. Littlestone's dimension is closely related to the notion of a mistake tree. A mistake tree 2 of a hypothesis class H is a complete binary tree 3 , whose leaves are classifiers in H and whose internal nodes correspond to examples in X . A mistake tree may have no internal nodes, in which case it only contains a leaf corresponding to a classifier h in H -we call it a zeroth order mistake tree. Given an internal node, the edge connecting it and its left (resp. right) child is labeled −1 (resp. +1). A root to leaf path p in mistake tree T is a sequence of nodes and edges v 1 e 1 v 2 e 2 . . . v n e n v n+1 , where v 1 , . . . , v n are internal nodes in T corresponding to examples in X , v 1 is the root node of T , each e i is an edge in T that connects v i and v i+1 , v n+1 = h is a classifier in H corresponding to a leaf in T . For each i, edge e i connects v i and v i+1 . The length of a path l(p) is defined as the number of edges in p. For each leaf, the associated classifier agrees with the internal nodes and edges along the path up to the root. That is, if each node v i corresponds to example x i and each edge e i has label y i , then h agrees with examples {(x 1 , y 1 ), . . . , (x n , y n )}. See Figure 1 for an illustration.A mistake tree T succinctly represents a strategy of the adversary in response to a deterministic learner. At t = 1, the adversary picks the example x 1 corresponding to the root node to show to the learner. If the learner predictsŷ 1 = −1, the adversary reveals label y 1 = +1, and follows the downward edge labeled +1; otherwise it follows the other edge. If at time t ≥ 2, the adversary reaches a node with example x t , then x t is shown to the learner, and one of the downward edges adjacent to this node is followed. The interaction comes to an end when a leaf is reached. It can be seen that the adversary forces the learner to make a mistake at each node of the mistake tree; this implies that if every root-to-leaf path of the mistake tree has depth d, then the adversary can force the learner to make d mistakes using the associated strategy.We are now ready to define Littlestone's dimension. Receive example x t ∈ X .

5:
if x t ∈ DIS(V ) then # All classifiers in V predict unanimously 6:Predictŷ t = h(x t ),where h is an arbitrary hypothesis in V .

6:
Receive label y t .

7:
else # There is disagreement among V 8:if k = 0 then # Zero mistake budget, must output ⊥ 9:Predictŷ t = ⊥. Compute m +1 = ELdim(V [(x t , −1)], k − 1), m −1 = ELdim(V [(x t , +1)], k − 1), and m ⊥ = max(ELdim(V [(x t , −1)], k), ELdim(V [(x t , +1)], k))

9:
end if 10: end for Recursive Definition. For finite H 4 one also has the following recurrence for its Littlestone's dimension:Ldim(H) = 0 |H| = 1 1 + max x∈DIS(H) min y∈{±1} Ldim(H[(x, y)]) |H| > 1

Extended Mistake
Trees. An adversary's strategy in response to a deterministic learner in the k-SZB model can be succinctly represented by extended mistake trees. An extended mistake tree for H is a full 5 binary tree, whose leaves are classifiers in H and whose internal nodes are examples in X . An extended mistake tree may have no internal node, in which case it only contains a leaf corresponding to a classifier h in H -we call it a zeroth order extended mistake tree. Unlike mistake trees, now, there are two type of edges: solid and dashed, representing mistakes and abstentions, respectively. Each node is associated with two downward solid edges, one to each child. Additionally, each node is associated with exactly one downward dashed edge connecting to one of its two children. For a downward edge of a node, whether solid or dashed, if it is connected with the node's left child, then it is labeled −1, and vice versa. Just as in mistake trees, for each leaf, the associated classifier agrees with the internal nodes and edges along the path up to the root. See Figure 2 for an illustration.A root to leaf path p of an extended mistake tree T is a sequence of nodes and edges v 1 e 1 v 2 e 2 . . . v n e n v n+1 , where v 1 , . . . , v n are internal nodes in T corresponding to examples in X , v 1 is the root node of T , each e i is an edge in T that connects v i and v i+1 , v n+1 = h is a classifier in H corresponding to a leaf in T . Here if there are multiple edges between v i and v i+1 , any one of them can be used by p.Given an extended mistake tree T , the associated adversarial strategy can be described as follows. At t = 1, the adversary chooses the example x 1 corresponding to the root node to show to the learner. If the learner predictsŷ 1 = −1, it reveals label y 1 = +1, follows the downward solid edge labeled +1, and vice versa. Otherwise, ifŷ 1 = ⊥, it reveals y 1 as the label on the dashed edge and follows the downward dashed edge. At time t ≥ 2, if the adversary reaches a node with example x t , then x t is shown to the learner, and one of its adjacent downward edges is followed. The interaction comes to an end when a leaf is reached. It can be seen that with this strategy, the adversary forces every round to be nontrivial. If the depth of the leaf reached is d, then the number of nontrivial rounds is d.As an example, the extended mistake tree in Figure 2 can be used by the adversary as follows. Initially x 1 = 2 is presented to the learner. If the learner predictsŷ 1 = −1, the adversary reveals label y 1 = +1 and follows the right downward solid edge to reach node x 2 = 3. At time t = 2, the learner now shows example x 2 = 3; If the learner predictsŷ 2 = ⊥, the adversary reveals y 2 = +1 according to the label on the dashed edge and follows the edge to reach node x 3 = 4. At time t = 3, the learner shows example x 3 = 4; If the learner predictsŷ 2 = +1, the adversary reveals label y 2 = −1 and follows the left downward solid edge to reach a leaf containing hypothesis h 3 . This concludes the interaction, and the learner makes a total of 3 nontrivial rounds: 2 mistakes and 1 abstentions. Note that realizability assumption is maintained, as h 3 ∈ H agrees with the examples (2, +1), (3, +1), (4, −1) shown. More generally, one can show that if the learner is not allowed to make any mistakes, then the adversary is able to force 3 nontrivial rounds by following this strategy. This motivates the definition below.Definition 2. We say that an extended mistake tree T is (k, m)-difficult for integers k, m ≥ 0, if all its root to leaf paths in T using at most k solid edges have length at least m.For example, the extended mistake tree in Figure 2 is (0, 3)-difficult.Extended Standard Optimal Algorithm. Algorithm 2 presents the Extended Standard Optimal Algorithm (SOA.DK), which, as we will show, is an optimal deterministic algorithm for online prediction in the k-SZB model in the realizable case. Note that it works even when the hypothesis class H is infinite. Similar to the Standard Optimal Algorithm, it maintains a version space V . For a new example x t , it predictŝ y t ∈ {−1, +1, ⊥} by computing function ELdim over subsets of V . The function ELdim is defined as follows.Definition 3 (Extended Littlestone's Dimension). For a hypothesis class V and integer k ≥ 0, the extended Littlestone's dimension ELdim(V, k) is defined as:ELdim(V, k) := sup{m ∈ N : There exists a (k, m)-difficult extended mistake tree for V }We remark that if for every integer m, V has a (k, m)-extended mistake tree, then ELdim(V, k) = ∞;If V = ∅, then ELdim(V, k) = −∞. Since for k ′ < k, a (k, m)-difficult extended mistake tree is also (k ′ , m)-difficult, ELdim(V, k) is monotonically nonincreasing with respect to k.We first show that when ELdim(V, k) is high, then an adversary can force a large number of nontrivial rounds by showing a V -realizable sequence, to any deterministic algorithms that guarantees at most k mistakes.Lemma 1. Suppose we are given a hypothesis set V and integers k ≥ 0, m ≥ 0. If ELdim(V, k) ≥ m, then there is a strategy of the adversary that presents a V -realizable sequence and that can force any deterministic algorithm that guarantees ≤ k mistakes to have ≥ m nontrivial rounds.In the following lemma, we show that given a mistake budget k, if the extended Littlestone's dimension of V is small, then SOA.DK has a small number of nontrivial rounds for V -realizable sequences.Lemma 2 (Performance Guarantees of SOA.DK). Suppose we are given a hypothesis class V and integers k ≥ 0, m ≥ 0. If ELdim(V, k) ≤ m, then Algorithm 2, when run on V with mistake budget k, achieves a (k, m)-SZB bound with respect to any adversary that shows V -realizable sequences. Receive example x t ∈ X .

12:
Predictŷ t = arg min{m y : y ∈ {−1, +1, ⊥}}. Receive label y t .16:ifŷ t = −y t orŷ t = ⊥ then V ← V [(x t , y t )] end if # Update version space 17: ifŷ t = −y t then k ← k − 1 end if # Update mistake budget 18: end forAn immediate consequence of Lemma 2 is that SOA.DK is optimal, in the sense that it has the smallest number of worst case nontrivial rounds, amongst all deterministic algorithms that work in k-SZB model.Theorem 2 (Optimality of SOA.DK). Suppose we are given a hypothesis class H and integers k ≥ 0, m ≥ 1 such that ELdim(H, k) = m. Then:(a) SOA.DK achieves a (k, m)-SZB bound for any adversary that shows H-realizable sequences.(b) There exists an adversary showing H-realizable sequences, such that no deterministic algorithm A can achieve a (k, m − 1)-SZB bound.The following simple property relates extended Littlestone's dimension to Littlestone's dimension.Theorem 3 (Relating Ldim to ELdim). Suppose we are given a hypothesis class H.If Ldim(H) = d < ∞, then ELdim(H, d) = dRecursive Definition. We provide a recursive characterization of Extended Littlestone's dimension. For finite H 6 , the following recurrence holds for its extended Littlestone's dimension:ELdim(H, k) =      0 |H| = 1 1 + max x∈DIS(H) max y∈{±1} ELdim(H[(x, y)], 0) |H| > 1, k = 0 1 + max x∈DIS(H) max y∈{±1} min(ELdim(H[(x, y)], k − 1), ELdim(H[(x, −y)], k)) |H| > 1, k ≥ 1The recurrence is an immediate consequence of Lemma 11 in Appendix D.

Properties of Extended Littlestone's Dimension
We next present upper bounds on the Extended Littlestone's Dimension of a hypothesis class H. Our upper bounds depend on the tree shattering coefficient, a notion analogous to the growth function, which is implicit in  #b5 . We also present some examples of Extended Littlestone's Dimension.

Tree Shattering Coefficient
The shattering coefficient (also known as the growth function), initially studied in [VC71], is a key notion in PAC learnability.Definition 4. Given a hypothesis H, the shattering coefficient of H, Π(H, t) is defined as the maximum number of labelings achievable by H over t points. Formally,Π(H, t) := max x1,...,xt |{(h(x 1 ), . . . , h(x t )) : h ∈ H}|Inspired by the shattering coefficient, in online learning, we define the notion of tree shattering coefficient below, implicit in  #b5 . As we will see, this notion is crucial to online learnability in both the mistake bound and the k-SZB models. First we set up our notation by adopting the notion of trees in [RST10].Definition 5 (X -valued Trees, see [RST10]). A depth-t X -valued tree x is a series of mappings (x 1 , . . . , x t ), where x i : {±1} i−1 → X . The root of the tree x is the constant function x 1 ∈ X . For integer t, the mapping x t (·) takes care of the nodes in level t.To see why a series of mappings corresponds to a tree, we first note that a tuple (ǫ 1 , . . . , ǫ s−1 ) in {±1} s−1 can be thought of as a left/right sequence of length s − 1, where −1 stands for left and +1 stands for right, respectively. The node reached from the root following the path corresponding to the left/right sequence corresponds to x s (ǫ 1 , . . . , ǫ s−1 ) ∈ X . For example, the root node corresponds to x 1 ∈ X , the left child of the root corresponds to x 2 (−1) ∈ X , the right child of the left child of the root corresponds to x 3 (−1, +1) ∈ X , etc. See Figure 3 for an illustration. We slightly abuse the notation to let x t (ǫ) denote x t (ǫ 1 , . . . , ǫ t−1 ).Note that a X -valued tree is not a mistake tree or an extended mistake tree, since it does not have leaves corresponding to hypotheses in H.Given a X -valued tree x, we add an extra level of edges at the bottom. Specifically for each leaf x t (ǫ), we attach a left and a right downward edge onto it, labeled −1 and +1 respectively. Now, consider every root to leaf path in the tree. If there is some classifier h in H that agrees with the path, we label the leaf with h; otherwise we label the leaf with symbol ×. We count the number of leaves not labeled ×, denoted by function S(H, x). See Figure 4 for an example.Definition 6. For a depth-t X -valued tree x, and a hypothesis class H, define function S(H, x) as the maximum number of labelings achievable by H on x. Formally,S(H, x) := {(ǫ 1 , ǫ 2 , . . . , ǫ t ) ∈ {±1} t : ǫ 1 = h(x 1 (ǫ)), ǫ 2 = h(x 2 (ǫ)), . . . , ǫ t = h(x t (ǫ)), for some h ∈ H} 6Just as with Littlestone's dimension, for infinite H, the recurrence may not reach the base case.x 1 −1 +1 x 2 (−1) x 2 (+1) x 3 (−1, −1) x 3 (−1, +1) x 3 (+1, −1) x 3 (+1, +1) −1 +1 −1 +1 Figure 3: A depth-3 X -valued tree x. z 1 −1 +1 z 2 z 3 z 4 z 5 z 6 z 7 −1 +1 h 1 h 2 h 3 h 4 × × × × −1 +1 −1 +1 −1 +1 −1 +1−1 +1 Figure 4: A concrete depth-3 X -valued tree x, where x 1 = z 1 , x 2 (−1) = z 2 , x 2 (+1) = z 3 , x 3 (−1, −1) = z 4 , x 3 (−1, +1) = z 5 , x 3 (+1, −1) = z 6 , x 3 (+1, +1) = z 7 .There are 4 root to leaf paths that agrees with some hypothesis in H (× in a leaf indicates that no hypothesis in H agree with the path from root to it), i.e. |S(H, x)| = 4.Definition 7. Given hypothesis class H, and integer t ≥ 1, the tree shattering coefficient of H, S(H, t) is defined as the maximum number of labelings achievable by H over all depth-t trees. Formally,S(H, t) := max x |S(H, x)| Additionally, define S(H, 0) := 1 if H is nonempty, S(H, 0) := 0 if H is empty.In other words, given hypothesis class H and a depth-t tree x with internal nodes only, there are at most S(H, t) distinct paths in T consistent with some classifier h ∈ H. Since a depth-t has at most 2 t root to leaf paths, S(H, t) ≤ 2 t . Note that if H has a depth-t mistake tree, then S(H, t) = 2 t . If we constrain the trees chosen to be constant among nodes in the same depth, then the tree shattering coefficient is equivalent to the shattering coefficient. In Appendix A, we show that the tree shattering coefficient is connected with the sequential growth function(maximal sequential zero covering number), defined in [RST10].The following two lemmas give bounds on tree shattering coefficients, implicit in [RST10,  #b5 . For finite hypothesis class H, its tree shattering coefficient is at most the size of |H|.Lemma 3. If H is finite, then for any t ≥ 0, S(H, t) ≤ |H|. Furthermore, if an infinite hypothesis class H has Littlestone's dimension d < ∞, its tree shattering coefficient is polynomial in t, that is, O(t d ). Lemma 4. If H has Littlestone's dimension d < ∞, then for any t ≥ 0, S(H, t) ≤ t ≤d .

Upper Bound on Extended Littlestone's Dimension
We present Theorem 4, the main result of this section, which upper bounds the extended Littlestone's dimension in terms of tree shattering coefficient. Intuitively, if H is not expressive, then it has small tree shattering coefficient, and a tighter upper bound on its extended Littlestone's dimension can be established. Note that the bound is valid even if H is infinite, and hence it is a strict generalization of [SZB10].Theorem 4. For any hypothesis class H and integer k ≥ 0,ELdim(H, k) ≤ sup t : t ≤ k + 1 ≤ S(H, t)For finite hypothesis classes one has the following corollary.Corollary 1. For any hypothesis class H such that |H| < ∞ and integer k ≥ 0,ELdim(H, k) ≤ max t : t ≤ k + 1 ≤ |H| Since t ≤k+1 ≥ ( t k+1 ) k+1 , this implies ELdim(H, k) ≤ max t : ( t k+1 ) k+1 ≤ |H| ≤ (k + 1)|H| Theorem 5. Consider H a set of threshold classifiers H = {2I(x ≤ t) − 1 : t ∈ {t 1 , . . . , t n }}. Then ELdim(H, k) = max t : t ≤ k + 1 ≤ nThe proof of Theorem 5 is provided in Appendix E. The upper bound follows immediately from Corollary 1. The lower bound comes from an explicit construction of optimal extended mistake trees by exploiting structure in the class of threshold classifiers.

Case Study: Union of Singletons (Infinite Class)
We give a precise characterization of the Extended Littlestone's dimension for the class of unions of singletons. In this case the bound given by Theorem 4 is tight. Consider the concept class of union of at most l singletons C l , with instance domain X such that |X | = ∞. Note that Ldim(C l ) = l and S(C l , t) = t ≤l (See Lemma 15 for a proof). We have the following result.Theorem 6. Consider the hypothesis class C l , the class of union of at most l singletons. Then,ELdim(C l , k) = sup t : t ≤ k + 1 ≤ t ≤ l = ∞, k ≤ l − 1 l, k ≥ lNote that Theorem 6 involves infinite hypothesis classes and is broader than the results of [SZB10]. The proof of Theorem 6 is provided in Appendix E. The upper bound follows immediately from Theorem 4. The lower bound comes from an explicit construction of optimal extended mistake trees by exploiting structures in the class of union of singleton classifiers.

Non-Realizable Case
We now consider the non-realizable case. For the rest of the section, we assume the l-bias assumption holds, i.e. the sequence (x 1 , y 1 ), . . . , (x n , y n ) presented by the adversary is H l -realizable. Recall that H l = H · C l , the class of hypothesis that disagrees with H on at most l points.

Lower Bounds for Deterministic Prediction
A natural question is, when the l-bias assumption holds, is it possible to derive algorithms with a small number of abstentions in k-SZB model? Perhaps surprisingly, the answer depends on whether H is finite or not. We show next that there is a finite hypothesis class H, such that for any k < l, and any integer m, any algorithm which is guaranteed to make k or less mistakes can be forced to abstain at least m times. Moreover, for any m, there is a infinite hypothesis class with Littlestone's dimension d, such that for any k < l + d, any algorithm that is guaranteed to make k or less mistakes can be forced to abstain at least m times.

Lower Bounds for Finite Hypothesis Classes
We first show that, for finite hypothesis classes H, when k < l, no algorithm can guarantee a (k, m)-SZB bound with finite m under the l-bias assumption.Theorem 7. There exists an instance domain X , a single-element hypothesis class H, such that the following holds. If k < l, then for any integer m ≥ 0, there exists a strategy of the adversary satisfying the l-bias assumption that forces any deterministic algorithm guaranteeing at most k mistakes to have at least m + 1 nontrivial rounds.

Lower Bounds for Infinite Hypothesis Classes
We show that, given a hypothesis classes H with Ldim(H) = d, when k < l + d, no algorithm can guarantee a (k, m)-SZB bound for finite m under the l-bias assumption.Theorem 8. There exists an instance domain X , a hypothesis class H with Littlestone's dimension d < ∞, such that the following holds. If k < l + d, then for any integer m ≥ 0, there exists a strategy of the adversary satisfying the l-bias assumption that forces any deterministic algorithm guaranteeing at most k mistakes to have at least m + 1 nontrivial rounds.

Upper Bounds


Upper Bounds for Finite Hypothesis classes
Since a sequence satisfying the l-bias assumption is H l -realizable, to provide an upper bound on the number of non-trivial rounds under this assumption, we need to provide an upper bound on ELdim(H l , k). We now provide such upper bounds on arbitrary finite hypothesis classses H. Note that since the hypothesis class H l is infinite, this result is more general than the kind of results in [SZB10].Lemma 5. Suppose we are given a finite hypothesis class H, integer k ≥ 0, l ≥ 0 such that k ≥ l. Then,ELdim(H l , k) ≤ e(k + 1) · |H| 1 k+1−lCorollary 2. Suppose we are given a finite hypothesis class H and integers k, l ≥ 0 such that k ≥ l. If Algorithm SOA.DK is run with input hypothesis class H l and mistake budget k, then for any adversary that shows sequences satisfying the l-bias assumption with respect to H, SOA.DK makes at most k mistakes and has at most e(k + 1) · |H| 1 k+1−l nontrivial rounds.

Upper Bounds for Infinite Hypothesis classes
We now derive a corresponding upper bound for infinite hypothesis classes H with finite Littlestone's dimension.Lemma 6. Suppose we are given a hypothesis class H with Littlestone's dimension d < ∞, integer k ≥ 0, l ≥ 0 such that k ≥ l + d. Then,ELdim(H l , k) ≤ (k + 1) · e 2k+2 k+1−l−dCorollary 3. Suppose we are given a hypothesis class H with Littlestone's dimension d and integer k, l ≥ 0 such that k ≥ l + d. If Algorithm SOA.DK is run with input hypothesis class H l and mistake budget k, then for any adversary that shows sequences satisfying the l-bias assumption with respect to H, SOA.DK makes at most k mistakes and has at most (k + 1) · e 2k+2 k+1−l−d nontrivial rounds.

Lower Bounds for Randomized Prediction
We show that the results in Section 5.1 hold even when the learner makes soft predictions.Randomized Prediction Model. Consider the following randomized variant of online classification model. At time t, the adversary presents example x t in X , and the learner outputs a tuple (p t,− , p t,+ , 1 − p t,− − p t,+ ), with p t,− ≥ 0, p t,+ ≥ 0 and 1 − p t,− − p t,+ ≥ 0. The tuple (p t,− , p t,+ , 1 − p t,− − p t,+ ) represents the learner's strategy of predicting +1 with probability p t,+ , −1 with probability p t,− and abstaining with probability 1 − p t,+ − p t,− . The adversary then reveals an outcome y t ∈ {−1, +1}, and the learner incurs a mistake penalty of p t,+ if y t = −1 and p t,− if y t = 1; it also incurs an abstention penalty of 1 − p t,+ − p t,− . When p t,+ and p t,− take values in {0, 1}, observe that this is equivalent to our prediction model in Section 2.So given examples (x 1 , y 1 ), . . . , (x n , y n ), the cumulative mistake penalty upto time n is as n t=1 I(y t = −1)p t,+ + I(y t = +1)p t,− and the cumulative abstention penalty is n t=1 (1 − p t,+ − p t,− ). We have the following result for finite hypothesis classes.Theorem 9. There exists an instance domain X , a single-element hypothesis class H, such that the following holds. If k < l, then for any a ≥ 0, there exists a strategy of the adversary satisfying l-bias assumption, such that any algorithm guaranteeing a cumulative mistake penalty at most k in the randomized prediction model must have cumulative abstention penalty at least a.For infinite hypothesis classes with Littlestone's dimension d, we have the following result.Theorem 10. There exists an instance domain X and a hypothesis class H with Littlestone's dimension d such that the following holds. If k < l + d, then for any a ≥ 0, there exists a strategy of the adversary satisfying the l-bias assumption, such that any algorithm guaranteeing a mistake penalty of at most k in the randomized prediction model must have cumulative abstention penalty at least a.

Related Work
The first formal framework for online learning with abstentions is the Knows What It Knows (KWIK) model [LLWS11], which works as follows. At time t, the learner is given an example x t , and is expected to output either the correct label for x t or abstain from prediction. [LLWS11] formalizes versions of this model for both classification and regression settings, and provides a classification algorithm that achieves no mistakes and |H| − 1 abstentions when the sequences provided are realizable for a finite hypothesis class H.[SS11] provides algorithms for online regression that apply even when the realizability assumption is relaxed.Perhaps the most related to our work is [SZB10], where the KWIK model is relaxed in the classification setting by allowing the learner to make ≤ k mistakes. This work presents an algorithm that, given a finite hypothesis H, can make at most k mistakes with at most (k+1)|H| 1 k+1 abstentions. Our work extends [SZB10] in that we provide an optimal algorithm that exploits finer structures in H, and also in that we allow the hypothesis class H to be infinite.  #b11  extends [SZB10] by providing efficient algorithms for the class of disjunctions. Finally, another important line of work for online classification with abstentions is conformal prediction [SV08], which, given a conformity measure R and an error probability measure δ, shows a strategy for constructing confidence sets in an online manner that contain the correct label with probability 1 − δ. Our framework differs from this line of work in that the conformity measure for us is not specified.There is a large volume of literature on online classification when no abstentions are allowed. The mistake bound model, initially proposed by [Lit87, Ang87], considers online binary classification in the realizable case. [Lit87] also introduces the standard optimal algorithm and optimal mistake bound (aka Littlestone's dimension Ldim(H)). There has been much literature on developing algorithms for specific hypothesis classes in the mistake bound model; see [SSBD14,  #b8  for examples.  #b5  considers online classification (with no abstentions) in the agnostic case; they show that if the hypothesis class H has finite Littlestone's dimension, then it is possible to design an online prediction algorithm that makes l +Õ( Ldim(H)T + Ldim(H)) mistakes over T rounds, where l is the minimum error of any hypotheses in H. In follow-up work, [RST10, RSS12, RST15b, RST15a] have developed a rich theory of online learning, and defined complexity measures such as sequential Rademacher complexity, and sequential covering number that characterize the complexity of online learning. However, this theory does not apply to online learning with abstentions.In the batch setting, the problem of classification with an abstention option has been both empirically and theoretically studied since the pioneering work of  #b10 . It is however unclear how to directly apply the results in the batch setting to the online setting, because of the adversarial nature of the examples.[HW06, BW08, YW10] consider classification where the decision to abstain is made based on thresholding a real-valued function that belongs to a fixed function class.[FMS04] provides an algorithm that performs weighted majority style aggregation over a hypothesis class and abstains when the aggregate is close to zero.[KKM12, KT14] study a related problem called reliable learning, and gives a predictor that achieves low error at the expense of abstentions.  #b2  considers the problem in transductive setting, where the goal is to make aggregated predictions with abstention based on an ensemble of classifiers, where some error upper bounds on individual classifiers are known. Finally, inspired by the active learning algorithm of  #b7 ,  #b12  proposes a abstention principle in the realizable case, which guarantees a zero error.[EYW11] shows how to extend the idea to nonrealizable case, where the predictor has zero error with respect to the optimal hyothesis and [ZC14] gives an improved predictor when a nonzero amount of error is allowed.[EYW11] R. El-Yaniv and Y. Wiener. Agnostic selective classification. In NIPS, 2011. [ZC14] C. Zhang and K. Chaudhuri. Beyond disagreement-based agnostic active learning. In NIPS, 2014.

A Tree Shattering Coefficient and Sequential Growth Function
In this section, we show that the tree shattering coefficient S(H, t) is at most the size of the sequential growth function(also known as maximal sequential zero covering number) of H [RST10]. We start with some notations.Definition 8 (Sequential Zero Cover and Sequential Zero Covering Number, see [RST10]). A set V of depth-t trees is a sequential zero cover of H on a depth-t tree x, if∀h ∈ H, ∀ǫ ∈ {±1} t , ∃v ∈ V, s.t.v s (ǫ) = h(x s (ǫ)), s = 1, 2, . . . , tThe sequential zero covering number of a hypothesis class H on a given tree x is defined asN (0, H, x) := min{|V | : V is a zero-cover of H on x}The maximal sequential zero covering number is the maximum sequential zero covering number of H over all depth-t X -valued trees x, that is,N (0, H, t) := max x N (0, H, x)Theorem 11. For a given hypothesis class H and integer t ≥ 0,S(H, t) ≤ N (0, H, t)Proof. This is an immediate consequence of Lemma 7.Lemma 7. Suppose we are given a X -valued tree x and a hypothesis class H. If V is a sequential zero cover of H on x, then the size of S(H, x) is at most |V |.Proof. Recall that S(H, x) = {(ǫ 1 , ǫ 2 , . . . , ǫ t ) ∈ {±1} t : ǫ 1 = h(x 1 (ǫ)), ǫ 2 = h(x 2 (ǫ)), . . . , ǫ t = h(x t (ǫ)), h ∈ H} Given an element (ǫ 1 , ǫ 2 , . . . , ǫ t ) in S(H, x), there exists some h in H such thatǫ 1 = h(x 1 (ǫ)), ǫ 2 = h(x 2 (ǫ)), . . . , ǫ t = h(x t (ǫ)) Since V is a zero-cover of H, there exists a depth-t tree v = (v 1 , . . . , v t ) in V such that v 1 (ǫ) = h(x 1 (ǫ)), v 2 (ǫ) = h(x 2 (ǫ)), . . . , v t (ǫ) = h(x t (ǫ)) Hence, v 1 (ǫ) = ǫ 1 , v 2 (ǫ) = ǫ 2 , . . . , v t (ǫ) = ǫ t More explicitly, v 1 = ǫ 1 , v 2 (ǫ 1 ) = ǫ 2 , v 3 (ǫ 1 , ǫ 2 ) = ǫ 3 , . . . , v t (ǫ 1 , . . . , ǫ t−1 ) = ǫ t(1)To summarize, for every (ǫ 1 , ǫ 2 , . . . , ǫ t ) in S (H, x), there is a tree v in V such that Equation (1) holds. Since for each tree v there can be at most one (ǫ 1 , ǫ 2 , . . . , ǫ t ) such that Equation (1) holds, this implies that |S(H, x)| ≤ |V |.

B Reducing the Expert Problem to Online Classification with Finite Class
In this section, we show that the problem of Prediction with Expert Advice (abbrev. Expert Problem) with l-mistake assumption  #b9  #b0  can be cast to the problem studied in this paper, i.e. online classification with a finite hypothesis class with l-bias assumption. Specifically, in the expert problem, at each time t, the algorithm is given experts' advice (x 1,t , . . . , x N,t ) ∈ {−1, 1} N , and predictsŷ t ∈ {−1, 1, ⊥}. Then adversary reveals label y t ∈ {−1, 1}. The l-mistake assumption states that there is an expert i that makes at most l mistakes throughout the process, i.e. M i = |{t : x i,t = y t }|is at most l. This immediately implies (a).An immediate consequence of the above proposition is that, for an instance of the expert problem with l-mistake assumption, we can convert it to an instance of online classification in H N under l-bias assumption, and apply SOA.DK on H N to get mistake-abstention tradeoffs. Taking the maximum over x ∈ X proves the lemma.

C A Note on the Recursive Definition of ELdim


D Proofs from Section 3
We first provide some auxiliary lemmas regarding properties of extended mistake trees and extended Littlestone's dimension. This will serve as the basis of the proof of Lemma 2.We state a property about subtrees of a (k, m)-difficult extended mistake tree.Lemma 10 (Recursive Property of Extended Mistake Trees). Suppose we are given hypothesis class H that has an extended mistake tree T with root x, left subtree T −1 , right subtree T +1 and integers k ≥ 0, m ≥ 1.For the root node x, denote by e l its downward left solid edge, e r its downward right solid edge, and e d its downward dashed edge. Denote by y the label of e d .(i) The following statements are equivalent:(a) T is (0, m)-difficult. (b) T y is (0, m − 1)-difficult.(ii) For k ≥ 1, the following statements are equivalent:(a) T is (k, m)-difficult. (b) T −y is (k − 1, m − 1)- difficult, and T y is (k, m − 1)-difficult.Proof of Lemma 10. Without loss of generality, suppose y = +1. The case of y = −1 can be shown symmetrically.Proof of item (i): We show the implication in both directions.(⇒) Consider a root to leaf path p in T +1 that uses no solid edges. Now consider path p + , the result of prepending the root node x and the downward dashed edge from root x to its right child onto p, i.e. p + = xe d p. It can be seen that p + uses no solid edges, and l(p + ) = l(p) + 1. Since T is (0, m)-difficult, l(p + ) ≥ m, therefore l(p) ≥ m − 1, thus showing T +1 is (0, m − 1)-difficult.(⇐) Consider a root to leaf path p = v 1 e 1 v 2 e 2 . . . v n e n v n+1 in T that uses no solid edges. The first edge of p must be the downward dashed edge e d . Define path p − as the result of deleting the first node v 1 = x and the first edge e 1 from p, i.e. p − = v 2 e 2 . . . v n e n v n+1 . Since T −1 is (0, m − 1)-difficult, we get that l(p − ) ≥ m − 1. Therefore l(p) = l(p − ) + 1 ≥ m. Therefore, any path p in T that uses no solid edges must be of length at least m. Thus, T is (0, m)-difficult.Proof of item (ii): We show the implication in both directions.(⇒) (1) Consider a root to leaf path p in T −1 that uses at most k − 1 solid edges. Now consider path p + , the result of prepending the root node x and the downward edge from root x to its left child onto p, i.e. p + = xe l p. It can be seen that p + uses at most k solid edges, and l(p + ) = l(p)+ 1. Since T is (k, m)-difficult, l(p + ) ≥ m, therefore l(p) ≥ m − 1, thus showing T −1 is (k − 1, m − 1)-difficult.(2) Consider a root to leaf path p in T +1 that uses at most k solid edges. Now consider path p + , the result of prepending the root node x and the downward dashed edge from root x to its right child onto p, i.e. p + = xe d p. It can be seen that p + uses at most k solid edges, and l(p+ ) = l(p)+1. Since T is (k, m)-difficult, l(p + ) ≥ m, therefore l(p) ≥ m − 1, thus showing T +1 is (k, m − 1)-difficult.(⇐) Consider a root to leaf path p = v 1 e 1 v 2 e 2 . . . v n e n v n+1 in T that uses at most k solid edges. Define path p − as the result of deleting the first node v 1 = x the first edge e 1 from p, i.e. p − = v 2 e 2 . . . v n e n v n+1 .(1) If the first edge of p is a downward edge from root x to its left child, then p − is a root to leaf path in T −1 , and uses at most k − 1 solid edges, since the first edge e 1 has to be a solid edge. Since T +1 is (k − 1, m − 1)-difficult, we get that l(p − ) ≥ m − 1.(2) If the first edge of p is the downward edge from root x to its right child, then p − is a root to leaf path in T +1 , and uses at most k solid edges. Since T −1 is (k, m − 1)-difficult, we get that l(p − ) ≥ m − 1.In both cases, l(p − ) ≥ m − 1. Hence l(p) = l(p − ) + 1 ≥ m. In summary, any path p in T that uses at most k solid edges must be of length m. Thus, T is (k, m)-difficult.Built upon Lemma 10, we obtain the following result regarding H's extended Littlestone's dimension.Lemma 11 (Recursive Property of ELdim). Suppose we are given hypothesis class H and integers k ≥ 0, m ≥ 1. Proof of Lemma 1. Since ELdim(H, k) ≥ m, there is a (k, m)-difficult extended mistake tree T H with respect to H. We consider the the strategy of the adversary associated with T H . Now consider any deterministic learning algorithm A that guarantees at most k mistakes. Since A is deterministic, the interaction between A and the adversary follows some path p from root to leaf. The number of mistakes is equal to the number of solid edges in p, and the number of abstentions is equal to the number of dashed edges in the p. Since A guarantees k mistakes, p must contain at most k solid edges, thus it must be of length at least m, as T H is (k, m)-difficult. Therefore, the number of nontrivial rounds of A is at least m.Proof of Lemma 2. We prove the lemma by joint induction on (k, m).Base Case. Consider pairs (k, m), where k = 0 or m = 0.(1) For m = 0 and k ≥ 0, if there is no (k, 1)-difficult extended mistake tree, then for all x ∈ X , V predicts unanimously on x. Otherwise, there are two hypotheses h 1 and h 2 and an example x such that h 1 (x) = −1 and h 2 (x) = +1. Consider extended mistake tree T as follows. T has x as its root, and h 1 and h 2 are leaves directly connecting to the root, where h 1 is on the left and h 2 is on the right. The downward dashed edge is connected to the right, i.e. has label +1. It can be seen that T is (k, 1)-difficult for any k ≥ 0. Therefore, Algorithm 2 always predicts correctly, and there will be no nontrivial rounds subsequently.(2) For k = 0 and m ≥ 0, we show the result by induction on m. The base case m = 0 has been shown in (1). For the inductive case, assume the inductive hypothesis holds for m ′ ≤ m − 1. Now, given a hypothesis class V such that ELdim(V, 0) is at most m. Consider the first nontrivial round t when running Algorithm 2 with version space V . The example x t must be in DIS(V ), and the algorithm outputsŷ t = ⊥. We claim that the resulting version space V [(x t , y t )] is such that ELdim(V [(x t , y t )], 0) ≤ m − 1. Indeed, suppose ELdim(V [(x t , y t )], 0) ≥ m, then by Lemma 11, ELdim(V, 0) ≥ m + 1, which is a contradiction.Note that from time t + 1 on, the adversary is only allowed to show V [(x t , y t )]-realizable sequences. By inductive hypothesis, Algorithm 2 runs on V [(x t , y t )] and achieves (0, m − 1)-SZB bound from time t + 1 on. Therefore, Algorithm 2 achieves (0, m)-SZB bound throughout the process.Inductive Case. Consider pairs (k, m) where k ≥ 1 and m ≥ 1. Assume for all k ′ ≤ k, m ′ ≤ m and k ′ + m ′ ≤ k + m − 1, the inductive hypothesis holds. Now, consider a hypothesis class V such that ELdim(V, k) ≤ m. Consider the first nontrivial round t when we run Algorithm 2 on V . The example x t must be in DIS(V ). According to Algorithm 2's predictionŷ t , we consider three cases separately, ELdim(V [(x t ,ŷ)], k) ≥ mTherefore, forŷ, we have ELdim(V [(x t ,ŷ)], k) ≥ m and ELdim(V [(x t , −ŷ)], k − 1) ≥ m. By Lemma 11, ELdim(V, k) ≥ m + 1, which is a contradiction.Note that from time t + 1 on, the adversary is only allowed to show V [(x t , y t )]-realizable sequences. By inductive hypothesis, Algorithm 2 runs on V [(x t , y t )] with mistake budget k−1 and achieves (k−1, m−1)-SZB bound from round t + 1 on. Therefore, Algorithm 2 achieves (k, m)-SZB bound throughout the process.Case 2:ŷ t = +1. This case is symmetric to Case 1.Case 3:ŷ t = ⊥. We first claim that ELdim(V [(x t , −1)], k) ≤ m − 1. Indeed, assume (for the sake of contradiction) that ELdim(V [(x t , −1)], k) ≥ m. By definition of Algorithm 2, m −1 ≥ m ⊥ ≥ m, that isELdim(V [(x t , +1)], k − 1) ≥ m By Lemma 11, ELdim(V, k) ≥ m + 1, contradiction. Symmetrically, one also has ELdim(V [(x t , +1)], k) ≤ m − 1.Hence, irrespective of the outcome y t ∈ {−1, +1}, the resulting version space V [(x t , y t )] satisfies that ELdim(V [(x t , y t )], k) ≤ m−1. Note that from time t+1 on, the adversary is only allowed to show V [(x t , y t )]realizable sequences. By inductive hypothesis, Algorithm 2 runs on V [(x t , y t )] with mistake budget k, and achieves (k, m − 1)-SZB bound from round t + 1 on. Therefore, Algorithm 2 achieves (k, m)-SZB bound throughout the process.In summary, Algorithm 2, when run on V , achieves (k, m)-SZB bound. This completes the induction.Proof of Theorem 2. (a) This is an immediate consequence of Lemma 2.(b) By Lemma 1, there is a strategy of the adversary such that any deterministic learner guaranteeing at most k mistakes must have at least m nontrivial rounds. Therefore, no deterministic learner can achieve a (k, m − 1)-SZB bound.Proof of Theorem 3. Recall that Ldim(H) = d < ∞. We show the equality by showing inequalities in both sides.( S(H, t) = max x∈X (S(H[(x, −1)], t − 1) + S(H[(x, +1)], t − 1))We need the following notation of subtrees to give the proof of Lemma 12.Definition 9 (Subtrees, see [RST10]). Given a depth-t tree x, the left subtree x l of x at the root is defined as t − 1 mappings (x l 1 , . . . ,x l t−1 ), where x l i (ǫ) = x({−1} × ǫ), for ǫ ∈ {±1} t−1 . The right subtree x r of x at the root is defined as t − 1 mappings (x r 1 , . . . , x r t−1 ), where x r i (ǫ) = x({+1} × ǫ), for ǫ ∈ {±1} t−1 . Proof of Lemma 12. Consider the definition of S(H, t): max x |{(ǫ 1 , ǫ 2 , . . . , ǫ t ) ∈ {±1} t : ǫ 1 = h(x 1 (ǫ)), ǫ 2 = h(x 2 (ǫ)), . . . , ǫ t = h(x t (ǫ)), h ∈ H}|This can be alternatively written asmax x |{(−1, σ 1 , . . . , σ t−1 ) ∈ {±1} t−1 : σ 1 = h(x l 1 (σ)), . . . , σ t = h(x l t−1 (σ)), h ∈ H[(x 1 , −1)]} ∪{(+1, σ 1 , . . . , σ t−1 ) ∈ {±1} t−1 : σ 2 = h(x r 1 (σ)), . . . , σ t = h(x r t−1 (σ)), h ∈ H[(x 1 , +1)]}|The above is equal to ≤ t − 1 ≤ d − 1 + t − 1 ≤ d ≤ t ≤ dThis completes the induction. This completes the proof for k = 0.Inductive Case: For t ≥ 1 and k ≥ 1, suppose the inductive hypothesis holds for any (k ′ , t ′ ) such that k ′ ≤ k, t ′ ≤ t, k ′ + t ′ ≤ k + t + 1. Proof of Theorem 5. Note that S(H, t) ≤ |H| = n, therefore by Lemma 13, ELdim(H, k) ≤ max{t : t ≤k+1 ≤ n}.On the other hand, Lemma 14 implies that for all m such that m ≤k+1 ≤ n, there is a (m, k)-difficult extended mistake tree with respect to H. Hence ELdim(H, k) ≥ max{t : (1) For k = 0, m ≤k = m + 1. We show a construction of T 0,m , a (0, m)-difficult extended mistake tree in Figure 5. It can be seen that the resulting tree T 0,m is (0, m)-difficult, as the only root to leaf path using no solid edges corresponds to examples (t 2 , +1), . . ., (t m+1 , +1), which has length m.(2) For m = 0 and integer k, m ≤k = 1. The zeroth order extended mistake tree containing h t1 is a (k, 0)difficult extended mistake tree. x −1 +1t 1 t 2 t m+1 t 2 −1 +1 t 3 −1 +1 t m+1 −1 +1 h 1 h 2 h m+1 h m . . .T k−1,m−1 T k,m−1 Figure 6: Construction of T k,m , an extended mistake tree given parameters k ≥ 1 and m ≥ 1, from T k,m−1 and T k−1,m−1 .x 1 −1 +1 Now consider the extended mistake tree T rooted at x, with its left subtree asT − and right subtree as T + . The dashed downward edge of root is linked to its right child, i.e. has label +1. Note that T is a valid extended mistake tree, since all hypotheses at the leaves inT − (resp.T + ) classifies x as −1 (resp. +1). By Lemma 10, T is (l − 1, m + 1)-difficult, hence (l − 1, m)-difficult. Additionally, all its dashed edges are labeled +1. Since the choice of m is arbitrary, this completes the induction.x 2 −1 +1 x m −1 +1 h 1 h 2 h + h m . . .

F Proofs from Section 5
Proof of Theorem 7. Let X be an infinite set. Let H be the hypothesis class containing only one hypothesis h ≡ +1. Note that H l = C l and by Theorem 6, ELdim(H l , k) = ∞ for k < l. By Lemma 1, the theorem follows.Proof of Theorem 8. Let X be an infinite set. Let H be the C d , the class of unions of at most d singletons. Note that H l = C l+d and by Theorem 6, ELdim(C l+d , k) = ∞ for k < l + d. By Lemma 1, the theorem follows.We will need the following result regarding the tree shattering coefficient of the "product" of two hypothesis classes. Proof. For any depth-t tree x, we have that Proof of Lemma 17. By induction on t.

Footnote
1 : k+1 , which recovers the result of [SZB10]. 74.3 Case Study: Thresholds (Finite Class)We give a precise characterization of the Extended Littlestone's dimension for the class of thresholds. In this case, the bound given by Theorem 4 is tight.Consider the instance domain X being R and the hypothesis class H being the set of n distinct threshold functions {2I(x ≤ t) − 1 : t ∈ {t 1 , . . . , t n }}.8 7 Although it is implicit in [SZB10] that the result can be refined by using the optimal solution of the Egg Dropping Game [GF08, Boa04], here we give a alternative proof using a more general technique. 8 Note that for an infinite set of thresholds, e.g. H = {2I(x ≤ t) − 1 : t ∈ [0, 1]}, Ldim(H) = ∞, hence ELdim(H, k) = ∞ for any finite k.
2 : In [Lit87] this is instead called a "complete mistake tree"; in [Sha12] this is called a H-shattered tree. 
4 : For infinite H, the recurrence may not reach the base case. 5 A full binary tree is one in which every internal node has exactly two children.
3 :  A complete binary tree is one in which every level is completely filled with nodes.