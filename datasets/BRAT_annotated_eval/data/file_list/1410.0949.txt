Tight Regret Bounds for Stochastic Combinatorial Semi-Bandits

Abstract
A stochastic combinatorial semi-bandit is an online learning problem where at each step a learning agent chooses a subset of ground items subject to constraints, and then observes stochastic weights of these items and receives their sum as a payoff. In this paper, we close the problem of computationally and sample efficient learning in stochastic combinatorial semi-bandits. In particular, we analyze a UCB-like algorithm for solving the problem, which is known to be computationally efficient; and prove O(KL(1/∆) log n) and O( √ KLn log n) upper bounds on its n-step regret, where L is the number of ground items, K is the maximum number of chosen items, and ∆ is the gap between the expected returns of the optimal and best suboptimal solutions. The gapdependent bound is tight up to a constant factor and the gap-free bound is tight up to a polylogarithmic factor.

Introduction
A stochastic combinatorial semi-bandit  #b10  #b9  is an online learning problem where at each step a learning agent chooses a subset of ground items subject to combinatorial constraints, and then observes stochastic weights of these items and receives their sum as a payoff. The problem can be viewed as a learning variant of combinatorial optimization with a linear objective function and binary variables. Many classical combinatorial optimization problems have linear objectives  #b15 . Therefore, stochastic combinatorial semi-bandits have found many practical applications, such as learning spectrum allocations  #b10 , shortest paths  #b10 , routing networks  #b11 , and recommendations  #b11  #b12 .In our work, we study a variant of stochastic combinatorial semi-bandits where the learning agent has access to an offline optimization oracle that can find the optimal solution for any weights of the items. We say that the problem is a (L, K, ∆) instance when L is the cardinality of its ground set E, K is the maximum number of chosen items, and ∆ is the gap between the expected returns of the optimal and best suboptimal solutions. We also say that the problem is a (L, K) instance if it is a (L, K, ∆) instance for some ∆. Based on the existing bandit work  #b5 , it is relatively easy to propose a UCB-like algorithm for solving our problem  #b10 , and we call this algorithm CombUCB1. CombUCB1 is a variant of UCB1 that calls the oracle to find the optimal solution with respect to the upper confidence bounds on the weights of the items. Chen et al.  #b9  recently showed that the n-step regret of CombUCB1 in any (L, K, ∆) stochastic combinatorial semi-bandit is O(K 2 L(1/∆) log n).Our main contribution is that we derive two upper bounds on the n-step regret of CombUCB1, O(KL(1/∆) log n) and O( √ KLn log n). Both of these bounds are significant improvements over Chen et al.  #b9 . Moreover, we prove two novel lower bounds, Ω(KL(1/∆) log n) and Ω( √ KLn), which match our upper bounds up to polylogarithmic factors. The consequence of these results is that CombUCB1 is sample efficient because it achieves near-optimal regret. It is well known that CombUCB1 is also computationally efficient  #b10 , it can be implemented efficiently whenever the offline optimization oracle is computationally efficient. So we close the problem of computationally and sample efficient learning in stochastic combinatorial semi-bandits, by showing that CombUCB1 has both properties. This problem is still open in the adversarial setting (Section 8).Our analysis is novel. It is based on the idea that the event that "many" items in a chosen suboptimal solution are not observed "sufficiently often" does not happen "too often". arXiv:1410.0949v3 [cs.LG] 27 Jan 2015The reason is that this event happens for "many" items simultaneously. Therefore, when the event happens, the observation counters of "many" items increase. Based on this observation, we divide the regret associated with the event among "many" items, instead of attributing it separately to each item as in the prior work  #b10  #b9 . This is the key step in our analysis that yields tight upper bounds.Our paper is organized as follows. In Section 2, we introduce our learning problem and the algorithm for solving it. In Section 3, we summarize our results. In Section 4, we prove a O(K 4 3 L(1/∆) log n) upper bound on the regret of CombUCB1. In Section 5, we prove a O(KL(1/∆) log n) upper bound on the regret of CombUCB1. In Section 6, we prove gap-dependent and gap-free lower bounds. In Section 7, we evaluate CombUCB1 on a synthetic problem and show that its n-step regret grows as suggested by our gapdependent upper bound. In Section 8, we compare our results to prior work. In Section 9, we discuss extensions of our work. We conclude in Section 10.

Setting
Formally, a stochastic combinatorial semi-bandit is a tuple B = (E, Θ, P ), where E = {1, . . . , L} is a finite set of L items, Θ ⊆ 2 E is a non-empty set of feasible subsets of E, and P is a probability distribution over a unit cube [0, 1] E . We borrow the terminology of combinatorial optimization and call E the ground set, Θ the feasible set, and A ∈ Θ a solution. The items in the ground set E are associated with a vector of stochastic weights w ∼ P . The e-th entry of w, w(e), is the weight of item e. The expected weights of the items are defined asw = E w∼P [w]. The return for choosing solution A under the realization of the weights w is:f (A, w) = e∈A w(e) .The maximum number of chosen items is defined as K = max A∈Θ |A|.Let (w t ) n t=1 be an i.i.d. sequence of n weights drawn from P . At time t, the learning agents chooses solution A t ∈ Θ based on its observations of the weights up to time t, gains f (A t , w t ), and observes the weights of all chosen items at time t, {(e, w t (e)) : e ∈ A t }. The learning agent interacts with the environment n times and its goal is to maximize its expected cumulative reward over this time. If the agent knew P a priori, the optimal action would be to choose the optimal solution 1 :A * = arg max A∈Θ f (A,w)at all steps t. The quality of the agent's policy is measured  $b1  For simplicity of exposition, we assume that the optimal solution is unique. Algorithm 1 CombUCB1 for stochastic combinatorial semibandits.Input: Feasible set Θ // Initialization (ŵ 1 , t 0 ) ← Init(Θ) T t0−1 (e) ← 1 ∀e ∈ E for all t = t 0 , . . . , n do // Compute UCBs U t (e) ←ŵ Tt−1(e) (e) + c t−1,Tt−1(e) ∀e ∈ E // Solve the optimization problem A t ← arg max A∈Θ f (A, U t ) // Observe the weights of chosen items Observe {(e, w t (e)) : e ∈ A t }, where w t ∼ P // Update statistics T t (e) ← T t−1 (e) ∀e ∈ E T t (e) ← T t (e) + 1 ∀e ∈ A t w Tt(e) (e) ← T t−1 (e)ŵ Tt−1(e) (e) + w t (e) T t (e) ∀e ∈ A tby its expected cumulative regret:R(n) = E n t=1 R(A t , w t ) , where R(A t , w t ) = f (A * , w t ) − f (A t , w t )is the regret of the agent at time t.

Algorithm
Gai et al.  #b10  proposed a simple algorithm for stochastic combinatorial semi-bandits. The algorithm is motivated by UCB1  #b5  and therefore we call it CombUCB1. At each time t, CombUCB1 consists of three steps. First, it computes the upper confidence bound (UCB) on the expected weight of each item e:U t (e) =ŵ Tt−1(e) (e) + c t−1,Tt−1(e) ,(1)whereŵ s (e) is the average of s observed weights of item e, T t (e) is the number of times that item e is observed in t steps, and:c t,s = 1.5 log t s(2)is the radius of a confidence interval aroundŵ s (e) at time t such thatw(e) ∈ [ŵ s (e) − c t,s ,ŵ s (e) + c t,s ] holds with high probability. Second, CombUCB1 calls the optimization oracle to solve the combinatorial problem on the UCBs:A t = arg max A∈Θ f (A, U t ) .Finally, CombUCB1 chooses A t , observes the weights of all chosen items, and updates the estimates ofw(e) for these items. The pseudocode of CombUCB1 is in Algorithm 1.Algorithm 2 Init: Initialization of CombUCB1. Input: Feasible set Θ w(e) ← 0 ∀e ∈ E u(e) ← 1 ∀e ∈ E t ← 1 while (∃e ∈ E : u(e) = 1) do A t ← arg max A∈Θ f (A, u) Observe {(e, w t (e)) : e ∈ A t }, where w t ∼ P for all e ∈ A t dô w(e) ← w t (e) u(e) ← 0 t ← t + 1Output:Weight vectorŵ First non-initialization step t

Initialization
CombUCB1 is initialized by calling procedure Init (Algorithm 2), which returns two variables. The first variable is a weight vectorŵ ∈ [0, 1] E , whereŵ(e) is a single observation from the e-th marginal of P . The second variable is the number of initialization steps plus one.The weight vectorŵ is computed as follows. Init repeatedly calls the oracle A t = arg max A∈Θ f (A, u) on a vector of auxiliary weights u ∈ {0, 1} E , which are initialized to ones. When item e is observed, we set the weightŵ(e) to the observed weight of the item and u(e) to zero. Init terminates when u(e) = 0 for all items e. Without loss of generality, let's assume that each item e is contained in at least one feasible solution. Then Init is guaranteed to terminate in at most L iterations, because at least one entry of u changes from one to zero after each call of the optimization oracle.

Summary of Main Results
We prove three upper bounds on the regret of CombUCB1. Two bounds depend on the gap ∆ and one is gap-free: Both gap-dependent bounds are major improvements over O(K 2 L(1/∆) log n), the best known upper bound on the n-step regret of CombUCB1  #b9 . The bound in Theorem 5 is asymptotically tighter than the bound in Theorem 3, but the latter is tighter for K < (534/96) 3 < 173.Theorem 3 : O(KOne of the main contributions of our work is that we identify an algorithm for stochastic combinatorial semi-bandits that is both computationally and sample efficient. The following are our definitions of computational and sample efficiency. We say that the algorithm is computationally efficient if it can be implemented efficiently whenever the offline variant of the problem can be solved computationally efficiently. The algorithm is sample efficient if it achieves optimal regret up to polylogarithmic factors. Based on our definitions, CombUCB1 is both computationally and sample efficient. We state this result slightly more formally below.Theorem 1. CombUCB1 is computationally and sample efficient in any (L, K) stochastic combinatorial semi-bandit where the offline optimization oracle arg max A∈Θ f (A, w) can be implemented efficiently for any w ∈ (R + ) E .Proof. In each step t, CombUCB1 calls the oracle once, and all of its remaining operations are polynomial in L and K. Therefore, CombUCB1 is guaranteed to be computationally efficient when the oracle is computationally efficient.CombUCB1 is sample efficient because it achieves optimal regret up to polylogarithmic factors. In particular, the gapdependent upper bound on the n-step regret of CombUCB1 in Theorem 5 matches the lower bound in Proposition 1 up to a constant factor. In addition, the gap-free upper bound in Theorem 6 matches the lower bound in Proposition 2 up to a factor of √ log n.

O(K


3 ) Upper Bounds
In this section, we prove two O(K 4 3 L(1/∆) log n) upper bounds on the n-step regret of CombUCB1. In Theorem 2, we assume that the gaps of all suboptimal solutions are the same. In Theorem 3, we relax this assumption.The gap of solution A is ∆ A = f (A * ,w) − f (A,w).The results in this section are presented for their didactic value. Their proofs are simple. Yet they illustrate the main ideas that lead to the tight regret bounds in Section 5.Theorem 2. In any (L, K, ∆) stochastic combinatorial semi-bandit where ∆ A = ∆ for all suboptimal solutions A, the regret of CombUCB1 is bounded as:R(n) ≤ K 4 3 L 48 ∆ log n + π 2 3 + 1 KL .The proof of Theorem 2 relies on two lemmas. In the first lemma, we bound the regret associated with the initialization of CombUCB1 and the event thatw(e) is outside of the high-probability confidence interval aroundŵ Tt−1(e) (e).Lemma 1. Let:F t =    ∆ At ≤ 2 e∈Ãt c n,Tt−1(e) , ∆ At > 0   (3)be the event that suboptimal solution A t is "hard to distinguish" from A * at time t, whereÃ t = A t \ A * . Then the regret of CombUCB1 is bounded as:R(n) ≤ E R (n) + π 2 3 + 1 KL ,(4)where:R(n) = n t=t0 ∆ At 1{F t } .(5)Proof. The claim is proved in Appendix A.1.Now we bound the regret corresponding to the events F t , the items in a suboptimal solution are not observed "sufficiently often" up to time t. To bound the regret, we define two events: (6) at most αK 2 6 ∆ 2G 1,t = at least d items inÃ t were observedAt log n times and:G 2,t = less than d items inÃ t were observed (7) at most αK 2 6 ∆ 2At log n times, at least one item inÃ t was observedat most αd 2 ( √ α − 1) 2 6 ∆ 2 At log n times ,where α ≥ 1 and d > 0 are parameters, which are chosen later. The event G 1,t happens when "many" chosen items, at least d, are not observed "sufficiently often" up to time t, at most αK 2 6∆ 2 A t log n times.Events G 1,t and G 2,t are obviously mutually exclusive. In the next lemma, we prove that these events are exhaustive when event F t happens. To prove this claim, we introduce new notation. We denote the set of items inÃ t that are not observed "sufficiently often" up to time t by:S t = e ∈Ã t : T t−1 (e) ≤ αK 2 6 ∆ 2 At log n .Lemma 2. Let α ≥ 1, d > 0, and event F t happen. Then either event G 1,t or G 2,t happens.Proof. By the definition of S t , the following three events:G1,t = {|St| ≥ d} G2,t = |St| < d, ∃e ∈Ãt : Tt−1(e) ≤ 6αd 2 log n ( √ α − 1) 2 ∆ 2 A t Ḡ t = |St| < d, ∀e ∈Ãt : Tt−1(e) > 6αd 2 log n ( √ α − 1) 2 ∆ 2 A tare exhaustive and mutually exclusive. Therefore, to prove that either G 1,t or G 2,t happens, it suffices to show thatḠ t does not happen. Suppose that eventḠ t happens. Then by the assumption that F t happens and from the definition of G t , it follows that:∆ At ≤ 2 e∈Ãt 1.5 log n T t−1 (e) = 2 e∈Ãt\St 1.5 log n T t−1 (e) + 2 e∈St 1.5 log n T t−1 (e) < 2 |Ã t \ S t | ≤K 1.5 log n αK 2 6 ∆ 2 A t log n + 2 |S t | ≤d 1.5 log n αd 2 ( √ α−1) 2 6 ∆ 2 A t log n ≤ ∆ At √ α + ∆ At ( √ α − 1) √ α = ∆ At .This is clearly a contradiction. Therefore, eventḠ t cannot happen; and either G 1,t or G 2,t happens.Now we are ready to prove Theorem 2.Proof. A detailed proof is in Appendix A.2.The key idea is to bound the number of times that events G 1,t and G 2,t happen in n steps. Based on these bounds, the regret associated with both events is bounded as:R(n) ≤ α d K 2 + αd 2 ( √ α − 1) 2 L 6 ∆ log n .Finally, we choose α = 4 and d = K 2 3 , and substitute the above upper bound into inequality (4).Theorem 2 can be generalized to the problems with different gaps. Let ∆ e,min be the minimum gap of any suboptimal solution that contains item e ∈Ẽ:∆ e,min = min A∈Θ:e∈A,∆ A >0 ∆ A (8) = f (A * ,w) − max A∈Θ:e∈A,∆ A >0 f (A,w) ,whereẼ = E \ A * is the set of subptimal items, the items that do not appear in the optimal solution. Then the regret of CombUCB1 is bounded as follows.Theorem 3. In any (L, K) stochastic combinatorial semibandit, the regret of CombUCB1 is bounded as:R(n) ≤ e∈Ẽ K 4 3 96 ∆ e,min log n + π 2 3 + 1 KL . Proof. A detailed proof is in Appendix A.3.The key idea is to define item-specific variants of events G 1,t and G 2,t , G e,1,t and G e,2,t ; and associate ∆ A t d and ∆ At regret with G e,1,t and G e,2,t , respectively. Then, for each item e, we order the events from the largest gap to the smallest, and show that the total regret is bounded as:R(n) < e∈Ẽ α d K 2 + αd 2 ( √ α − 1) 2 12 ∆ e,min log n .Finally, we choose α = 4 and d = K 2 3 , and substitute the above upper bound into inequality (4).

O(K) Upper Bounds
In this section, we improve on the results in Section 4 and derive O(KL(1/∆) log n) upper bounds on the n-step regret of CombUCB1. In Theorem 4, we assume that the gaps of all suboptimal solutions are identical. In Theorem 5, we relax this assumption.The key step in our analysis is that we define a cascade of infinitely-many mutually-exclusive events and then bound the number of times that these events happen when a suboptimal solution is chosen. The events are parametrized by two decreasing sequences of constants:1 = β 0 > β 1 > β 2 > . . . > β k > . . . (9) α 1 > α 2 > . . . > α k > . . .(10)such that lim i→∞ α i = lim i→∞ β i = 0. We define:m i,t = α i K 2 ∆ 2At log n and assume that m i,t = ∞ when ∆ At = 0. The events at time t are defined as: (11) at most m 1,t times} ,G 1,t = {at least β 1 K items inÃ t were observedG 2,t = {less than β 1 K items inÃ t were observed at most m 1,t times, at least β 2 K items inÃ t were observed at most m 2,t times} , . . . G i,t = {less than β 1 K items inÃ t were observedat most m 1,t times, . . . , less than β i−1 K items inÃ t were observed at most m i−1,t times, at least β i K items inÃ t were observed at most m i,t times} , . . .The following lemma establishes a sufficient condition under which events G i,t are exhaustive. This is the key step in the proofs in this section.Lemma 3. Let (α i ) and (β i ) be defined as in (9) and (10), respectively; and let:√ 6 ∞ i=1 β i−1 − β i √ α i ≤ 1 .(12)Let event F t happen. Then event G i,t happens for some i.Proof. We fix t such that ∆ At > 0. Because t is fixed, we use shorthands G i = G i,t and m i = m i,t . Let: S i = e ∈Ã t : T t−1 (e) ≤ m ibe the set of items inÃ t that are not observed "sufficiently often" under event G i . Then event G i can be written as:G i = i−1 j=1 {|S j | < β j K} ∩ {|S i | ≥ β i K} .As in Lemma 2, we prove that event G i happens for some i by showing that the event that none of our events happen cannot happen. Note that this event can be written as:G = ∞ i=1 G i = ∞ i=1 i−1 j=1 {|S j | ≥ β j K} ∪ {|S i | < β i K} = ∞ i=1 {|S i | < β i K} . LetS i =Ã t \ S i and S 0 =Ã t . Then by the definitions of S i and S i ,S i−1 ⊆S i for all i > 0. Furthermore, note that lim i→∞ m i = 0. So there must exist an integer j such that S i =Ã t for all i > j, andÃ t = ∞ i=1 (S i \S i−1 ). Finally, by the definition ofS i , T t−1 (e) > m i for all e ∈S i . Now suppose that eventḠ happens. Then:e∈Ãt 1 T t−1 (e) < ∞ i=1 e∈Si\Si−1 1 √ m i = ∞ i=1 |S i \S i−1 | √ m i < ∞ i=1 (β i−1 − β i )K √ m i ,where the last inequality is due to Lemma 4 (Appendix B).In addition, let event F t happen. Then:∆ At ≤ 2 e∈Ãt 1.5 log n T t−1 (e) < 6 log n ∞ i=1 (β i−1 − β i )K √ m i = ∆ At √ 6 ∞ i=1 β i−1 − β i √ α i ≤ ∆ At ,where the last inequality is due to our assumption in  #b11 . The above is clearly a contradiction. As a result,Ḡ cannot happen, and event G i must happen for some i. R(n) ≤ KL 267 ∆ log n + π 2 3 + 1 KL . Proof. A detailed proof is in Appendix A.4.The key idea is to bound the number of times that event G i,t happens in n steps for any i. Based on this bound, the regret due to all events G i,t is bounded as:R(n) ≤ KL 1 ∆ ∞ i=1 α i β i log n ,whereR(n) is defined in  #b4 . Finally, we choose (α i ) and (β i ), and apply the above upper bound in inequality (4).Now we generalize Theorem 4 to arbitrary gaps.Theorem 5. In any (L, K) stochastic combinatorial semibandit, the regret of CombUCB1 is bounded as:R(n) ≤ e∈Ẽ K 534 ∆ e,min log n + π 2 3 + 1 KL ,where ∆ e,min is the minimum gap of suboptimal solutions that contain item e, which is defined in  #b7 .Proof. A detailed proof is in Appendix A.5.The key idea is to introduce item-specific variants of events G i,t , G e,i,t , and associate ∆ A t βiK regret with each of these events. Then, for each item e, we order the events from the largest gap to the smallest, and show that the total regret is bounded as:R(n) < e∈Ẽ K 2 ∆ e,min ∞ i=1 α i β i log n ,whereR(n) is defined in  #b4 . Finally, we choose (α i ) and (β i ), and apply the above upper bound in inequality (4).We also prove a gap-free bound.Theorem 6. In any (L, K) stochastic combinatorial semibandit, the regret of CombUCB1 is bounded as:R(n) ≤ 47 KLn log n + π 2 3 + 1 KL .Proof. The proof is in Appendix A.6. The key idea is to decompose the regret of CombUCB1 into two parts, where the gaps are larger than and at most . We analyze each part separately and then set to get the desired result.

Lower Bounds
In this section, we derive two lower bounds on the n-step regret in stochastic combinatorial semi-bandits. One of the bounds is gap-dependent and the other one is gap-free.Our bounds are derived on a K-path semi-bandit problem, which is illustrated in Figure 1a. The items in the ground set are L path segments E = {1, . . . , L}. The feasible set Θ are L/K paths, each of which contains K unique items. Specifically, path j contains items (j − 1)K + 1, . . . , jK.Without loss of generality, we assume that L/K is an integer. The probability distribution P over the weights of the items is defined as follows. The weights of the items in the same path are equal. The weights of the items in different paths are distributed independently. The weight of item e is a Bernoulli random variable with mean:w(e) = 0.5 item e belongs to path 1 0.5 − ∆/K otherwise , where 0 < ∆/K < 0.5. Note that our problem is designed such that ∆ e,min = ∆ for any item e in path j > 1.The key observation is that our problem is equivalent to a (L/K)-arm Bernoulli bandit whose returns are scaled by K, when the learning agent knows that the weights of the items in the same path are equal. Therefore, we can derive lower bounds for our problem based on the existing lower bounds for Bernoulli bandits  #b6  #b7  #b13 .Our gap-dependent lower bound is derived for the class of consistent algorithms, which is defined as follows. We say that the algorithm is consistent if for any stochastic combinatorial semi-bandit, any suboptimal A, and any α > 0, E [T n (A)] = o(n α ), where T n (A) is the number of times that solution A is chosen in n steps. The restriction to the consistent algorithms is without loss of generality. In particular, an inconsistent algorithm is guaranteed to perform poorly on some semi-bandit, and therefore cannot achieve logarithmic regret on all semi-bandits, as CombUCB1.Proposition 1. For any L and K such that L/K is an integer, and any 0 < ∆/K < 0.5, the regret of any consistent algorithm on the K-path semi-bandit problem is bounded The K-path semi-bandit problem in Section 6. The red and blue nodes are the starting and end points of the paths, respectively. The optimal path is marked in red. b. The grid-path problem in Section 7. The red and blue nodes are the starting and end points of the paths, respectively. The optimal path is marked in red. c. The n-step regret of CombUCB1 on the grid-path problem.from below as:lim inf n→∞ R(n) log n ≥ (L − K)K 4∆ .Proof. The proposition is proved as follows:lim inf n→∞ R(n) log n (a) ≥ K L/K k=2 ∆/K D KL (0.5 − ∆/K 0.5) = L K − 1 ∆ D KL (0.5 − ∆/K 0.5) (b) ≥ (L − K)K 4∆ ,where D KL (p q) is the Kullback-Leibler (KL) divergence between two Bernoulli random variables with means p and q. Inequality (a) follows from the fact that our problem is equivalent to a (L/K)-arm Bernoulli bandit whose returns are scaled by K. Therefore, we can bound the regret from below using an existing lower bound for Bernoulli bandits  #b13 . Inequality (b) is due to D KL (p q) ≤ (p−q) 2 q(1−q) , where p = 0.5 − ∆/K and q = 0.5.We also derive a gap-free lower bound. Proposition 2. For any L and K such that L/K is an integer, and any horizon n > 0, there exists a K-path semibandit problem such that the regret of any algorithm is:R(n) ≥ 1 20 min( √ KLn, Kn) .Proof. The K-path semi-bandit problem is equivalent to a (L/K)-arm Bernoulli bandit whose payoffs are scaled by K. Therefore, we can apply Theorem 5.1 of Auer et al.  #b6  and bound the regret of any algorithm from below by: Note that the bound of Auer et al.  #b6  is for the adversarial setting. However, the worst-case environment in the proof is stochastic and therefore it applies to our problem.

Experiments
In this section, we evaluate CombUCB1 on a synthetic problem and demonstrate that its regret grows as suggested by our O(KL(1/∆) log n) upper bound. We experiment with a stochastic longest-path problem on a (m + 1) × (m + 1) square grid (Figure 1b). The items in the ground set E are the edges in the grid, 2m(m + 1) in total. The feasible set Θ are all paths in the grid from the upper left corner to the bottom right corner that follow the directions of the edges. The length of these paths is K = 2m. The weight of edge e is drawn i.i.d. from a Bernoulli distribution with mean:w(e) = 0.5 + σ/2 e is a leftmost or bottomost edge 0.5 − σ/2 otherwise , where 0 < σ < 1. The optimal solution A * is a path along the leftmost and bottommost edges (Figure 1b).The sample complexity of our problem is characterized by |Ẽ| = 2m(m + 1) − 2m gaps ∆ e,min ranging from 2σ to 2mσ. It is easy to show that the number of items e where ∆ e,min = iσ is at most 2(i − 1). Therefore, we can bound the (log n)-term in Theorem 5 as:e∈Ẽ K 534 ∆ e,min log n < 1068m 2m i=2 2i iσ log n < 4272m 2 log n σ .(13)Now we validate the dependence on m and σ empirically. We vary m and σ, and run CombUCB1 for n = 10 5 steps.Our experimental results are reported in Figure 1c. We observe two trends. First, the regret of CombUCB1 is linear in the number of items L, which depends quadratically on m since L = 2m(m + 1). Second, the regret is linear in 1/σ. The dependence on m and 1/σ is the same as in our upper bound in (13).

Related Work
Gai et al.  #b10  proposed CombUCB1 and analyzed it. Chen et al.  #b9  derived a O(K 2 L(1/∆) log n) upper bound on the n-step regret of CombUCB1. In this paper, we show that the regret of CombUCB1 is O(KL(1/∆) log n), a factor of K improvement over the upper bound of Chen et al.  #b9 . This upper bound is tight. We also prove a gap-free upper bound and show that it is nearly tight.COMBAND  #b8 , online stochastic mirror descent (OSMD)  #b3 , and follow-the-perturbed-leader (FPL) with geometric resampling  #b14  are three recently proposed algorithms for adversarial combinatorial semi-bandits. In general, OSMD achieves optimal regret but is not guaranteed to be computationally efficient, in the same sense as in Section 3. FPL does not achieve optimal regret but is computationally efficient.It is an open problem whether adversarial combinatorial semi-bandits can be solved both computationally and sample efficiently. In this paper, we close this problem in the stochastic setting.Matroid and polymatroid bandits  #b11  #b12  are instances of stochastic combinatorial semi-bandits. The n-step regret of CombUCB1 in these problems is O(L(1/∆) log n), a factor of K smaller than is suggested by our O(KL(1/∆) log n) upper bound. However, we note that the bound of Kveton et al.  #b11  #b12  is less general, as it applies only to matroids and polymatroids.Our problem can be viewed as a linear bandit  #b4  #b0 , where each solution A is associated with an indicator vector x ∈ {0, 1} E and the learning agent observes the weight of each non-zero entry of x. This feedback model is clearly more informative than that in linear bandits, where the learning agent observes just the sum of the weights. Therefore, our learning problem has lower sample complexity. In particular, note that our Ω( √ KLn) lower bound (Proposition 2) is √ K smaller than that of Audibert et al.  #b3  (Theorem 5) for combinatorial linear bandits. The bound of Audibert et al.  #b3  is proved for the adversarial setting. Nevertheless, it applies to our setting because the worst-case environment in the proof is stochastic.Russo and Van Roy  #b16 , and Wen et al.  #b18 , derived upper bounds on the Bayes regret of Thompson sampling in stochastic combinatorial semi-bandits. These bounds have a similar form as our gap-free upper bound in Theorem 6. However, they differ from our work in two aspects. First, the Bayes regret is a different performance metric from regret. From the frequentist perspective, it is a much weaker metric. Second, we also derive O(log n) upper bounds.

Extensions
The computational efficiency of CombUCB1 depends on the computational efficiency of the offline optimization oracle. When the oracle is inefficient, we suggest resorting to approximations. Let ALG be a computationally-efficient oracle that returns an approximation. Then CombUCB1 can be straightforwardly modified to call ALG instead of the original oracle. Moreover, it is easy to bound the regret of this algorithm if it is measured with respect to the best approximate solution by ALG in hindsight.Thompson sampling  #b17  often performs better in practice than UCB1  #b5 . It is straightforward to propose a variant of CombUCB1 that uses Thompson sampling, by replacing the UCBs in Algorithm 1 with sampling from the posterior on the mean of the weights. The frequentist analysis of regret in Thompson sampling  #b1  resembles the analysis of UCB1. Therefore, we believe that our analysis can be generalized to Thompson sampling, and we hypothesize that the regret of the resulting algorithm is O(KL(1/∆) log n).

Conclusions
The main contribution of this work is that we derive novel gap-dependent and gap-free upper bounds on the regret of CombUCB1, a UCB-like algorithm for stochastic combinatorial semi-bandits. These bounds are tight up to polylogarithmic factors. In other words, we show that CombUCB1 is sample efficient because it achieves near-optimal regret. It is well known that CombUCB1 is also computationally efficient  #b10 , it can be implemented efficiently whenever the offline variant of the problem can be solved computationally efficiently. Therefore, we indirectly show that stochastic combinatorial semi-bandits can be solved both computationally and sample efficiently, by CombUCB1.Theorems 4 and 5 are proved quite generally, for any (α i ) and (β i ) subject to relatively mild constraints. At the end of the proofs, we choose (α i ) and (β i ) to be geometric sequences. This is sufficient for our purpose. But the choice is likely to be suboptimal and may lead to larger constants in our upper bounds than is necessary. We leave the problem of choosing better (α i ) and (β i ) for future work. Our O( √ KLn log n) upper bound matches the Ω( √ KLn) lower bound up to a factor of √ log n. We believe that this factor can be eliminated by modifying the confidence radii in CombUCB1 (2) along the lines of Audibert et al.  #b2 . We leave this for future work.

A Proofs of Main Theorems


A.1 Proof of Lemma 1
Let R t = R(A t , w t ) be the stochastic regret of CombUCB1 at time t, where A t and w t are the solution and the weights of the items at time t, respectively. Furthermore, let E t = ∃e ∈ E : w(e) −ŵ Tt−1(e) (e) ≥ c t−1,Tt−1(e) be the event that w(e) is outside of the high-probability confidence interval aroundŵ Tt−1(e) (e) for some item e at time t; and let E t be the complement of E t ,w(e) is in the high-probability confidence interval aroundŵ Tt−1(e) (e) for all e at time t. Then we can decompose the regret of CombUCB1 as:R(n) = E t0−1 t=1 R t + E n t=t0 1{E t } R t + E n t=t0 1 E t R t .Now we bound each term in our regret decomposition.The regret of the initialization, E t0−1 t=1 R t , is bounded by KL because Algorithm 2 terminates in at most L steps, and R t ≤ K for any A t and w t .The second term in our regret decomposition, E n t=t0 1{E t } R t , is small because all of our confidence intervals hold with high probability. In particular, for any e, s, and t:P (|w(e) −ŵ s (e)| ≥ c t,s ) ≤ 2 exp[−3 log t] ,and therefore:E n t=t0 1{E t } ≤ e∈E n t=1 t s=1 P (|w(e) −ŵ s (e)| ≥ c t,s ) ≤ 2 e∈E n t=1 t s=1 exp[−3 log t] ≤ 2 e∈E n t=1 t −2 ≤ π 2 3 L .Since R t ≤ K for any A t and w t , E n t=t0 1{E t } R t ≤ π 2 3 KL. Finally, we rewrite the last term in our regret decomposition as:E n t=t0 1 E t R t (a) = n t=t0 E 1 E t E [R t | A t ] (b) = E n t=t0 ∆ At 1 E t , ∆ At > 0 .In equality (a), the outer expectation is over the history of the agent up to time t, which in turn determines A t and E t ; and E [R t | A t ] is the expected regret at time t conditioned on solution A t . Equality (b) follows from ∆ At = E [R t | A t ]. Now we bound ∆ At 1 E t , ∆ At > 0 for any suboptimal A t . The bound is derived based on two facts. First, when CombUCB1chooses A t , f (A t , U t ) ≥ f (A * , U t ). This further implies that e∈At\A * U t (e) ≥ e∈A * \At U t (e). Second, when event E t happens, w(e) −ŵ Tt−1(e) (e) < c t−1,Tt−1(e) for all items e. Therefore:e∈At\A * w(e) + 2 e∈At\A * c t−1,Tt−1(e) ≥ e∈At\A * U t (e) ≥ e∈A * \At U t (e) ≥ e∈A * \At w(e) ,and 2 e∈At\A * c t−1,Tt−1(e) ≥ ∆ At follows from the observation that ∆ At = e∈A * \Atw (e) − e∈At\A * w(e). Now note that c n,Tt−1(e) ≥ c t−1,Tt−1(e) for any time t ≤ n. Therefore, the event F t in (3) must happen and:E n t=t0 ∆ At 1 E t , ∆ At > 0 ≤ E n t=t0 ∆ At 1{F t } .This concludes our proof.

A.2 Proof of Theorem 2
By Lemma 1, it remains to boundR(n) = n t=t0 ∆ At 1{F t }, where the event F t is defined in (3). By Lemma 2 and from the assumption that ∆ At = ∆ for all suboptimal A t , it follows that:R(n) = ∆ n t=t0 1{F t } = ∆ n t=t0 1{G 1,t , ∆ At > 0} + ∆ n t=t0 1{G 2,t , ∆ At > 0} .To bound the above quantity, it is sufficient to bound the number of times that events G 1,t and G 2,t happen. Then we set the tunable parameters d and α such that the two counts are of the same magnitude. Claim 1. Event G 1,t happens at most α d K 2 L 6 ∆ 2 log n times.Proof. Recall that event G 1,t can happen only if at least d chosen suboptimal items are not observed "sufficiently often" up to time t, T t−1 (e) ≤ αK 2 6 ∆ 2 log n for at least d items inÃ t . After the event happens, the observation counters of these items increase by one. Therefore, after the event happens α d K 2 L 6 ∆ 2 log n times, all suboptimal items are guaranteed to be observed at least αK 2 6 ∆ 2 log n times and G 1,t cannot happen anymore.Claim 2. Event G 2,t happens at most αd 2 ( √ α − 1) 2 L 6 ∆ 2 log n times.Proof. Event G 2,t can happen only if there exists e ∈Ã t such that T t−1 (e) ≤ αd 2( √ α−1) 2 6 ∆ 2 log n.After the event happens, the observation counter of item e increases by one. Therefore, the number of times that event G 2,t can happen is bounded trivially by αd 2( √ α−1) 2 L 6 ∆ 2 log n.Based on Claims 1 and 2,R(n) is bounded as:R(n) ≤ α d K 2 + αd 2 ( √ α − 1) 2 L 6 ∆ log n .Finally, we choose α = 4 and d = K 2 3 ; and it follows that the regret is bounded as:R(n) ≤ E R (n) + π 2 3 + 1 KL ≤ K 4 3 L 48 ∆ log n + π 2 3 + 1 KL .

A.3 Proof of Theorem 3
Let F t be the event in (3). By Lemmas 1 and 2, it remains to bound:R(n) = n t=t0 ∆ At 1{F t } = n t=t0 ∆ At 1{G 1,t , ∆ At > 0} + n t=t0 ∆ At 1{G 2,t , ∆ At > 0} .In the next step, we introduce item-specific variants of events G 1,t (6) and G 2,t (7), and then associate the regret at time t with these events. In particular, let:G e,1,t = G 1,t ∩ e ∈Ã t , T t−1 (e) ≤ αK 2 6 ∆ 2 At log n (14) G e,2,t = G 2,t ∩ e ∈Ã t , T t−1 (e) ≤ αd 2 ( √ α − 1) 2 6 ∆ 2 At log n(15)be the events that item e is not observed "sufficiently often" under events G 1,t and G 2,t , respectively. Then by the definitions of the above events, it follows that:1{G 1,t , ∆ At > 0} ≤ 1 d e∈Ẽ 1{G e,1,t , ∆ At > 0} 1{G 2,t , ∆ At > 0} ≤ e∈Ẽ 1{G e,2,t , ∆ At > 0} ,whereẼ = E \ A * is the set of subptimal items; and we boundR(n) as:R(n) ≤ e∈Ẽ n t=t0 1{G e,1,t , ∆ At > 0} ∆ At d + e∈Ẽ n t=t01{G e,2,t , ∆ At > 0} ∆ At .  + e∈Ẽ 6αd 2 log n ( √ α − 1) 2 ∆ e,1 1 ∆ 2 e,1 + Ne k=2 ∆ e,k 1 ∆ 2 e,k − 1 ∆ 2 e,k−1 (c) < e∈Ẽ α d K 2 + αd 2 ( √ α − 1) 2 12 ∆ e,Finally, we choose α = 4 and d = K 2 3 ; and it follows that the regret is bounded as:R(n) ≤ E R (n) + π 2 3 + 1 KL ≤ e∈Ẽ K 4 396 ∆ e,min log n + π 2 3 + 1 KL .

A.4 Proof of Theorem 4
The first step of the proof is identical to that of Theorem 2. By Lemma 1, it remains to boundR(n) = n t=t0 ∆ At 1{F t }, where the event F t is defined in (3). By Lemma 3 and from the assumption that ∆ At = ∆ for all suboptimal A t , it follows that:R(n) = ∆ n t=t0 1{F t } = ∆ ∞ i=1 n t=t0 1{G i,t , ∆ At > 0} .Note that ∆ At > 0 implies ∆ At = ∆. Therefore, m i,t does not depend on t and we denote it by m i = α i K 2 ∆ 2 log n. Based on the same argument as in Claim 1, event G i,t cannot happen more than Lmi βiK times, because at least β i K items that are observed at most m i times have their observation counters incremented in each event G i,t . Therefore:R(n) ≤ ∆ ∞ i=1 Lm i β i K = KL 1 ∆ ∞ i=1 α i β i log n .(17)It remains to choose (α i ) and (β i ) such that:• lim i→∞ α i = lim i→∞ β i = 0;• Monotonicity conditions in (9) and (10) hold;• Inequality (12) holds,√ 6 ∞ i=1 βi−1−βi √ αi ≤ 1; • ∞ i=1αi βi is minimized.We choose (α i ) and (β i ) to be geometric sequences, β i = β i and α i = dα i for 0 < α, β < 1 and d > 0. For this setting, α i → 0 and β i → 0, and the monotonicity conditions are also satisfied. Moreover, if β < √ α, we have:√ 6 ∞ i=1 β i−1 − β i √ α i = √ 6 ∞ i=1 β i−1 − β i √ dα i = 6 d 1 − β √ α − β ≤ 1 provided that d ≥ 6 1−β √ α−β 2. Furthermore, if α < β, we have:∞ i=1 α i β i = ∞ i=1 dα i β i = dα β − α .Given the above, the best choice of d is6 1−β √ α−β 2and the problem of minimizing the constant in our regret bound can be written as:inf α,β 6 1 − β √ α − β 2 α β − α s.t. 0 < α < β < √ α < 1 .We find the solution to the above problem numerically, and determine it to be α = 0.1459 and β = 0.2360. For these α and β, 6 1−β √ α−β 2 α β−α < 267. We apply this upper bound to  #b16  and it follows that the regret is bounded as:R(n) ≤ E R (n) + π 2 3 + 1 KL ≤ KL 267 ∆ log n + π 2 3 + 1 KL .

A.5 Proof of Theorem 5
Let F t be the event in (3). By Lemmas 1 and 3, it remains to bound:R(n) = n t=t0 ∆ At 1{F t } = ∞ i=1 n t=t0 ∆ At 1{G i,t , ∆ At > 0} .In the next step, we define item-specific variants of events G i,t (11) and associate the regret at time t with these events. In particular, let:G e,i,t = G i,t ∩ e ∈Ã t , T t−1 (e) ≤ m i,t(18)be the event that item e is not observed "sufficiently often" under event G i,t . Then it follows that:1{G i,t , ∆ At > 0} ≤ 1 β i K e∈Ẽ 1{G e,i,t , ∆ At > 0} ,because at least β i K items are not observed "sufficiently often" under event G i,t . Therefore, we can boundR(n) as:R(n) ≤ e∈Ẽ ∞ i=1 n t=t01{G e,i,t , ∆ At > 0} ∆ At β i K .

Tight Regret Bounds for Stochastic Combinatorial Semi-Bandits
Let each item e be contained in N e suboptimal solutions and ∆ e,1 ≥ . . . ≥ ∆ e,Ne be the gaps of these solutions, ordered from the largest gap to the smallest one. ThenR(n) can be further bounded as:R(n) ≤ e∈Ẽ ∞ i=1 n t=t0Ne k=1 1{G e,i,t , ∆ At = ∆ e,k } ∆ e,k β i K and inequality (c) follows from  #b15 . For the same (α i ) and (β i ) as in Theorem 4, we have ∞ i=1 αi βi < 267 and it follows that the regret is bounded as:R(n) ≤ E R (n) + π 2 3 + 1 KL ≤ e∈Ẽ K 534∆ e,min log n + π 2 3 + 1 KL .

A.6 Proof of Theorem 6
The key idea is to decompose the regret of CombUCB1 into two parts, where the gaps are larger than and at most . We analyze each part separately and then set to get the desired result.By Lemma 1, it remains to boundR(n) = n t=t0 ∆ At 1{F t }, where the event F t is defined in (3). We partitionR(n) as:R(n) = n t=t0 ∆ At 1{F t , ∆ At < } + n t=t0 ∆ At 1{F t , ∆ At ≥ } ≤ n + n t=t0 ∆ At 1{F t , ∆ At ≥ }and bound the first term trivially. The second term is bounded in the same way asR(n) in the proof of Theorem 5, except that we only consider the gaps ∆ e,k ≥ . Therefore, ∆ e,min ≥ and we get: Based on the above inequalities:R(n) ≤ 534KL log n + n + π 2 3 + 1 KL .Finally, we choose = 534KL log n n and get: R(n) ≤ 2 534KLn log n + π 2 3 + 1 KL < 47 KLn log n + π 2 3 + 1 KL , which concludes our proof.

B Technical Lemmas
Lemma 4. Let S i ,S i , and m i be defined as in Lemma 3; and |S i | < β i K for all i > 0. Then:∞ i=1 |S i \S i−1 | √ m i < ∞ i=1 (β i−1 − β i )K √ m i .Proof. The lemma is proved as:∞ i=1 |S i \S i−1 | 1 √ m i = ∞ i=1 (|S i−1 \ S i |) 1 √ m i = ∞ i=1 (|S i−1 | − |S i |) 1 √ m i = |S 0 | √ m 1 + ∞ i=1 |S i | 1 √ m i+1 − 1 √ m i < β 0 K √ m 1 + ∞ i=1 β i K 1 √ m i+1 − 1 √ m i = ∞ i=1 (β i−1 − β i )K 1 √ m i .The first two equalities follow from the definitions ofS i and S i . The inequality follows from the facts that |S i | < β i K for all i > 0 and |S 0 | ≤ β 0 K.