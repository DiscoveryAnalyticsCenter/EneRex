Under consideration for publication in Theory and Practice of Logic Programming Efficient Computation of the Well-Founded Semantics over Big Data

Abstract
Data originating from the Web, sensor readings and social media result in increasingly huge datasets. The so called Big Data comes with new scientific and technological challenges while creating new opportunities, hence the increasing interest in academia and industry. Traditionally, logic programming has focused on complex knowledge structures/programs, so the question arises whether and how it can work in the face of Big Data. In this paper, we examine how the well-founded semantics can process huge amounts of data through mass parallelization. More specifically, we propose and evaluate a parallel approach using the MapReduce framework. Our experimental results indicate that our approach is scalable and that wellfounded semantics can be applied to billions of facts. To the best of our knowledge, this is the first work that addresses large scale nonmonotonic reasoning without the restriction of stratification for predicates of arbitrary arity.

Introduction
Huge amounts of data are being generated at an increasing pace by sensor networks, government authorities and social media. Such data is heterogeneous, and often needs to be combined with other information, including database and web data, in order to become more useful. This big data challenge is at the core of many contemporary scientific, technological and business developments.The question arises whether the reasoning community, as found in the areas of knowledge representation, rule systems, logic programming and semantic web, can connect to the big data wave. On the one hand, there is a clear application scope, e.g. deriving higher-level knowledge, assisting decision support and data cleaning. But on the other hand, there are significant challenges arising from the area's traditional focus on rich knowledge structures instead of large amounts of data, and its reliance on in-memory methods. The best approach for enabling reasoning with big data is parallelization, as established e.g. by the LarKC project  #b5 ).As discussed in  #b5 ), reasoning on the large scale can be achieved through parallelization by distributing the computation among nodes. There are mainly two proposed approaches in the literature, namely rule partitioning and data partitioning  #b20 ).In the case of rule partitioning, the computation of each rule is assigned to a node in the cluster. arXiv:1405.2590v1 [cs.AI] 11 May 2014 defined map and reduce functions are run in parallel. The former performs a user-defined operation over an arbitrary part of the input and partitions the data, while the latter performs a user-defined operation on each partition. MapReduce is designed to operate over key/value pairs. Specifically, each Map function receives a key/value pair and emits a set of key/value pairs. Subsequently, all key/value pairs produced during the map phase are grouped by their key and passed to reduce phase. During the reduce phase, a Reduce function is called for each unique key, processing the corresponding set of values.Let us illustrate the wordcount example. In this example, we take as input a large number of documents and calculate the frequency of each word. The pseudo-code for the Map and Reduce functions is provided in Appendix A.Consider the following documents as input:Doc1: "Hello world." Doc2: "Hello MapReduce."During map phase, each map operation gets as input a line of a document. Map function extracts words from each line and emits pairs of the form <w, "1"> meaning that word w occurred once ("1"), namely the following pairs:<Hello, 1> <world, 1> <Hello, 1> <MapReduce, 1>MapReduce framework will perform grouping/sorting resulting in the following intermediate pairs:<Hello, <1,1>> <world, 1> <MapReduce, 1>During the reduce phase, the Reduce function sums up all occurrence values for each word emitting a pair containing the word and the frequency of the word. Thus, the reducer with key:Hello will emit <Hello, 2> world will emit <world, 1> MapReduce will emit <MapReduce, 1>

Well-Founded Semantics
In this section we provide the definition of the well-founded semantics (WFS) as it was defined in  #b7 ).Definition 2.1  #b7 ) A general logic program is a finite set of general rules, which may have both positive and negative subgoals. A general rule is written with its head, or conclusion on the left, and its subgoal (body), if any to the right of the symbol "←", which may be read "if". For example,p(X) ← a(X), not b(X).is a rule in which p(X) is the head, a(X) is a positive subgoal, and b(X) is a negative subgoal. This rule may be read as "p(X) if a(X) and not b(X)". A Horn rule is one with no negative subgoals, and a Horn logic program is one with only Horn rules.We use the following conventions. A logical variable starts with a capital letter while a constant or a predicate starts with a lowercase letter. Note that functions are not allowed. A predicate of arbitrary arity will be referred as a literal. Constants, variables and literals are terms. A ground term is a term with no variables. The Herbrand universe is the set of constants in a given program. The Herbrand base is the set of ground terms that are produced by the substitution of variables with constants in the Herbrand universe. In this paper, we will refer to Horn rules also as definite rules, likewise Horn programs will also be referred to as definite programs.Definition 2.2  #b7 ) Given a program P, a partial interpretation I is a consistent set of literals whose atoms are in the Herbrand base of P. A total interpretation is a partial interpretation that contains every atom of the Hebrand base or its negation. We say a ground (variable-free) literal is true in I when it is in I and say it is false in I when its complement is in I. Similarly, we say a conjunction of ground literals is true in I if all of the literals are true in I, and is false in I if any of its literals is false in I. Definition 2.3  #b7 ) Let a program P, its associated Herbrand base H and a partial interpretation I be given. We say A ⊆ H is an unfounded set (of P) with respect to I if each atom p ∈ A satisfies the following condition: For each instantiated rule R of P whose head is p, (at least) one of the following holds:1. Some (positive or negative) subgoal of the body is false in I.

Some positive subgoal of the body occurs in A.
A literal that makes (1) or (2) above true is called a witness of unusability for rule R (with respect to I).Theorem 2.1  #b7 ) The data complexity of the well-founded semantics for function-free programs is polynomial time.In this paper, we require each rule to be safe, that is, each variable in a rule must occur (also) in a positive subgoal. Safe programs consist of safe rules only. This safety criterion is an adaptation of range restriction  #b16 ), which guarantees the important concept of domain independence, originally studied in deductive databases (see for example  #b0 )). Apart from this semantic property, the safety condition implicitly also enforces a certain locality of computation, which is important for our proposed method, as we shall discuss in Section 4.2.

Alternating Fixpoint Procedure
In this section, we provide the definition of the alternating fixpoint procedure as it was defined in  #b2 ). Definition 2.5  #b2 ) (Extended Immediate Consequence Operator) Let P be a normal logic program. Let I and J be sets of ground atoms. The set T P,J (I) of immediate consequences of I w.r.t. P and J is defined as follows: If P is definite, the set J is not needed and we obtain the standard immediate consequence operator T P by T P (I) = T P, / 0 (I).For an operator T we define T ↑ 0 := / 0 and T ↑ i := T (T ↑ i − 1), for i > 0. lfp(T ) denotes the least fixpoint of T , i.e. the smallest set S such that T (S) = S. Definition 2.6  #b2 ) (Alternating Fixpoint Procedure) Let P be a normal logic program. Let P + denote the subprogram consisting of the definite rules of P. Then the sequence (K i ,U i ) i≥0 with set K i of true (known) facts and U i of possible (unknown) facts is defined by:K 0 := lfp(T P + ) U 0 := lfp(T P,K 0 ) i > 0 : K i := lfp(T P,U i−1 ) U i := lfp(T P,K i )The computation terminates when the sequence becomes stationary, i.e., when a fixpoint is reached in the sense that (K i ,U i ) = (K i+1 ,U i+1 ). This computation schema is called the Alternating Fixpoint Procedure (AFP).We rely on the definition of the well-founded partial model W * p of P as given in  #b7 ).Theorem 2.2  #b2 ) (Correctness of AFP) Let the sequence (K i ,U i ) i≥0 be defined as above. Then there is a j ≥ 0 such that (K j ,U j )= (K j+1 ,U j+1 ). The well-founded model W * p of P can be directly derived from the fixpoint (K j ,U j ), i.e.,W * p = {L | L is a positive ground literal and L ∈ K j or L is a negative ground literal not A and A ∈ BASE(P) − U j },where BASE(P) is the Herbrand base of program P.Lemma 2.1  #b2 ) (Monotonicity) Let the sequence (K i ,U i ) i≥0 be defined as above. Then the following holds for i ≥ 0 :K i ⊆ K i+1 , U i ⊇ U i+1 , K i ⊆ U i .3 Computing T P,J (I)Consider the following program:p(X,Y) ← a(X,Z), b(Z,Y), not c(X,Z), not d(Z,Y).Here p(X,Y) is our final goal, a(X,Z) and b(Z,Y) are positive subgoals, while c(X,Z) and d(Z,Y) are negative subgoals. In order to compute our final goal p(X,Y) we need to ensure that {a(X,Z), b(Z,Y)} ⊆ I and {c(X,Z), d(Z,Y)} ∩ J = / 0 (see Definition 2.5), namely both a(X,Z) and b(Z,Y) are in I while none of c(X,Z) and d(Z,Y) is found in J.As positive subgoals depend on I we can group them into a positive goal. A positive goal consists of a new predicate (say ab) that contains as arguments the union of two sets: (a) all the arguments of the final goal (X,Y) and (b) all the common arguments between positive and negative subgoals (X,Z,Y), namely we need to compute ab(X,Z,Y). The final goal (p(X,Y)) consists of all values of the positive goal (ab(X,Z,Y)) that do not match any of the negative subgoals (c(X,Z) and d(Z,Y)) on their common arguments (X,Z and Z,Y respectively).

Positive goal calculation
Consider the following program:  #b3 ), calculating the positive goal ab(X,Z,Y), can be performed as described below. The pseudo-code for the Map and Reduce functions is provided in Appendix A. Note that we use only literals from I.p(X,Y) ← a(X,Z), b(Z,Y), not c(X,Z), not d(Z,Y). where I = {a(1,2), a(1,3), b(2,4), b(3,5)} J = {c(1,2), d(2,3)} A single joinThe Map function will emit pairs of the form <Z,(a,X)> for predicate a and <Z,(b,Y)> for predicate b, namely the following pairs:<2, (a,1)> <3, (a,1)> <2, (b,4)> <3, (b,5)> MapReduce framework will perform grouping/sorting resulting in the following intermediate pairs:<2, <(a,1), (b,4)>> <3, <(a,1), (b,5)>> During the reduce phase we match predicates a and b on their common argument (which is the key) and use the values to emit positive goals. Thus, the reducer with key: 2 will emit ab(1,2,4) 3 will emit ab(1,3,5)Note that we need to filter out possibly occurring duplicates as soon as possible because they will produce unnecessary duplicates as well, affecting the overall performance. The pseudo-code and a brief description of duplicate elimination are provided in Appendix A.For rules with more than one join between positive subgoals we need to apply multi-joins (multi-way join).Consider the following program:q(X,Y) ← a(X,Z), b(Z,W), c(W,Y), not d(X,W).We can compute the positive goal (abc(X,W,Y)) by applying our approach for single join twice. First, we need to join a(X,Z) and b(Z,W) on Z, producing a temporary literal (say ab(X,W)), and then join ab(X,W) and c(W,Y) on W producing the positive goal (abc(X,W,Y)). Once abc(X,W,Y) is calculated, we proceed with calculating the final goal q(X,Y) by retaining all the values of abc(X,W,Y) that do not match d(X,W) on their common arguments (X,W). For details on single and multi-way join, readers are referred to literature. More specifically, multi-way join has been described and optimized in  #b1 ). In order to achieve an efficient implementation, optimizations in (Afrati and Ullman (2010)) should be taken into consideration.

Final goal calculation
Consider the program mentioned at the beginning of Section 3.1. By calculating the positive goal ab(X,Z,Y) we obtain the following knowledge:ab (1,2,4) ab (1,3,5) In order to calculate the final goal (p(X,Y)) we need to perform an anti-join  #b3 ) between ab(X,Z,Y) and each negative subgoal (c(X,Z) and d(Z,Y)). Note that to perform an anti-join we use only the previously calculated positive goal (ab(X,Z,Y)) and literals from J.We start by performing an anti-join between ab(X,Z,Y) and c(X,Z) on their common arguments (X,Z), creating a new literal (say abc(X,Z,Y)), which contains all the results from ab(X,Z,Y) that are not found in c(X,Z), as described below. The pseudo-code for the Map and Reduce functions is provided in Appendix A.The Map function will emit pairs of the form <(X,Z),(ab,Y)> for predicate ab and <(X,Z),c> for predicate c (while predicate d will be taken into consideration during the next anti-join), namely the following pairs:<(1,2), (ab,4)> <(1,3), (ab,5)> <(1,2), c> MapReduce framework will perform grouping/sorting resulting in the following intermediate pairs:<(1,2), <(ab,4), (c)>> <(1,3), (ab,5)> During the reduce phase we output values of the predicate ab only if it is not matched by predicate c on their common arguments (which are contained in the key) and emit abc(X,Z,Y). Thus, the reducer with key:(1,2) will have no output (1,3) will emit abc(1,3,5)In order to calculate the final goal (p(X,Y)), we need to perform an additional anti-join between abc(X,Z,Y) and d(Z,Y) on their common arguments (Z,Y). Here, abc(1,3,5) and d(2,3) do not match on their common arguments (Z,Y) as (3,5) = (2,3). Thus, our calculated final goal is p(1,5).

Computing the Well-Founded Semantics
In this section we describe an optimized implementation for the calculation of the well-founded semantics. A naive implementation is considered as one following Definition 2.6 while ignoring the monotonicity properties of the well-founded semantics (see Lemma 2.1).

Optimized implementation
A naive implementation would introduce unnecessary overhead to the overall computation since it comes with the overhead of reasoning over and storage of overlapping sets of knowledge. A more refined version of both WFS fixpoint and least fixpoint of T P,J (I) is defined in Algorithm 1 and Algorithm 2 respectively.Algorithm 1 Optimized WFS fixpoint opt WFS fixpoint(P): input: program P 1: K 0 = opt lfp(P+, / 0, / 0); output: set of literals K i−1 , U i−1 2: i = 0; 3: repeat 4:U i = K i ∪ opt lfp(P, K i , K i ); 5: i++;next "inference step" 6: Our first optimization is the changed calculation of the least fixpoint of T P,J (I) (opt lfp), which is depicted in Algorithm 2. Instead of calculating the least fixpoint starting from I = / 0, for a given program P and a set of literals J, we allow the calculation to start from a given I, provided that I ⊆ lfp(T P,J ( / 0)), and return only the newly inferred literals (S) that led us to the least fixpoint. Thus, the actual set of literals that the least fixpoint of T P,J (I) consists of is I ∪ S. In order to reassure correctness we need to take into consideration both I and S while calculating the least fixpoint, namely new literals are inferred by calculating T P,J (I ∪ S). However, we use a temporary set of inferred literals (new) in order to eliminate duplicates (new = new − (I ∪ S)) prior to adding newly inferred literals to the set S (S = S ∪ new). Note that the set of literals I remains unchanged when the optimized least fixpoint is calculated.K i = K i−1 ∪ opt lfp(P, K i−1 , U i−1 ); 7: until K i−1 .size() == K i .size() 8: return K i−1 , U i−1 ;The optimized version of the least fixpoint is used, in Algorithm 1, for the computation of each set of literals K and U. K 0 is a special case where we start from I = / 0 and J = / 0, and thus, unable to fully utilize the advantages of the optimized least fixpoint.The proposed optimizations are mainly based on the monotonicity of the well-founded semantics as given in Lemma 2.1. Note that in this section, the indices of the sets K and U found in Lemma 2.1 are adjusted to the indices used in Algorithm 1 in order to facilitate our discussion.Since K i ⊆ U i , for i ≥ 0 (see Lemma 2.1), the computation of U i can start from K i , namely I = K i . Thus, instead of recomputing all literals of K i while calculating U i , we can use them to speed up the process. Note that the actual least fixpoint of U i is the union of sets K i and opt lfp(P, K i , K i ), as the optimized least fixpoint computes only new literals (which are not included in given I).Since K i−1 ⊆ K i , for i ≥ 1 (see Lemma 2.1), the computation of K i can start from K i−1 , namely I = K i−1 . Once opt lfp(P, K i−1 , U i−1 ) is computed, we append it to our previously stored knowledge K i−1 , resulting in K i . In addition, a WFS fixpoint is reached when K i−1 = K i , namely when K i−1 and K i have the same number of literals.Proof If K i−1 = K i , for i ≥ 1, then U i−1 = K i−1 ∪ opt lfp(P, K i−1 , K i−1 ) = K i ∪ opt lfp(P, K i , K i ) = U i Thus, fixpoint is reached as (K i−1 ,U i−1 ) =(K i ,U i ).According to Theorem 2.2, having reached WFS fixpoint at step i, we can determine which literals are true, undefined and false as follows: (a) true literals, denoted by K i , (b) undefined literals, denoted by U i − K i and (c) false literals, denoted by BASE(P) − U i .Although for K i calculation only new literals are inferred during each "inference step", for U i we have to recalculate a subset of literals that can be found in U i−1 , as literals in U i−1 − K i−1 are discarded prior to the computation of U i . However, the computational overhead coming from the calculation of opt lfp(P, K i , K i ) reduces over time since the set of literals in U i − K i becomes smaller after each "inference step" due to K i−1 ⊆ K i and U i−1 ⊇ U i , for i ≥ 1, (see Lemma 2.1).We may further optimize our approach by minimizing the amount of stored literals. A naive implementation would require the storage of up to four overlapping sets of literals (K i−1 , U i−1 , K i , U i ). However, as K i ⊆ U i , while calculating U i , we need to store in our knowledge base only the sets K i and opt lfp(P, K i , K i ), since U i = K i ∪ opt lfp(P, K i , K i ).As K i−1 ⊆ K i , for the calculation of K i , we need to store in our knowledge base only three sets of literals, namely: (a) K i−1 , (b) U i−1 − K i−1 = opt lfp(P, K i−1 , K i−1 ) and (c) currently calculating least fixpoint opt lfp(P, K i−1 , U i−1 ). All newly inferred literals in opt lfp(P, K i−1 , U i−1 ), are added to K i (replacing our prior knowledge about K i−1 ), while literals in U i−1 -K i−1 = opt lfp(P, K i−1 , K i−1 ) are deleted, if fixpoint is not reached, as they cannot be used for the computation of U i .A WFS fixpoint is reached when K i−1 = K i , namely when no new literals are derived during the calculation of K i , which practically is the calculation of opt lfp(P, K i−1 , U i−1 ). Since (K i−1 ,U i−1 ) = (K i ,U i ), we return the sets of literals K i−1 and U i−1 , representing our fixpoint knowledge base.In practice, the maximum amount of stored data occurs while calculating K i , for i ≥ 1, where we need to store three sets of literals, namely: (a) K i−1 , (b) U i−1 − K i−1 and (c) opt lfp(P, K i−1 , U i−1 ), requiring significantly less storage space compared to the naive implementation.

Computational Impact of Safety
In this paper, we follow the alternating fixpoint procedure, over safe WFS programs, in order to avoid full materialization of or reasoning over the Herbrand base for any predicate. Storing or performing reasoning over the entire Herbrand base may easily become prohibiting even for small datasets, and thus, not applicable to big data.Apart from the semantic motivation of the safety requirement outlined in Section 2.2, it also has considerable impact on the computational method followed in this paper. Recall that safety requires that each variable in a rule must occur (also) in a positive subgoal. If this safety condition is not met, an anti-join is no longer a single lookup between the positive goal and a negative subgoal, but a comparison between a subset of the Herbrand base and a given set of literals J. An efficient implementation for such computation is yet to be defined and problematic, as illustrated next. Consider the following program:p(X,Y) ← a(X,Y), not b(Y,Z). q(X,Y) ← c(X,U), not d(W,U), not e(U,Y).For the first rule, each (X,Y) in a(X,Y) is included in the final goal (p(X,Y)) only if for a given Y, there is a Z the in Herbrand universe such that b(Y,Z) does not belong to J. For the second rule, for each (X,Y) that is included in the final goal (q(X,Y)) there should be a literal c(X,U) that does not match neither d(W,U) on U, for any W in Herbrand universe, nor e(U,Y) on U, for any Y in Herbrand universe. Thus, we need to perform reasoning over a subset of the Herbrand base for b(Y,Z), d(W,U) and e(U,Y) in order to find the nonmatching literals.

Experimental results
Methodology. In order to evaluate our approach, we surveyed available benchmarks in the literature. In  #b12 ), the authors evaluate the performance of several rule engines on data that fit in main memory. However, our approach is targeted on data that exceed the capacity of the main memory. Thus, we follow the proposed methodology in  #b12 ) while adjusting several parameters. In  #b12 ) loading and inference time are separated, focusing on inference time. However, for our approach such a separation is difficult as loading and inference time may overlap. We evaluate our approach considering default negation by applying the win-not-win test and merge large (anti-)join tests with datalog recursion and default negation, creating a new test called transitive closure with negation. Other metrics in  #b12 ), such as indexing, are not supported by the MapReduce framework, while all optimizations and cost-based analysis were performed manually.Platform. We have implemented our experiments using the Hadoop MapReduce framework 1 , version 1.2.1. We have performed experiments on a cluster of the University of Huddersfield. The cluster consists of 8 nodes (one node was allocated as "master" node), using a Gigabit Ethernet interconnect. Each node was equipped with 4 cores running at 2.5GHz, 8GB RAM and 250GB of storage space.Evaluation tests. The win-not-win test  #b12 ) consists of a single rule, where move is the base relation:win(X) ← move(X,Y), not win(Y).We test the following data distributions:• the base facts form a cycle: {move(1,2), ..., move(i, i+1), ..., move(n-1,n), move(n,1)}.• the data is tree-structured: {move(i, 2*i), move(i, 2*i+1) | 1 ≤ i ≤ n}.We used four cyclic datasets and four tree-structured datasets with 125M, 250M, 500M and 1000M facts.The transitive closure with negation test consists of the following rule set, where b is the base relation:tc(X,Y) ← par(X,Y). par(X,Y) ← b(X,Y), not q(X,Y). tc(X,Y) ← par(X,Z), tc(Z,Y). par(X,Y) ← b(X,Y), b(Y,Z), not q(Y,Z). q(X,Y) ← b(Z,X), b(X,Y), not q(Z,X).We test the following data distribution:• the base facts are chain-structured: {b(i, i+k) | 1 ≤ i ≤ n, k < n}. Intuitively, the i values are distributed over n/k levels, allowing n/k − 1 joins in the formed chain.The transitive closure with negation test allows for comparing the performance of the naive and the optimized WFS fixpoint calculation when the computation of lfp(T P,J (I)) starts from I = / 0 and I = / 0 respectively. For U i and K i+1 , for i ≥ 0, the optimized implementation speeds up the process by using, as input, the previously computed transitive closure of K i , while the naive implementation comes with the overhead of recomputing previously inferred literals. Intuitively, this test allows the subsequent computation of transitive closure that becomes larger after each "inference step".We used four chain-structured datasets for increasing number of joins in the initially formed chain ( n/k − 1) with n = 125M, and k = 41.7M, 25M, 13.9M and 7.36M, and four chainstructured datasets for a constant number of joins in the initially formed chain ( n/k − 1) with n = 62.5M, 125M, 250M and 500M, and k = 12.5M, 25M, 50M and 100M respectively.Results. We can identify four main factors that affect the performance of our approach: (a) number of facts, affecting the input size, (b) number of rules, affecting the output size, (c) data distribution, affecting the number of required MapReduce jobs, and (d) rule set structure, affecting the number of required MapReduce jobs. Figure 1 presents the runtimes of our system for the win-not-win test over cyclic datasets with input sizes up to 1 billion facts. In this case, our system scales linearly with respect to both dataset size and number of nodes. This is attributed to the fact that the runtime per MapReduce job scales linearly for increasing data sizes, while the number of jobs remains constant. Figure 2 shows the runtimes of our system for the win-not-win test over tree-structured datasets with input sizes up to 1 billion facts. Our approach scales linearly for increasing data sizes and number of nodes. Figure 3 depicts the scaling properties of our system for the transitive closure with negation test over chain-structured datasets, when run on 7 nodes. Practically, transitive closure depends on the number of joins in the initially formed chain, which are equal to n/k − 1, namely 2, 4, 8 and 16, and thus, appropriate for scalability evaluation. The length of the chain affects both the size of the transitive closure and the number of "inference steps", leading to polynomial complexity. Note that our results are in line with Theorem 2.1. Finally, the speedup of the optimized over the naive implementation is higher for longer chains, since the naive implementation has to recompute larger transitive closures. Figure 4 illustrates the scalability properties of our system for the transitive closure with negation test over chain-structured datasets for constant number of joins in the initially formed chain, when run on 7 nodes. Our approach scales linearly, both for naive and optimized implementation as the number of jobs remains constant, while the runtime per job scales linearly for increasing number of facts.  

Conclusion and Future Work
In this paper, we studied the feasibility of computing the well-founded semantics, while allowing recursion through negation, over large amounts of data. In particular, we proposed a parallel approach based on the MapReduce framework, ran experiments for various rule sets and data sizes, and showed the performance speedup coming from the optimized implementation when compared to a naive implementation. Our experimental results indicate that this method can be applied to billions of facts.In future work, we plan to study more complex knowledge representation methods including Answer-Set programming  #b8 ), and RDF/S ontology evolution  #b10 ) and repair  #b19 ). We believe that these complex forms of reasoning do not fall under the category of "embarrassingly parallel" problems for which MapReduce is designed, and thus, a more complex computational model is required. Parallelization techniques such as OpenMP 2 and Message Passing Interface (MPI) may provide higher degree of flexibility than the MapReduce framework, giving the opportunity to overcome arising limitations. In fact, in Answer-Set programming, the system claspar  #b6 ) uses MPI, but it needs a preliminary grounding step, as it accepts only ground or propositional programs.  #b18 ) uses POSIX threads on shared memory for parallelized grounding. Combining these two approaches and making them more data-driven would be an interesting challenge. possible in order to minimize overhead, the description of the algorithm was deferred to this appendix. Duplicate elimination can be performed as described in Algorithm 5. Practically, the Map function emits every inferred literal as the key, with an empty value. The MapReduce framework performs grouping/sorting resulting in one group (of duplicates) for each unique literal. Each group of duplicates consists of the unique literal as the key and a set of empty values (with values being eventually ignored). The actual duplicate elimination takes place during the reduce phase since for each group of duplicates, we emit the (unique) inferred literal once, using the key, while ignoring the values. Finally, the calculation of the final goal as described in Section 3.2 follows Algorithm 6. emit("abc(key.X,key.Z,ab.Y)",""); 16: end for

Footnote
1 : http://hadoop.apache.org/mapreduce/
2 : http://openmp.org/wp/