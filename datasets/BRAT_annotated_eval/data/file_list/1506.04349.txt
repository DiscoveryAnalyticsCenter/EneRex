Rare Speed-up in Automatic Theorem Proving Reveals Tradeoff Between Computational Time and Information Value

Abstract
We show that strategies implemented in automatic theorem proving involve an interesting tradeoff between execution speed, proving speedup/computational time and usefulness of information. We advance formal definitions for these concepts by way of a notion of normality related to an expected (optimal) theoretical speedup when adding useful information (other theorems as axioms), as compared with actual strategies that can be effectively and efficiently implemented. We propose the existence of an ineluctable tradeoff between this normality and computational time complexity. The argument quantifies the usefulness of information in terms of (positive) speed-up. The results disclose a kind of no-free-lunch scenario and a tradeoff of a fundamental nature. The main theorem in this paper together with the numerical experiment-undertaken using two different automatic theorem provers (AProS and Prover9) on random theorems of propositional logic-provide strong theoretical and empirical arguments for the fact that finding new useful information for solving a specific problem (theorem) is, in general, as hard as the problem (theorem) itself.

Introduction
Speed-up in automatic theorem proving should not be regarded just as a quest for faster provers. To prove a theorem is an essentially difficult task and a very sensible question is whether there can be a shortcut to it by adding additional information. So the issue is what information can be added so that a proof is significantly shorter. Viewed from a very abstract point of view, of course, there is an easy (and trivial) answer: add the theorem itself and the proof becomes minimal! But adding all provable theorems to an axiomatic system renders it pointless.On the other hand, a system under memory constraints that are not minimal (i.e. that can store a set of useful theorems apart from the axioms of a theory) but at the same time bounded by a realistic measure, would be theoretically optimal if it stores only the most useful theorems for a certain task (that is, those that can make a proof shorter). A naive strategy would be to prove theorems incrementally and save them (until the memory is full). When a new theorem has to be proved the system can resort to previous theorems to see if a shorter proof can be obtained other than trying to prove the theorem from scratch. But how useful can this approach be? As we will show, it is not only naive and so expectedly not very useful, but it is also very rarely fruitful and in equal measure a waste of resources.For this, we use a very basic but objective measure of speed-up, namely shortening the length of proofs. We sample random propositional calculus theorems and with the help of two automatic theorem provers (AProS and Prover9) we produced alternative proofs for them including as additional axioms other (random) valid formulas. Afterwards, we compare the length of the proofs to establish if a shorter one arose from the use of the new axioms. In order to select our samples, we restrict our analysis to a fragment of propositional logic, given by an upper bound on the number of atomic propositions and of logical connectives.To find a proof for a theorem β from a finite set of formulas t using an automatic theorem prover, one can always start from t and apply all transformation rules until β is generated, then pick out the sequence on the path from t to β as proof. In practice, however, important optimization strategies have to be implemented to avoid exponential execution time even for the simplest of proofs. We will explore how implementing these algorithmic strategies leads to a compromise between various seminal complexity currencies, shedding light on a possibly more general challenge in problem solving, related to the usefulness of information and computational time.Definition 1. Let s be a finite set of formulas and let s β stand for the fact that β is provable from s. D(s β) will denote the length of the minimum proof for s β, as given by the number of logical deduction steps used in the proof (for example, the number of lines in a Fitch diagram).Let t and t be two representations of the class of equivalent theories [t] = [t ] (that is, t and t are finite sets of axioms with an identical set of logical consequences, or theories) such that |t| < |t |. We define the speed-up delta for t β between t and t , or simply speed-up, as the function:δ β (t, t ) = 1 − D(t β) D(t β) .Let P = {φ i } be a finite subset of the set of all valid formulas in propositional logic and let β ∈ P and t ⊆ P . Now A will be the set of all logical consequences (theorems) of t in P . Finally, the set S is the subset of A such that for a given subset A of P , with β / ∈ A, we have the following property:δ β (t, t ∪ A) > 0.Note that this property is equivalent to D(t β) > D(t ∪ A β) We ask after the relation and distribution between the size of the set S with respect to the size of a finite subset of A as a function of the set A. In other words, given a random axiomatic system, if we strengthen it by adding a number of theorems as axioms, what does the distribution of non-trivial speed-ups look like? A set of valid propositional calculus sentences and axiomatic systems is constructed given three variables: n represents the maximum depth of composition of logical operators, m states the maximum number of different literals that can be present in a sentence, and j determines the number of axioms in an axiomatic system.We will report not only that instances of non-trivial positive speed-up are relatively rare, but that their number is considerably smaller than the number of instances of negative speedup. In other words, strengthening a random axiomatic system by adding theorems as axioms tends to increase the length of proofs found by automatic theorem provers. We believe that the behavior observed verifies the stated condition and that its oblique distribution is strongly related to the computational difficulty of finding a proof of minimum size and deciding the usefulness of information as a whole.

Methodology
Prover9 is an automated theorem prover for First-order and equational logic developed by William McCune  #b16  at the Argonne National Laboratory. Prover9 is the successor of the Otter theorem prover. Prover9 is free and open source. AProS (Automated Proof Search) is a theorem prover that aims to find normal natural deduction proofs of theorems in propositional and predicate logic  #b17 . It does so efficiently for minimal, intuitionistic and classical versions of first-order logic.We undertake an empirical exploration of the speed-up in propositional logic, using AProS and Prover9 in order to approximate the proof complexity over randomly generated sets of axiomatic systems and propositions. We later propose a necessary but possibly insufficient property (in definition 7) for judging the adequacy of the approximations so obtained.To perform the exploration described, we have first to narrow the search space: We denote the set of all propositions bounded by n and m by P (n, m), the set of all theories in P by T (T = 2 P ), while T(n, m) and A(n, m) denote the sets of all theories and arguments bounded by n and m respectively. Finally, we define the sets:T(n, m, j) = {t : t ∈ T(n, m) and |t| = j} and A(m, n, j) = {t β l : t ∈ T(n, m, j) and β l ∈ P (n, m)}.The sets P (n, m) are generated recursively as follows:P (n, m) = S ∪ {op(a, b) : op ∈ { ⇐⇒ , =⇒ , ∧, ∨} and a, b ∈ S} ,(2)where S = P (n − 1, m) ∪ N eg(P (n − 1, m), N eg(X) = {∼ a|a ∈ X} and P (0, m) is the set that consists of the first m variables of P .Note that, given an order to the set of Boolean operators, we can define an enumeration of all the members of P based on its generation order, an order which is consistent among all the P (n, m) subsets for a given m. The order defined is equivalent to giving each P (n, m) set an array structure on which the first position correspond to the first element of P (n, m) and f (n, m) to the last, where f is defined asf (n, m) = |P (n, m)|.We call this array the propositions array. Given this order, we can represent each theory comprising T(n, m) by a binary string of size f (n, m) on which the ith bit is 1 iff φ i is in the theory. Following the previous idea, we can efficiently represent the members of T(n, m, j) by an array of j integers, where each integer denotes the number of 0s present between each 1. Hence we can represent the theories t ∈ T(n, m, j) by integer arrays of the form K = [k 1 , ..., k j ]. We call this the j-representation of the theory and denote it by t K .Definition 3. If φ ∈ P (n, m) and φ ∈ P (n − 1, m), then n is known as the syntactic complexity of φ or depth of φ; it is denoted by s(φ). Now let's consider the following function:gs(t K ) = j i=1 k i .The function gs gives us the degree of separation between the first element in the array of propositions ([0,...,0]) and t K . Moreover, there is an exponential number of theories that share a value for the function. We call such a set, defined by [g] = {t|gs(t) = g}, a separation class and g the separation order of all the theories in the class. Recall that the position of each proposition depends on its order of generation. Hence the syntactic complexity of each theory is set by its order of separation.Definition 4. We define the syntactic complexity of a theory t, denoted as s(t), ass(t) = max{s(φ) : φ ∈ t}, where s(φ) is the syntactic complexity of φ. Note that t ∈ [s(t)].The size of the systems we are exploring grows by ∼ 2 (16m) 2 n 16, making an exhaustive exploration intractable. The methodology used therefore consists in sampling the space of valid propositional sentences. The propositions are then used as theorem candidates against subsets of the formulae used as theories.In order to compute each sample set we build two sets: a sample set of theories denoted by T , composed of x number of theories in T(n, m, j), and the sample set of prospective theorems denoted by O, composed of |O| numbers of propositions in P (n, m). Each set is randomly generated by, first, choosing a random list of numbers of the respective lengths between 1 and f (n, m). For the list O, each of these numbers represents the prospective theorems sampled (for each theory). For the list T , the numbers represent a separation class from which we choose a theory by assigning random numbers to each of the parameters of its j representation, with the condition that their sum is the value of the chosen class. The chosen lists are then rid of inconsistent theories for T and inconsistent propositions with respect to the first element for the list O.Afterwards, we use the lists obtained to compute a sample set of A(n, m, j). First, for each t ∈ T we generate an additional number of theories of the form It is important to note that we are generating a significant number of trivial cases when j = j. Hence we expect at least close to ∼ |O| × |T | instances of positive speed-up, depending on the number of unprovable cases.t ∪ O j , where O j is a prefix of the list O; we call t = t ∪ O 0 = t ∪ ∅Finally, we run an automatic theorem prover (ATP) and register the length of each of the proofs obtained, storing the shortest ones. However, we have no reason to believe that the use of an ATP system would give us a good approximation to the sparsity of proving speed-up. Therefore we define a speed-up function relative to each ATP: Definition 5. Let A be an ATP system, t β a provable argument for A, t and t two descriptions of [t] such that |t| < |t |. We define the speed-up delta relative to A of t β between t and t , or simply relative speed-up, as the function:δ A(β) (t, t ) = 1 − D A(β) (t β) D A(β) (t β) .where D A(β) (t β) is the shortest proof found by A for the argument t β.Definition 6. Let L be a formal system, A be an ATP system for L, t β a provable argument for A, and t a description for [t] such that t ⊂ t . We call the function t : N → R a bound for A as a function of t ifδ A(β) (t, t ) ≥ 0 + t (|t |).Now, since we do not have enough information about the existent sparsity of proving speed-up, we will define a necessary but possibly insufficient condition needed for an acceptable approximation: Definition 7. We say that an argument t β is trivial if β ∈ t. An ATP system is possibly normal for L if, for each t, t (x) = 0, and if t β is a non-trivial argument, then δ A(β) (t, t ∪ {β}) > 0.(In lemma 8 we will show that normality is possible, although our example is far from ideal.)The mathematical structure used to store and analyze the results obtained is called the speed-up matrix. On this matrix each entry has assigned the valueδ i,j = δ o j (t(i, j), t i ) where t(i, j) = t i if t i is a base theory. t : D(t o j ) = min D(t o j ) {t k , .., t i−1 } otherwise.If t i o j is not a provable case, then the value of the entry is left undefined.A natural simplification of this matrix is the incidence speed-up matrix, on which we simply assign different discrete values to one of the following four cases: δ i,j > 0, δ i,j = 0, δ i,j < 0 and δ i,j is undefined.Note that by design we expect a prevalence in both matrices of diagonal structures composed of cases of positive speed-up with a period of |O|. These structures correspond to the cases of trivial speed up included.

Results
To begin with, we performed more than 15 experiments using Prover9.  As the table shows, Prover9 does not exhibit normal behavior as defined in 7. Furthermore, as exemplified in Fig. 3, the speed-up matrix does not present the expected periodic diagonal speed-up instances. The four experiments yield similar behavior: although AProS does show periodic diagonal structures it also exhibits a significant presence of negative speed-up instances, which makes the ATP otherwise than normal.It is important to note that a degree of clustering of negative speed-up instances is expected, since each delta is computed from the minimum proof length found for each previously derived theory and current objective. It is arguable whether or not we are overcounting negative speed-up instances.Each speed-up matrix is divided into four parts for visualization purposes. Each of the entries' values is represented using a four-color scale, where the color white corresponds to no speed-up, blue to positive speed up and red to negative speed-up. The columns correspond to each theory generated and the rows to each of the theorems. Grey corresponds to unprovable cases or cases where a time limit was reached.   

AProS speed-up incidence matrix with classical deduction and all four logical connectives


AProS speed-up incidence matrix with classical deduction and without disjunction
Provable Cases: 6680.Positive δ: 899, percentage: 13.46 %. Negative δ: 484, percentage: 7.246%. Figure 5: A visual representation of the incidence speed-up matrix compiled for the experiment 3.3 (classical deduction without disjunction) divided into four parts for visualization purposes. It is important to note that the set of arguments employed for the previous experiments is incompatible with the parameters established for this case. Hence a new random set had to be generated. From the image we can see that the speed-up distribution does not differ notably from previous experiments, aside from the significantly lower incidence of undemonstrable arguments.

AProS speed-up incidence matrix with intuitionistic deduction and without disjunction
Provable Cases: 6660. Positive δ: 862, percentage: 12.94%. Negative δ: 587, percentage: 8.81%. Figure 6: A visual representation of the incidence speed-up matrix generated for experiment 3.4 (intuitionistic deduction without disjunction) obtained from the same set of arguments used to compile the figure 5. We can see that the behavior is very similar to that observed in experiment 3.3, along with the significant presence of negative speed-up. We detected a negligible decrease in the number of positive speed-up instances and a small increase in negative speed-up cases.

Prover9 incidence speed-up matrix without disjunction:
Provable Cases: 6680.Positive δ: 312, percentage: 4.67%.Negative δ: 0, percentage: 0%. Figure 7: A color scale representation of the incidence speed-up matrix obtained for experiment 3.1 (classical deduction with all four logical connectives) using Prover9. The image is divided into four parts for visualization purposes. As with figure 3 the absence of the predicted diagonal structures is conspicuous, but of greater importance is the total absence of instances of negative speed-up.

Observations and Conclusions
The main objective of this project was to undertake an empirical exploration of the prevalence and distribution of instances of positive speed-up found within the propositional calculus. In particular, two deduction systems for propositional logic were explored: natural deduction and binary resolution, each of which was approximated by two automated proving systems, AProS and Prover9. A necessary (but not sufficient) condition was proposed in order to decide the adequacy of these approximations (Def. 7).Given the speed-up matrices obtained, it is evident that neither AProS nor Prover9 conforms to the normality condition defined :Prover9 cannot detect trivial cases with regularity; instead of the expected periodic diagonal patterns induced by the presence of instances of trivial speed-up, we find a number of vertical clusters of speed-up instances without a discernible regular distribution. This behavior is incompatible with the second condition of normality. We also found a non-negligible number of negative speed-up instances when a disjunction is included in the list of logical connectives. The presence of the disjunction seems to have little effect on the distribution of instances of positive speed-up.AProS shows an important number of instances of negative speed-up (slow-down). While AProS does not have problems detecting cases of trivial speed-up, the number of instances of negative speed-up is greater than in Prover9. Furthermore, the presence and distribution of these instances is not significantly affected by the presence or absence of the disjunction, nor by the alternation between intuitionistic and classical deduction.We consider the observed behaviors as evidence of the computational complexity that the proposed condition of normality entails: discerning the usefulness of new information is intrinsically computationally complex. We formalize this in the following statements: Lemma 8. There is a normal prover.Proof. Given the argument t β, a brute force algorithm that, starting from the list t, simply searches for β while building the (infinite) tree of all possible logical derivations in a breadth-first search fashion, will always find the proof of minimal length in the form of the selected branch.The expected computational time of this algorithm is of the order O(q(D(t β)) D(t β) ), where q is a polynomial that depends on the number and structure of the derivation rules used.Theorem 9. Given a non-trivial argument t β and a non-empty set t ⊂ P such thatt ⊂ t , deciding if δ β (t, t ) > 0 is N P -Hard.Proof. Given the results found in  #b10  we can say that, if P = N P , there is no polynomial time algorithm that can find D(∅ β) (if it is polynomial with respect to |β|). However, if we can decide δ β (t, t ∪ A) > 0 in polynomial time then we can find D(∅ β) in polynomial time:The algorithm we propose iterates the answer to δ β (∅, {φ}) > 0 on each possible φ derivation from the list of chosen formulas D (D starts with the list of axioms). The number of derived formulas is polynomial with respect to |D|. Each of the positive instances is added to a list l. The formula in l that minimizes the proof length can be found in log(|l|)O(|l|) by pairwise comparison using the result of δ β ({φ i }, {φ i , φ j }) > 0 and δ β ({φ j }, {φ i , φ j }) > 0 for each φ i , φ j ∈ l. Note that if both values are TRUE, then both formulas must be part of the smallest proof that contains any of the propositions, so we can choose to add just one formula and the other one will eventually be added on to the following iterations if it is part of the smallest demonstration. We add the selected expression to the list D.Following the stated procedure, we will eventually reach a trivial argument, finishing the demonstration of the tautology in the form of list D (the list contains a succession of formulas derived in order from t). Note that we consult a polynomial time algorithm a polynomial number of times over the size of a list that grows up to a polynomial size with respect to the input. Hence the algorithm finds the smallest proof in polynomial time.Given the demonstrated difficulty of the problem, we make the following conjecture:Conjecture 10. There is no normal proving algorithm significantly faster than the brute force algorithm described in 8.In other words, we are proposing the existence of an ineluctable tradeoff between normality and execution time of an automated proving algorithm. The conjecture 10 also implies that, for AProS and Prover9, the function t is of exponential order for each t.Finally, in the context of an argument t β, we can say that a set A contains useful information if it induces (positive) speed-up 1 and that the information is useless otherwise. With the experiment and the theorem 9 we have presented empirical and theoretical arguments as to why discerning the usefulness of new information for solving a specific problem is as hard as the problem itself.As for the differences found in the speed-up matrices for Prover9 and AProS, we believe that these emerge mostly due to an initial syntactic analysis performed by AProS that allows it to detect trivial cases; the exception being when removing disjunction which results in no slow-down instances, although this change doesn't seem to affect the positive speed-up distribution in a significant way. The conjecture 10 suggests that, for AProS and Prover9, the function t is of exponential order for almost all t's, and that both are within a linear constant between them, else we should be able to find a shortcut to normality.Whenever the result presented in figure 7 is a counterexample to this statement and the conjecture 10 is an open question. We could argue that simplifying the formulas by removing number of logical connectives is doing the prover's job. And, if we do restrict our space to simpler (yet complete) set of formulas, a stronger normality condition should be able to be defined as:Definition 11. A system is normal for L if there exist a polynomial time algorithm that calls ATP as an oracle for deciding δ β (t, t ) > 0, with t, t and β as in theorem 9.

Footnote
1 : This means that δ β (t, t ∪ A) > 0)