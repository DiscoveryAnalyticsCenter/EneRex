Adaptive Neighborhood Resizing for Stochastic Reachability in Multi-Agent Systems

Abstract
We present DAMPC, a distributed, adaptive-horizon and adaptive-neighborhood algorithm for solving the stochastic reachability problem in multi-agent systems, in particular flocking modeled as a Markov decision process. At each time step, every agent calls a centralized, adaptive-horizon model-predictive control (AMPC) algorithm [13] to obtain an optimal solution for its local neighborhood. Second, the agents derive the flock-wide optimal solution through a sequence of consensus rounds. Third, the neighborhood is adaptively resized using a flock-wide, cost-based Lyapunov function V . This way DAMPC improves efficiency without compromising convergence. We evaluate DAMPC's performance using statistical model checking. Our results demonstrate that, compared to AMPC, DAMPC achieves considerable speed-up (two-fold in some cases) with only a slightly lower rate of convergence. The smaller average neighborhood size and lookahead horizon demonstrate the benefits of the DAMPC approach for stochastic reachability problems involving any controllable multi-agent system that possesses a cost function.

Introduction
V-formation in a flock of birds is a quintessential example of emergent behavior in a stochastic multi-agent system. V-formation brings numerous benefits to the flock. It is primarily known for being energy-efficient due to the upwash benefit a bird in the flock enjoys from its frontal neighbor. In addition, it offers each bird a clear frontal view, unobstructed by any flockmate. Moreover, its collective spatial flock mass can be intimidating to potential predators. It is therefore not surprising that interest in V-formation is on the rise in the aircraft industry  #b4 .Recent work on V-formation has shown that the problem can be viewed as one of optimal control, model-predictive control (MPC) in particular. In  #b12 , we introduced adaptive-horizon MPC (AMPC), a highly effective control algorithm for multi-agent cyber-physical systems (CPS) modeled as a Markov decision process (MDP). Traditional MPC uses a fixed prediction horizon, i.e. number of steps to compute ahead, to determine the optimal, cost-minimizing control action. The downside of the fixed look-ahead is that the algorithm may get stuck in a local minimum. For a controllable MDP, AMPC chooses its prediction Black solid line is neighborhood resizing for the next step given the current cost. Right:Step-by-step evolution of the flock of seven birds bringing two separate formations together. Each color-slice is a configuration of the birds at a particular time step.horizon dynamically, extending it out into the future until the cost function (shown in blue in Fig. 1) decreases sufficiently. This implicitly endows AMPC with a Lyapunov function (shown in red in Fig. 1), providing statistical guarantees of convergence to a goal state such as V-formation, even in the presence of adversarial agents. It should be noted that AMPC works in a centralized manner, with global knowledge of the state of the flock at its disposal. This paper introduces DAMPC, a distributed version of AMPC that extends it along several dimensions. First, at every time step, DAMPC runs a distributed consensus algorithm to determine the optimal action (acceleration) for every agent in the flock. In particular, each agent i starts by computing the optimal actions for its local subflock. The subflocks then communicate in a sequence of consensus rounds to determine the optimal actions for the entire flock. Secondly, DAMPC features adaptive neighborhood resizing (black line in Fig. 1) in an effort to further improve the algorithm's efficiency. In a similar way as for the prediction horizon in AMPC, neighborhood resizing utilizes the implicit Lyapunov function to guarantee eventual convergence to a minimum neighborhood size. DAMPC thus treats the neighborhood size as another controllable variable that can be dynamically adjusted for efficiency purposes. This leads to reduced communication and computation compared to the centralized solution, without sacrificing statistical guarantees of convergence like those offered by its centralized counterpart AMPC.The proof of statistical global convergence is intricate. For example, consider the scenario shown in Fig. 1. DAMPC is decreasing the neighborhood size k for all agents, as the system-wide cost function J follows a decreasing trajectory. Suddenly and without warning, the flock begins to split into two, undoubtedly owing to an unsuitably low value of k, leading to an abrupt upward turn in J. DAMPC reacts accordingly and promptly, increasing its prediction horizon first and then k, until system stability is restored. The ability for DAMPC to do this is guaranteed, for in the worst case k will be increased to B, the total number of birds in the flock. It can then again attempt to monotonically decrease k, but this time starting from a lower value of J, until V-formation is reached.A smoother convergence scenario is shown in Fig. 3. In this case, the efficiency gains of adaptive neighborhood resizing are more evident, as the cost function J follows an almost purely monotonically decreasing trajectory. A formal proof of global convergence of DAMPC with high probability is given in the body of the paper, and represents one of the paper's main results.Apart from the novel adaptive-horizon adaptive-neighborhood distributed algorithm to synthesize a controller, and its verification using statistical model checking, we believe the work here is significant in a deeper way. The problem of synthesizing a sequence of control actions to drive a system to a desired state can be also viewed as a falsification problem, where one tries to find values for (adversarial) inputs that steer the system to a bad state.These problems can be cast as constraint satisfaction problems, or as optimization problems. As in case of V-formation, one has to deal with non-convexity, and popular techniques, such as convex optimization, will not work. Our approach can be seen as a tool for solving such highly nonlinear optimization problems that encode systems with notions of time steps and spatially distributed agents. Our work demonstrates that a solution can be found efficiently by adaptively varying the time horizon and the spatial neighborhood. A main benefit of the adaptive scheme, apart from efficiency, is that it gives a path towards completeness. By allowing adaptation to consider longer time horizons, and larger neighborhoods (possibly the entire flock), one can provide convergence guarantees that would be otherwise impossible (say, in a fixed-horizon MPC).The rest of the paper is organized as follows. Section 2 discusses related work. Section 3 describes the flocking model and the cost function. Section 4 defines the stochastic reachability problem. Section 5 introduces DAMPC, our main contribution. Section 6 provides proofs of our theoretical results. Section 7 presents our statistical evaluation of the algorithm. Section 8 offers concluding remarks and indicates directions for future research.

Related Work
In  #b7 , the ARES algorithm generates plans incrementally, segment by segment, using adaptive horizons (AH) to find the next best step towards the global optimum. In particular, ARES calls a collection of particle swarm optimizers (PSO), each with its own AH. PSOs with the best results are cloned, while the others are restarted from the current level on the way to the goal (similar to importance splitting  #b5 ). When the V-formation is achieved, the complete plan is composed of the best segments. The AHs are chosen such that the best PSOs can succeed to decrease the objective cost by at least a pre-defined value, implicitly defining a Lyapunov function that guarantees global convergence.The presence of an adversary able to disturb the state of the system at every time step (e.g., remove a bird) is investigated in  #b12 . In this case, planning is not sufficient. Instead, a controller (AMPC) finding the best accelerations at every step has to be designed. This calls only one PSO with a given horizon and uses the first flock-wide accelerations (from the sequence returned by PSO) as the next actions. Under the assumption that the flock is controllable, even if the returned accelerations are not the optimal (in terms of the entire run), AMPC can correct for this in the future. AH is again picked based on the distance of the system to the goal states. This results in a global AMPC that, unlike classical MPC (which uses a fixed horizon), is guaranteed to converge.In  #b15 , the problem of taking an arbitrary initial configuration of n agents to a final configuration, where every pair of stationary "neighbors" is a fixed distance d apart, is considered. They present centralized and distributed algorithms for this problem, both of which use MPC to determine the next action. The problem in  #b15  is related to our work. However, we consider nonconvex and nonlinear cost functions, which require overcoming local minima to ensure convergence. In contrast,  #b15  deals with convex functions, which do not suffer from problems introduced by the presence of multiple local minima. Furthermore, in the distributed control procedure of  #b15 , each agent publishes the control value it locally computed, which is then used by other agents to calculate their own. A quadratic number of such steps is performed before each agent fixes its control input for the next time step. In our work, we limit this number to linear.Other related work, including  #b1  #b2  #b14 , focuses on distributed controllers for flight formation that operate in an environment where the multi-agent system is already in the desired formation and the distributed controller's objective is to maintain formation in the presence of disturbances. A distinguishing feature of these approaches is the particular formation they are seeking to maintain, including a half-vee  #b2 , a ring and a torus  #b1 , and a leader-follower formation  #b14 . These works are specialized for capturing the dynamics of moving-wing aircraft. In contrast, we use DAMPC with dynamic neighborhood resizing to bring a flock from a random initial configuration to a stable V-formation.Although DAMPC uses global consensus, our main focus is on adaptive neighborhood resizing and global convergence, and not on fault tolerance  #b0  #b11 .

Background on V-Formation
Dynamical model. In the flocking model used, the state of each bird is given by four variables: a 2-dimensional vector x denoting the position of the bird in 2D continuous space, and a 2-dimensional vector v denoting the velocity of the bird. We uses = {x i , v i } B i=1to denote a state of a flock with B birds. The control actions of each bird are 2-dimensional accelerations a.Letx i (t), v i (t), and a i (t) denote the position, velocity, and acceleration, of i-th bird at time t, i ∈ {1, . . . , B}, respectively. Given an initial configurationx i (0) = x 0 i , v i (0) = v 0i inside a bounding box of a given size, the discrete-time behavior of bird i is given by Eq. 1:v i (t + 1) = v i (t) + a i (t), x i (t + 1) = x i (t) + v i (t).(1)In the simulations described in Section 7, the time interval between two successive updates of the positions and velocities of all birds in the flock equals one. The initial state is generated uniformly at random inside a bounding box. The accelerations are the output of the particle swarm optimization (PSO) algorithm  #b6 , which samples particles uniformly at random subject to the following constraints on the maximum velocities and accelerations:∀ i ∈ {1, . . . , B} ||v i (t)|| v max , ||a i (t)|| ρ||v i (t)||, where v max is a constant and ρ ∈ (0, 1).Thus, a introduces uncertainty in our model. We chose this model for its simplicity, as the cost function described in Section 3, is nonlinear, nonconvex, nondifferentiable, and therefore sufficient enough to make reachability analysis extremely challenging. We propose an approximate algorithm to tackle reachability. In principle, more sophisticated models of flocking dynamics can be considered, but we leave those for future work, and focus on the simplest one.The problem of bringing a flock from an arbitrary configuration to a Vformation can be posed as a reachability question, where the goal is the set of states representing a V-formation. A key assumption is that the reachability goal can be specified as J(s) ϕ, where J is a cost function that assigns a nonnegative real value to each state s, and ϕ is a small positive constant.Cost Function. In order to define the cost function, we recall the definitions of the metrics determining the cost of a state from  #b13  (see Appendix for details). while downwash is in the center of a bird. An upwash measure is defined on the 2D space using a Gaussian-like model that peaks at the appropriate upwash and downwash regions. UB (s) for flock state s is the sum of UB i for 1 i B. The upwash benefit UB (s) in V-formation is UB * = 1, as all birds, except for the leader, have minimum upwash-benefit metric (UB i = 0), while the leader has an upwash-benefit metric of 1 (UB i = 1).Given the above metrics, the overall objective function J is defined as a sum-of-squares of VM , CV , and UB , as follows:J(s) = (CV (s) − CV * ) 2 + (VM (s) − VM * ) 2 + (UB (s) − UB * ) 2 .(2)A state s * is considered to be a V-formation if J(s * ) ϕ, for a small positive ϕ.

The Stochastic Reachability Problem
Given the stochasticity introduced by PSO, the V-formation problem can be formulated in terms of a reachability problem for a Markov Chain, induced by the composition of a Markov decision process (MDP) and a controller. The MDP M modeling a flock of B birds is defined as follows. The set of states S is S = R 4B , as each bird has a 2D position and a 2D velocity vector, and the flock contains B birds. The set of actions A is A = R 2B , as each bird takes a 2D acceleration action and there are B birds. The cost function J is defined by Eq. 2. The transition function T is defined by Eq. 1. As the acceleration vector a i (t) for bird i at time t is a random variable, the state vector (x i (t+1), v i (t+1))is also a random variable. The initial state distribution I is a uniform distribution from a region of state space where all birds have positions and velocities in a range defined by fixed lower and upper bounds.Before we can define traces, or executions, of M, we need to fix a controller, or strategy, that determines which action from A to use at any given state of the system. We focus on randomized strategies. A randomized strategy σ over M is a function of the form σ : S → PD(A), where PD(A) is the set of probability distributions over A. That is, σ takes a state s and returns an action consistent with the probability distribution σ(s). Once we fix a strategy for an MDP, we obtain a Markov chain. We refer to the underlying Markov chain induced by σ over M as M σ . We use the terms strategy and controller interchangeably.In the bird-flocking problem, a controller would be a function that determines the accelerations for all the birds given their current positions and velocities. Once we fix a controller, we can iteratively use it to (probabilistically) select a sequence of flock accelerations. The goal is to generate a sequence of actions that takes an MDP from an initial state s to a state s * with J(s * ) ϕ.Definition 2. Let M = (S, A, T, J, I) be an MDP, and let G ⊆ S be the set of goal states G = {s|J(s) ϕ} of M. Our stochastic reachability problem is to design a controller σ : S → PD(A) for M such that for a given δ probability of the underlying Markov chain M σ to reach a state in G in m steps, for a given m, starting from an initial state, is at least 1 − δ.We approach the stochastic reachability problem by designing a controller and quantifying its probability of success in reaching the goal states. In  #b7 , a stochastic reachability problem was solved by appropriately designing centralized controllers σ. In this paper, we design a distributed procedure with an adaptive horizon and adaptive neighborhood resizing and evaluate its performance.

Adaptive-Neighborhood Distributed Control
In contrast to  #b7  #b12 , we consider a distributed setting with the following assumptions about the system model.1. Each bird is equipped with the means for communication. The communication radius of each bird i changes its size adaptively. The measure of the radius is the number of birds covered and we refer to it as the bird's local neighborhood N i , including the bird itself. 2. All birds use the same algorithm to satisfy their local reachability goals, i.e.to bring the local cost J(s Ni ), i ∈ {1, . . . , B}, below the given threshold ϕ. 3. The birds move in continuous space and change accelerations synchronously at discrete time points. 4. After executing its local algorithms, each bird broadcasts the obtained solutions to its neighbors. This way every bird receives solution proposals, which differ due to the fact that each bird has its own local neighborhood. To find consensus, each bird takes as its best action the one with the minimal cost among the received proposals. The solutions for the birds in the considered neighborhood are then fixed. The consensus rounds repeat until all birds in the flock have fixed solutions. 5. Every time step the value of the cost function J(s) is obtained globally for all birds in the flock and checked for improvement. The neighborhood for each bird is then resized based on this global check. 6. The upwash modeled in Section 3 maintains connectivity of the flock along the computations, while our algorithm manages collision avoidance.The main result of this paper is a distributed adaptive-neighborhood and adaptive-horizon model-predictive control algorithm we call DAMPC. At each time step, each bird runs AMPC to determine the best acceleration for itself and its neighbors (while ignoring the birds outside its neighborhood). The birds then exchange the computed accelerations with their neighbors, and the whole flock arrives at a consensus that assigns each bird to a unique (fixed) acceleration value. Before reaching consensus, it may be the case that some of i's neighbors already have fixed solutions (accelerations) -these accelerations are not updated when i runs AMPC. A key idea of our algorithm is to adaptively resize the extent of a bird's neighborhood.

The Distributed AMPC Algorithm
DAMPC (see Alg. 1) takes as input an MDP M, a threshold ϕ defining the goal states G, the maximum horizon length h max , the maximum number of time steps m, the number of birds B, and a scaling factor β. It outputs a state s 0 in I, and a sequence of actions a m taking M from s 0 to a state in G.The initialization step (Line 1) picks an initial state s 0 from I, fixes the initial level 0 as the cost of s 0 , sets an arrays of costs to infinite values, sets the initial time, and sets the number of birds to process.The outer while loop (Lines 2-23) is active as long as M has not reached G and time has not expired. In each time step, DAMPC first sets the sequences of accelerations a(t) to "not fixed yet" (nfy), and then iterates (Lines 4-17) until all birds fix their accelerations through global consensus. This happens as follows. First, all birds determine their neighborhood (subflock ) N i and the cost   decrement ∆ i that will bring them to the next level (Lines 8-9). Second, they call LocalAMPC (see Section 5.2), which returns (Line 10): a sequence of actions a hi Ni of length h i for the subflock, which should decrease the subflock cost by ∆ i , the state s Ni of the subflock after executing the first action in a hi Ni , the state s Ni after executing the last action, and the cost J i in the last state. Third, they determine the subflock N i * with lowest cost as a winner (Line 12) 4 and fix the acceleration sequences of all birds in this subflock (Lines 13-16). After all accelerations sequences are fixed, that is Fixed(a(t)) is true, the first accelerations in this sequence are selected for the output (Line 18). The next state s is set tos, the state of the flock after executing a(t), andŝ has the state after executing last action in a(t). If we found a path that eventually decreases the cost by ∆, we reached the next level, and advance time (Lines 19-21). In that case, we optionally decrease the neighborhood, and increase it otherwise (Line 22). Fig. 2 illustrates DAMPC for two consecutive consensus rounds after neighborhood resizing. Bigger yellow circles represent birds that are running LocalAMPC. Smaller blue circles represent birds whose acceleration sequences are not completely fixed yet. Black squares mark birds with already fixed accelerations. Connecting lines are neighborhood relationship.1 s0 ← sample(I); s ← s0; 0 ← J(s); [ Ji]i∈B ← inf; t ← 1; k ← B; // Init 2 while ( t−1 > ϕ) ∧ (t < m) dob (t) ← a h i N i * [b]; // a h i b (t) isWorking with a real CPS flock requires careful consideration of energy consumption. Our algorithm accounts for this by using the smallest neighborhood necessary during next control input computations. Regarding deployment, we see the following approach. Alg. 2 can be implemented as a local controller on each drone and communication will require broadcasting positions and output of the algorithm to other drones in the neighborhood through a shared memory. In this case, according to Alg. 1, a central agent will be needed to periodically compute the global cost and resize the neighborhood. Before deployment, we plan to use OpenUAV simulator  #b10  to test DAMPC on drone formation control scenarios described in  #b8 .

The Local AMPC Algorithm
LocalAMPC is a modified version of the AMPC algorithm  #b12 , as shown in Alg. 2. Its input is an MDP M, the current state s Ni of a subflock N i , a vector of acceleration sequences a hi Ni , one sequence for each bird in the subflock, a cost decrement ∆ to be achieved, a maximum horizon h max and a scaling factor β.In a hi Ni some accelerations may not be fixed yet, that is, they have value nfy. Its output is a vector of acceleration sequences a * , one for each bird, that decreased the cost of the flock at most, the state s Ni of the subflock after executing the first action in the sequence, the state s Ni after executing all actions, and the cost J i actually achieved by the subflock in state s Ni .

Algorithm 2: LocalAMPC
Input : M = (S, A, T, J, I), sN i , a h i N i , ∆, hmax, β Output: sN i , sN i , a * , Ji 1 p ← 2 · β · hi · B; Ji ← Inf; // Initialization 2 while (J(sN i ) − Ji < ∆) ∧ (hi hmax) do 3 // Run PSO with local information sN i and partial solution a h N i 4 (sN i , sN i , a * ) ←PSO(M, sN i , a h i N i , p, hi); 5 Ji ← J( sN i ); hi ← hi + 1; p ← 2 · β · hi · B; // increase horizon 6 endLocalAMPC first initializes (Line 1) the number of particles p to be used by the particle swarm optimization algorithm (PSO), proportionally to the input horizon h i of the input accelerations a hi Ni , to the number of birds B, and the scaling factor β. It then tries to decrement the cost of the subflock by at least ∆, as long as the maximum horizon h max is not reached (Lines 2-6).For this purpose it calls PSO (Line 4) with an increasingly longer horizon, and an increasingly larger number of particles. The idea is that the flock might have to first overcome a cost bump, before it gets to a state where the cost decreases by at least ∆. PSO extends the input sequences of fixed actions to the desired horizon with new actions that are most successful in decreasing the cost of the flock, and it computes from scratch the sequence of actions, for the nfy entries. The result is returned in a * . PSO also returns the states s Ni and s Ni of the flock after applying the first and the last actions, respectively. Using this information, it computes the actual cost achieved by the flock. ϕ}. If the transition relation T is controllable with actions in A for every (local) subset of agents, then there exists a finite (maximum) horizon h max such that LocalAMPC is able to find the best actions a * Ni that decreases the cost of a neighborhood of agents in the states s Ni by at least a given ∆.Proof. In the input to LocalAMPC, the accelerations of some birds in N i may be fixed (for some horizon). As a consequence, the MDP M may not be fully controllable within this horizon. Beyond this horizon, however, PSO is allowed to freely choose the accelerations, that is, the MDP M is fully controllable again. The result now follows from convergence of AMPC (Theorem 1 from  #b12 ).

Dynamic Neighborhood Resizing
The key feature of DAMPC is that it adaptively resizes neighborhoods. This is based on the following observation: as the agents are gradually converging towards a global optimal state, they can explore smaller neighborhoods when computing actions that will improve upon the current configuration.Adaptation works on lookahead cost, which is the cost that is reachable in some future time. Line 20 of DAMPC is reached (and the level t is incremented) whenever we are able to decrease this look-ahead cost. If level t is incremented, neighborhood size k ∈ [k min , k max ] is decremented, and incremented otherwise, as follows:NeighSize(J, k) = min max k − (1 − J(s(t)) k ) , k min , k max if level t was incremented min (k + 1, k max ) otherwise.(3)In Fig. 3 we depict a simulation-trace example, demonstrating how levels and neighborhood size are adapting to the current value of the cost function.

Convergence and Stability
Since we are solving a nonlinear nonconvex optimization problem, the cost J itself may not decrease monotonically. However, the look-ahead cost -the cost of some future reachable state -monotonically decreases. These costs are stored in level variables t in Algorithm DAMPC and they define a Lyapunov function V .V (t) = t for levels t = 0, 1, 2, . . .where the levels decrease by at least a minimum ∆, that is, (4) is a valid Lyapunov function, i.e., it is positive-definite and monotonically decreases until the system reaches its goal state.V (t) − V (t + 1) > ∆. Lemma 2. V (t) : Z → R defined byProof. Note that the cost function J(s) is positive by definition, and since l t equals J(s) for some state s, V is nonnegative. Line 19 of Algorithm DAMPC guarantees that V is monotonically decreasing by at least ∆.

Lemma 3 (Global Consensus).
Given Assumptions 1-7 in Section 5, all agents in the system will fix their actions in a finite number of consensus rounds.Proof. During the first consensus round, each agent i in the system runs LocalAMPC for its own neighborhood N i of the current size k. Due to Lemma 1, ∃ h such that a solution, i.e. a set of action (acceleration) sequences of length h, will be found for all agents in the considered neighborhood N i . Consequently, at the end of the round the solutions for at least all the agents in N i * , where i * is the agent which proposed the globally best solution, will be fixed. During the next rounds the procedure recurses. Hence, the set R of all agents with nfy values is monotonically decreasing with every consensus round.Global consensus is reached by the system during communication rounds. However, to achieve the global optimization goal we prove that the consensus value converges to the desired property. Lemma 4 (Max-neighborhood convergence). If DAMPC is run with constant neighborhood size B, then it behaves identically to centralized AMPC.Proof. If DAMPC uses neighborhood B, then it behaves like the centralized AMPC, because the accelerations of all birds are fixed in the first consensus round.Theorem 1 (Global Convergence). Let M be an MDP (S, A, T, J, I) with a positive and continuous cost function J and a nonempty set of target states G ⊂ S, with G = {s | J(s) ϕ}. If there exists a finite horizon h max and a finite number of execution steps m, such that centralized AMPC is able to find a sequence of actions {a(t) : t = 1, . . . , m} that brings M from a state in I to a state in G, then DAMPC is also able to do so, with probability one.Proof. We illustrate the proof by our example of flocking. Note that the theorem is valid in the general formulation above for the fact that as global Lyapunov function approaches zero, the local dynamical thresholds will not allow neighborhood solutions to significantly diverge from reaching the state obtained as a result of repeated consensus rounds. Owing to Lemma 1, after the first consensus round, Alg. 2 finds a sequence of best accelerations of length h i * , for birds in subflock N i * , decreasing their cost by ∆ i * . In the next consensus round, birds j outside N i * have to adjust the accelerations for their subflock N j , while keeping the accelerations of the neighbors in N i * ∩ N j to the already fixed solutions. If bird j fails to decrease the cost of its subflock N j with at least ∆ j within prediction horizon h i * , then it can explore a longer horizon h j up to h max . This allows PSO to compute accelerations for the birds in N i * ∩ N j in horizon interval h j < h h i * , decreasing the cost of N j by ∆ j . Hence, the entire flock decreases its cost by ∆ (this defines Lyapunov function V in Eq. 4) ensuring convergence to a global optimum. If h max is reached before the cost of the flock was decreased by ∆, the size of the neighborhood will be increased by one, and eventually it would reach B. Consequently, using Theorem 1 in  #b12 , there exists a horizon h max that ensures global convergence. For this choice of h max and for maximum neighborhood size, the cost is guaranteed to decrease by ∆, and we are bound to proceed to the next level in DAMPC. The Lyapunov function on levels guarantees that we have no indefinite switching between "decreasing neighborhood size" and "increasing neighborhood size" phases, and we converge (see Fig. 1). Fig. 1 illustrates the proof of global convergence of our algorithm, where we overcome a local minimum by gradually adapting the neighborhood size to proceed to the next level defined by the Lyapunov function. In the plot on the right, we see 7 birds starting from an arbitrary initial state near the origin (x, y) = (0, 0), and eventually reaching V-formation at position (x, y) ≈ (300, 100). However, around x ≈ 50, the flock starts to drift away from a V-formation, but our algorithm is able to bring it back to a V-formation. Let us see how this is reflected in terms of changing cost and neighborhood sizes. In the plot on the left, we see the cost starting very high (blue lines), but mostly decreasing with time steps initially. When we see an unexpected rise in cost value at time steps in the range 11−13 (corresponding to the divergence at x ≈ 50), our algorithm adaptively increases the horizon h first, and eventually the neighborhood size, which eventually increases back to 7, to overcome the divergence from V-formation, and maintain the Lyapunov property of the red function. Note that the neighborhood size eventually decreases to three, the minimum for maintaining a V-formation.The result presented in  #b12  applied to our distributed model, together with Theorem 1, ensure the validity of the following corollary.Corollary 1 (Global Stability). Assume the set of target states G ∈ S has been reached and one of the following perturbations of the system dynamics has been applied: a) the best next action is chosen with probability zero (crash failure); b) an agent is displaced (sensor noise); c) an action of a player with opposing objective is performed. Then applying Algorithm 1 the system converges with probability one from a disturbed state to a state in G.

Experimental Results
We comprehensively evaluated DAMPC to compute statistical estimates of the success rate of reaching a V-formation from an arbitrary initial state in a finite number of steps m. We considered flocks of size B = {5, 7, 9} birds. The specific reachability problem we addressed is as follows. Given a flock MDP M with B birds and the randomized strategy σ : S → PD(A) of Alg. 1, estimate the probability of reaching a state s where the cost function J(s) ϕ, starting from an initial state in the underlying Markov chain M σ induced by σ on M.Since the exact solution to this stochastic reachability problem is intractable (infinite/continuous state and action spaces), we solve it approximately using statistical model checking (SMC). In particular, as the probability estimate of reaching a V-formation under our algorithm is relatively high, we can safely employ the additive error (ε, δ)-Monte-Carlo-approximation scheme from  #b3 . This requires L i.i.d. executions (up to a maximum time horizon), determining in Z l if execution l reaches a V-formation, and returning the mean of the random variables Z 1 , . . . , Z L . Recalling  #b3 , we compute µ Z = L l=1 Z l /L by using Bernstein's inequality to fix L∝ ln(1/δ)/ε 2 and obtain P[µ Z − ε ≤ µ Z ≤ µ Z + ε] ≥ 1 − δ, where µ Z approximates µ Z with additive error ε and probability 1 − δ. In particular, we are interested in a Bernoulli random variable Z returning 1 if the cost J(s) is less than ϕ and 0 otherwise. In this case, we can use the Chernoff-Hoeffding instantiation of the Bernstein's inequality  #b3 , and further fix the proportionality constant to N = 4 ln(2/δ)/ε. Executing the algorithm 10 3 times for each flock size gives us a confidence ratio δ = 0.05 and an additive error of ε = 10 −2 .We used the following parameters: number of birds B ∈ {5, 7, 9}, cost threshold ϕ = 10 −1 , maximum horizon h max = 3, number of particles in PSO p = 200·h·B. DAMPC is allowed to run for a maximum of m = 60 steps. The initial configurations are generated independently, uniformly at random, subject to the following constraints on the initial positions and velocities: ∀ i ∈ {1, . . . , B} x i (0) ∈ [0, 3] × [0, 3] and v i (0) ∈ [0.25, 0.75] × [0.25, 0.75]. To perform the SMC evaluation of DAMPC, and to compare it with the centralized AMPC from  #b12 , we designed the above experiments for both algorithms in C, and ran them on the 2x Intel Xeon E5-2660 Okto-Core, 2.2 GHz, 64 GB platform.Our experimental results are given in Table 1. We used three different ways of computing the average number of neighbors for successful runs. Assuming a successful run converges after m steps, we (1) compute the average over the first m steps, reported as "for good runs until convergence"; (2) extend the partial m -step run into a full m-step run and compute the average over all m steps, reported as "for good runs over m steps"; or (3) take an average across > m steps, reported as "for good runs after convergence", to illustrate global stability. We obtain a high success rate for 5 and 7 birds, which does not drop significantly for 9 birds. The average convergence duration, horizon, and neighbors, respectively, increase monotonically when we consider more birds, as one would expect. The average neighborhood size is smaller than the number of birds, indicating that we improve over AMPC  #b12  where all birds need to be considered for synthesizing the next action. We also observe that the average number of neighbors for good runs until convergence is larger than the one for bad runs, except for 5 birds. The reason is that in some bad runs the cost drops quickly to a small value resulting in a small neighborhood size, but gets stuck in a local minimum (e.g., the flock separates into two groups) due to the limitations imposed by fixing the parameters h max , p, and m. The neighborhood size remains small for the rest of the run leading to a smaller average. Finally, compared to the centralized AMPC  #b12 , DAMPC is faster (e.g., two times faster for 5 birds). Our algorithm takes fewer steps to converge. The average horizon of DAMPC is smaller. The smaller horizon and neighborhood sizes, respectively, allow PSO to speed up its computation.

Conclusions
We introduced DAMPC, a distributed adaptive-neighborhood, adaptive-horizon model-predictive control algorithm, that synthesizes actions for a controllable Markov decision process (MDP), such that the MDP eventually reaches a state with cost close to zero, provided that the MDP has such a state.The main contribution of DAMPC is that it adaptively resizes an agent's local neighborhood, while still managing to converge to a goal state with high probability. Initially, when the cost value is large, the neighborhood of an agent is the entire multi-agent system. As the cost decreases, however, the neighborhood is resized to smaller values. Eventually, when the system reaches a goal state, the neighborhood size remains around a pre-defined minimal value. This is a remarkable result showing that the local information needed to converge is strongly related to a cost-based Lyapunov function evaluated over a global system state. While our experiments were restricted to V-formation in bird flocks, our approach applies to reachability problems for any collection of entities that seek convergence from an arbitrary initial state to a desired goal state, where a notion of distance to it can be suitably defined. 

Footnote
4 : This step requires global consensus, but more generally, the loop on Lines 4-17 requires birds to have global information at multiple places. This can be quite inefficient in practice. A more practical approach, given in[10], is based on a dynamic local (among neighbors) consensus, for fixed neighborhood graphs. Since we are adapting and changing neighborhood sizes, the results are not directly applicable. Nevertheless, we can still use a similar truly distributed approach (in place of global consensus on Lines 4-17), but preferred to experiment with the easier to implement global version, since adapting neighborhoods size is the main focus of our paper, and our goal was to evaluate if neighborhood sizes really shrink, and remain small as the flock converges to a state s in G, with J(s) ϕ.