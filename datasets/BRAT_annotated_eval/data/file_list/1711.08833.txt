Deep Learning for Real-Time Crime Forecasting and Its Ternarization

Abstract
Real-time crime forecasting is important. However, accurate prediction of when and where the next crime will happen is difficult. No known physical model provides a reasonable approximation to such a complex system. Historical crime data are sparse in both space and time and the signal of interests is weak. In this work, we first present a proper representation of crime data. We then adapt the spatial temporal residual network on the well represented data to predict the distribution of crime in Los Angeles at the scale of hours in neighborhood-sized parcels. These experiments as well as comparisons with several existing approaches to prediction demonstrate the superiority of the proposed model in terms of accuracy. Finally, we present a ternarization technique to address the resource consumption issue for its deployment in real world. This work is an extension of our short conference proceeding paper [Wang et al, Arxiv 1707.03340]. Introduction Forecasting crime at hourly or even finer temporal scales in micro-geographic regions is an important scientific and practical problem. Anticipating where and when crime is most likely to occur creates novel opportunities to prevent crime. However, accurate crime forecasting at fine spatial temporal scales is very challenging. The occurrence of crime depends on complex factors, many of which cannot be described quantitatively. Statistically, crime is extremely stochastic and sparse in both space and time. 21 Recent efforts have been devoted to the mathematical and statistical modeling of crime. Short et al introduced a novel partial differential equations (PDE) model to simulate crime hotspots and analyzed the regime for different dynamical patterns. [24] [25] [26] The PDE model provides a macroscale description which can be regarded as a continuum limit of the microscopic random walk. Considering crime as self-exciting, Mohler et al adapted the epidemic type aftershock sequence (ETAS) model to crime modeling. 20, 23 The ETAS model provides a microscopic representation of the crime events with predictive power. Such point process idea have been extended to study other crime problems such as crime missing data reconstruction. 27 Another class of crime predictors uses autoregressive integrated moving average (ARIMA) or other simple statistical models. 1, 8 The aforementioned models are built only on historical data. There is also interesting work on crime prediction using social network data, e.g., Twitter. 2, 30 Deep learning has recently been used for crime modeling and forecasting. In our previous work, we considered realtime crime forecasting at fine spatial scale. 29 Kang et al studied the crime forecasting problem by transforming it into binary classification problem. 14 The key idea is to have a convolutional neural network (CNN) learn the features for crime forecasting with inputs of historical data, weather, geographical information, etc. Finally, they apply a support vector machine (SVM) to classify the region into crime or no crime with a posterior probability. This is an interesting idea, but not an optimal approach. Consider two regions. One region always has one crime happen with certainty. The other region has many crimes to happen, but only with 90 percent probability. Based on the classification approach, the first region would be flagged for patrol over the second. This model does not fully model the fine scale spatial temporal patterns in the crime data. Recent advances in deep learning techniques has made forecasting of complex spatial temporal crime patterns more tractable. 10, 11, 13, 16, 19, 32 Some of the most successful applications include citywide traffic flow forecasting, motion prediction and human object interaction modeling. Zhang et al 32 create an ensemble of residual networks 9 to study the traffic flow, their network is called ST-ResNet. The key idea is to map the traffic flow at each time slot to an image and explicit specify the dependencies. Their model gave excellent traffic flow forecasting in Beijing and New York city. Jain et al 13 proposed a jointly trainable neural network structure, called a structural recurrent neural network (SRNN), which is a feed-forward arrangement of RNN units. The SRNN gives state-of-the-art motion forecasting. Moreover, the SRNN is scalable to massive data sets. For


periodic motion forecasting, Holden et al  $b11  proposed a phased-function neural network for character control, their techniques have been successfully used in the gaming industry.Despite CNNs' superior performance in various real-world applications including crime prediction, their memory and energy consumptions can be a problem, especially when deployed on mobile devices with limited resources, due to the huge number of floating-point parameters in the models. Recent efforts have been made to develop quantization techniques  #b4  #b5  #b16  #b21  #b30  $b34  for training CNNs with low precision parameters. Thus we are able to compress the model size and speed up computation during inference. For example, in binary weight neural networks (BNNs),  #b4  #b5  $b22  the weights in the same fully-connected or convolutional layer are restricted to have the same magnitude. For a layer with n binary weights, the storage of these parameters only requires the memory for one 32-bit floating-point number and n 1-bit binary numbers (i.e., ±1) instead of that for n 32-bit weights, resulting in approximately 32× memory savings. Moreover, at inference time, the need for floating-point multiplications can be eliminated by leveraging the distributive law during forward propagation, which enables faster deployment and substantial energy savings. More precisely, in BNNs, a weight filter matrix or a 4 dimensional tensor, can be expressed asW = αB,where α > 0 is the layer-wise scaling factor and B has the same size as W but only contains entries ±1. Given input I, the forward propagation calls for evaluatingW * I = α(B * I),where * denotes the convolution operation or matrix-vector multiplication. Note that the computation of B * I involves additions and subtractions only. Unfortunately, weight binarization often leads to nonnegligible loss of prediction accuracy.  #b4  #b5  #b16  $b22  Compared to BNNs, Ternary weight neural networks (TNNs)  #b16  #b30  $b34  own an extra state 0 for the weights and thus enjoy a larger model capacity. TNNs benefit in the same way as BNNs do from quantization.Thanks to sparsity, a number of additions/subtractions can be further dropped from foward propagation. To store ternary numbers, we need 2-bit representation which results in 16× model compression rate. TNNs strike a balance between the accuracy and memory storage. Other methods for training general low-bit CNNs have also been proposed.  #b30  $b33  In this paper, we study the crime forecasting at small spatial and hourly temporal scales. We adapt the ST-ResNet structure for our purposes. Compared to the traffic flow data handled by ST-ResNet, crime data is more challenging. Crime data has much less spatial temporal regularity; i.e., the number of events in adjacent time intervals and spatial cells differ hugely. Crime data are very sparse in both space and time. Crime types are also diverse.  $b21  Our contribution is fourfold. First, we select the appropriate spatial temporal scales at which crimes are predictable. We explore the suitable representation for the spatial temporal crime distribution. Second, we provide different approaches for data regularization in both spatial and temporal dimensions to further enhance the predictable signals. Third, we adapt the deep learning architecture for crime forecasting. Fourth, we study the ternarization of our ST-ResNet model.We organize the paper as follows: In section 2, we discuss crime data sets and preprocessing techniques. In section 3, we discuss the deep learning algorithms and network structures for crime forecasting. Forecasting results and comparisons with some other methods are presented in sections 4 and 5, respectively. In section 6, we explore the ternarization of the ST-ResNet to reduce the model size and speed up forecasting. In section 7, we summarize this paper's contribution and discuss future work.

Data Representation 2.1 Data set description
We consider crime forecasting in Los Angeles (LA). In our protocol, historical crime, weather and historical holiday data are the key ingredients. Since holiday records are easy to obtain, we only provide brief descriptions of the other two data sets. Crime Data For a simple yet effective demonstration of our framework, we consider all the crimes recorded in LA over the last six months of 2015 without distinguishing their types. In total there were 104,957 crime events. The crime time and location information is used in our forecasting paradigm. Each crime is associated with two times: start and end times. To avoid ambiguity, we regard the start time of each event as the associated time slot. Geographically, the latitude and longitude intervals spanned by these crimes are [33. ], this selected region contains more than 95 percent of the total crimes. Nevertheless, there is still spatial redundancy in this data embedding. In our study, we partition this selected region into a 16 × 16 lattice. Each grid cell represents approximately 17.8km 2 land area. Fig. 1 shows the crime distribution at 1:00 p.m on Dec 20th, 2015. The left panel is the crime distribution over the whole LA area. The right panel depicts the crimes in the restricted region. All crime historical data is provided by Los Angeles Police Department (LAPD). Weather Data We collect the weather data from the Weather Underground database available at https://www.wunderground. com/ using a simple web crawler. Special attention should be paid to get extracting the data correctly as the format varies day by day. We select temperature, wind speed, and special events, including fog, rain, and thunderstorms, for our weather features. Since we study hourly crime forecasting, if more than one weather data are available, we make use of an average of the features. For the time intervals without weather data, we use a linear interpolation from neighboring intervals.

Data Preprocessing
Charts (a) and (c) of Fig. 2 show crime intensity functions in the whole LA and a randomly selected grid over the last two weeks of the year 2015. The intensity functions show low regularity in the temporal dimension. However, the hourly crime time series indicate strongly predictable signals; obviously, the time series over the whole domain is periodic with a period of 24 hours. For selected grid cells, the periodic patterns still exists, but the time series much more irregular. Deep learning uses combinations of simple linear and nonlinear continuous functions to form a dynamical system, thus approximating the complex input signal. Since deep learning models are essentially continuous, we need to enhance the regularity of the time series data, especially for the grid-wise crime intensity functions. To address this, we map the original crime intensity function {X(t)} to {Y (t)} via a diurnal periodic integral mapping:Y (t) = t nT X(s)ds,(1)for t within the time interval (nT, (n + 1)T ]. As demonstrated in charts (b) and (d) of Fig.2, after integration, the regularity of the original time series improves dramatically. The periodic signal is amplified.To resolve the lack of spatial regularity, we use a super resolution technique at each time step; e.g., bilinear and cubic spline interpolation. For computational efficiency, we resolve by a factor of 2 in each dimension of the spatial domain. In Fig. 3 we see that the bilinear spline super resolution significantly improves spatial regularity. A merit of this preprocessing is that it improves the signal without losing information associated with the crime data.

Models and Algorithms 3.1 Mathematical Problem Formulation
For the sake of simplicity, in this work we do not consider the crime type forecasting problem. In our protocol, we only consider how many crimes will happen in the next time step in each grid cell. Mathematically, our paradigm can be formulated as: given the historical data {(X t , E t )} t=1,2,···n and future external features {E n+1 }, predict X n+1 , where X 1 , X 2 , · · · , X n+1 are the tensors representing the crime spatial distributions at times t 1 , t 2 , · · · , t n+1 . E 1 , E 2 , · · · , E n+1 are the external features that affect the crimes, (e.g., holiday, time, weather). The entire procedures of our crime predictor can be formulated by the pseudo code described in Algorithm. 1. In Algorithm. 1, S and I denote spatial super-resolution and temporal diurnal integration operators, respectively.

ST-ResNet structure
We test two different deep neural network structures. The first structure is adapted from.  $b32  The second structure, which excludes convolution, is equivalent to an ensemble of residual networks to learn the time series on each grid, without considering the transition of crimes between different grids. The first model is more realistic. Through convolutional layers, crime dynamics and influences among different grids can be captured. In both networks, all features are fused with the crime data via a parametric-matrix based fusion technique used in.  $b32  The detailed description of the network structure can be found in.  $b32  We implement our method using Keras 4 on top of Theano 28 software. Our models incorporate external features such as weather and holidays. Due to the periodic pattern and self-exciting property of crimes,  $b20  we adopt nearby, periodic, and trend features. The time spacing of these features are at hourly, daily, and weekly levels, respectively. For each category of these dependencies, we employ the three nearest previous spatial distributions of crimes. For instance, suppose we wish to predict the crime distribution at t n+1 , the past crime distributions: X n , X n−1 , X n−2 , X n−24 , X n−48 , X n−72 , X 168 , X n−336 , X n−504 are utilized as features. We believe that longer dependencies produce better results. We let the algorithm learn the dependencies automatically in a RNN fashion.(a) (b) (c) (d)

Results on Crime Forecasting
We ran experiments on the last six months crime data of 2015 over LA. The last two weeks data is used to test the model. The remaining data is used for training and validating the models, where the validation ratio is 20 percent. We use 6 layers of residual units, the number selected by trial-and-error, to assemble the ST-ResNet, which is a good compromise between model complexity and accuracy. In the training period, we first run 200 epochs to train the network with a separated validation set to ensure our models do not over-fit. Subsequently, we schedule another 50 epochs on the combination of the training and validation sets to fine tune the model. All the experiments are carried out with a single Nvidia Quadro-K4000 graphics card. To speed up the training process, we make use of the deep neural network library cuDNN.  $b3  The size of the convolution filters are fixed to 3 × 3. The learning rate is chosen to be 0.0005. The ADAM optimizer is used to optimize the loss function. We use the root mean square error (RMSE) between prediction and ground truth as our measure of accuracy of the predictions. RMSE is defined as: where N is the total number of grids that we partition the restricted area into, T is the number of time slots considered, I it and I p it are the exact and predicted crime intensity in grid i at time t, respectively. When considering the accuracy of the prediction in a single grid cell, we do not need to sum over the index N . Table 1 lists the RMSEs between the predictions and the ground truth cumulative intensity functions with different setups of the network and different treatments of the input data.RMSE = 1 N * T i,t (I it − I p it ) 2 ,(2)(a) (b) (c) (d)We consider different experimental setups to validate the importance of the signal enhancement treatments. For super resolution comparisons, we consider three cases, namely super resolution in space and time, super resolution in space only, and no super resolution. Bilinear interpolation is employed for all signal enhancements. As demonstrated in Table  1, the best results come from using both spatial and temporal super resolutions. In general, these signal enhancement techniques improve model performance. To test the influence of model complexity, we considered different number of filters in the convolutional layers. We list the results for different number of neurons in Table 1 In general, performance increases with the more neurons involved. These filters capture different scales of the spatial temporal features of the training data set. Currently, the maximum number of filters (64×64) is set by the capacity of our graphics card. We believe the model can give even better results with more filters, since they can capture more detailed information about the spatial temporal distribution of crime. The optimal results obtained when we use convolutional layers on the super resolved signals on both space and time, which gives RMSE 0.207 in the prediction. The performance shows that convolutional layers captures the spatial influence of crimes, as it is known that crime is self-exciting in both space and time.  $b20  Without convolutional layers, each grid is basically treated independently, which leads to an inefficient model.In Fig. 5 we show sample snapshots in time. It is easy to see all crime hot spots are captured. The ST-ResNet gives satisfactory results in the cases with or without convolutional layers. Output: Crime spatial distribution X n+1 at time slot t n+1 .

4:
Step 1: Perform spatial super resolution on the input crime distributions to get S(X t ) for t = 1, 2, · · · n.

5:
Step 2: Perform temporal super resolution on the spatial super resolved data to get I(S(X t )) for t = 1, 2, · · · n.

6:
Step 3: Train the ST-ResNet on the concatenation of the super resolved historical crime data and external features, {(I(S(X t ))), E t } n t=1 .

7:
Step 4: Predict the spatial temporal super resolved crime distribution at time slot t n+1 by the trained ST-ResNet and external features E n+1 .

8:
Step 5: Temporal recovery: I −1 (I(S(X n+1 ))) = S(X n+1 ).

9:
Step 6: Spatial recovery: S −1 (S(X n+1 )) = X n+1 . 10: Step 7: Get the predictionX p n+1 = |X n+1 | + , if mod(n, 24) = 0 max{|X n+1 | + , X n }, if mod(n, 24) = 0where |X n+1 | + is the positive part of X n+1 , i.e., For a given grid, the crime intensity over a given time interval is also accurately predicted. We randomly select two grids with longitude and latitude ranges gives 104 slots, 69 of them lies in the ground truth set.|X n+1 | + = 0, if X n+1 < 0 X n+1 , if X n+1 ≥ 0One key feature of the convolutional neural network is weight sharing, i.e., for a given neuron, it shares the common filter over the whole image domain. This simplifies the neural network model and the training procedure. However, for extremely sparse spatial data, like the crime data we study, this weight sharing may lead to the filter with all weights being zeros. As shown in Table 1, without super resolution, the network with convolutional layers offers worst forecasting (all the predictions are zero). We conclude that, for sparse spatial data, applying convolutional network to the super resolved data can give excellent forecasting. On the one hand, it solves weight sharing problem. On the other, it captures complex spatial distributions.

Comparison between Different Methods
In this section, we compare our approach with several existing methods for crime forecasting. In total, we compare our deep learning approach to ARIMA, 1 k nearest neighbor (KNN), and historical average (HA). We brief summarize these methods in the following:• HA: in this simple empirical model, at each time slot, we regard the historical average at that specific hour as the prediction. This is a parameter free model. However, the daily crime volatility cannot be captured by this model.• KNN: in this model, we use the average number of crimes in the closest previous time steps to forecast the number of events at the next time step. The only parameter is k, which represents the number of nearest previous steps involved in the prediction. The parameter k can be determined by simple cross validation. Here we adopt five-fold cross validation to determine this parameter. It is found that when k equal to one, KNN provides the best results. Lag forecasting is the main drawback of this model.• ARIMA: the general model ARIMA(p, d, q) has three parameters, where p is the order of autoregressive model, d is the order of difference needed to make the signal to be stationary, q is the order of the moving average. The parameter d is determined by the ADF stationarity test, p and q are determined by the autocorrelation function (ACF) and partial autocorrelation function (PACF), respectively. Based on our testing, the cumulative crime intensity function itself is stationary. The optimal order for autoregression and moving average are 25 and 26, respectively. These two parameters reflect a roughly one day dependence. Due the the simplicity of training the model, we implement the ARIMA model in a rolling fashion and update the model on the fly as new data is presented. The major deficiency of this model is that it cannot included features other than the time series itself. It is also too simple to capture all the features carried by the signal. In general, ARIMA is only suitable for simple time series that carry all the predictable information.We randomly select a grid cell with the longitude and latitude range   (b) of Fig.7 is a comparison of the crime intensity functions. The crime distribution function itself is highly irregular over the time span. The regularity of the signal is enhanced by integration. The cumulative density function is periodic with some fluctuation. The deep learning model provides the optimal prediction, followed by ARIMA, KNN, and HA (Table 2). ARIMA, KNN, HA are not on par with one another. The optimal RMSEs in cumulative density and original crime signal are 0.750 and 0.659, respectively. For ARIMA and KNN, the errors in the original signal are more than the cumulative one. Visually, ARIMA and KNN seem to provide excellent predictions. However, this is a misperception due to lagged forecasting. According to our tests, ST-ResNet shows even stronger performance relative to the other predictors when the data become more sparse.

Ternarization of ST-ResNet
In this section, we consider the ternarization of ST-ResNet. Suppose there are in total l fully-connected and convolutional layers with the respective weight filters W i , i = 1, . . . , l. For a fully-connected layer, W i is a matrix, and for a convolutional layer, it is a high dimensional tensor. Without loss of generality, let us view W i as a vector of dimension n i . Then the vector W i ∈ R ni is ternary-valued and takes the formW i = α i T i ,where T i ∈ {−1, 0, 1} ni has the same size as W i , and α i > 0 is a shared scaling factor. Training TNNs calls for solving the following constrained minimization problemmin W,b f (W, b) subject to W i ∈ T i , i = 1, . . . , l,(3)where f denotes the overall energy function determined by the network architecture, W = {W 1 , . . . , W l } the weight parameters, b the other trainable parameters, andT i := {W i ∈ R ni : ∃ α i > 0 and T i ∈ {−1, 0, 1} ni such that W i = α i T i }the set of ternary weights for the i-th layer.The key step for solving Eq.(3) lies in the ternarization of some given floating-point vectorW i . To this end, we seek to minimize the Euclidean distance betweenW i and W i :proj Ti (W i ) := arg min Wi W i −W i 2 subject to W i ∈ T i .The solution proj Ti (W i ) to the above problem is simply the projection ofW i onto the set T i . For now let us ignore the subscript i for notational simplicity. In an alternative form, the above problem can be formulated as(α * , T * ) = arg min α,T αT −W 2 subject to α > 0, T ∈ {−1, 0, 1} n .(4)After obtaining (α * , T * ), the ternarization ofW is then given by proj T (W ) = α * T * . The solution to (4) was first approximated by Li et al 17 under unrealistic statistical assumptions on the components ofW , albeit with satisfactory empirical performance. The exact expression for proj T was later derived by Yin et al.  $b31  We summarize the result in the theorem below.Theorem 6.1. SupposeW [k] keeps the k largest entries in magnitude ofW and zeros out the others. Then the solution to problem (4) is given byα * = W [k * ] 1 k * , T * = sign(W [k * ] ), where k * = arg max k W [k] 2 1k is the sparsity of the optimal ternary weight vector.For readers' convenience, we provide a proof here.Proof. Suppose the sparsity of T is k. Since T ∈ {−1, 0, 1} n , thenT 2 = k and | T,W | ≤ W [k] 1 ,and thusαT −W 2 = kα 2 − 2 T,W α + W 2 = k α − T,W k 2 − T,W 2 k + W 2 ≥ − T,W 2 k + W 2 ≥ − W [k] 2 1 k + W 2 .(5)Since W 2 is a constant, the optimal sparsity k * maximizes the term k .W [k]To achieve the lower-bound in (5), we must haveT * = sign(W [k * ] ), α * = T * ,W k * = W [k * ] 1 k * .According to Theorem 6.1, the ternarization ofW can be performed in a manner of direct enumeration. This involves sorting the magnitudes of elements ofW and computing accumulative sum of the sorted sequence, which require computational complexity of O(n log(n)). Our training of ternary ST-ResNet is carried out by a projected SGD-like algorithm.  $b22  We keep updating the floating-point weights using the minibatch (sub)gradient of f evaluated at ternary weights. This is different from the standard projected SGD in which the ternary weights are updated in the descent step. The mean convergence of this pseudo projected SGD has been proved under smoothness and convexity assumptions on f .  $b18  In fact, it has demonstrated much stronger empirical performance than the standard version in training quantized neural networks.  $b18  In addition, we adopt popular techniques in deep learning such as 2 regularization, batch normalization 12 and ADAM 15 to improve training efficiency. Our method for training ternary ST-ResNet is summarized in Algorithm 2.We coded and tested the optimizer on Lasagne/Theano 7, 28 platform in Python on a machine with Nvidia GeForce GTX Titan X GPU. We trained fully-ternary ST-ResNet with spatial and temporal super-resolution preprocessing, where all the weight filters are ternary. The training RMSE and testing RMSE with 64×64 neurons are 0.234 and 0.242, respectively. As shown in Table 3, compared to the full-precision model, there is only a small accuracy loss. Input: Energy function f (W, b), the number of mini-batches d, adaptive learning rate η t , t = 1, . . . , d, parameters W 0 , b 0 andW 0 output from the last epoch. Output: floating-point weightsW d , ternary weights W d and other parameters b d . Initialization: Randomly shuffle the samples in training dataset. for t = 1, . . . , d do f (W t−1 , b t−1 ) =EvalGrad(f, W t−1 , b t−1 ) // Evaluate the (sub)gradient of f at (W t−1 , b t−1 ) using the t-th mini-batch by back propagation.W t = ADAM(W t−1 , ∇ t−1 f (W t−1 , b t−1 ), η t−1 ) // Update the floating-point weightsW using ADAM. for i = 1, . . . , l do W t i = proj Ti (W t i ) // Ternarize the weightsW i in the i-th layer by solving  #b3  .f (W t , b t−1 ) =EvalGrad(f, W t , b t−1 ) // Evaluate the (sub)gradient of f at (W t , b t−1 ) using the t-th mini-batch by back propagation. b t = ADAM(b t−1 , ∇ t−1 f (W t , b t−1 ), η t−1 ) // Update other trainable parameters b using ADAM. 

Concluding Remarks
In this paper, we present a real-time spatial temporal predictor for end-to-end crime intensity prediction. The key idea of our predictor can be summarized as follows:• We chose appropriate spatial temporal scales at which crime historical time series carry sufficient predictable signals. For a given time step, we map the number of events into an image, each pixel value represents the number of crime in a grid at a specific time.• We developed effective spatial temporal signal enhancement techniques to boost the crime forecasting accuracy. These techniques also solve the deficiency of the CNNs for sparse data dues to the weight sharing. More specifically, in the temporal dimension, we compute the diurnal cumulative crime per grid spatial region. In the spatial dimension, we use bilinear interpolation super resolution.• We adapted the ST-ResNet for crime prediction.Our methods provide crime forecasting for each grid cell at hourly temporal scale. The predictions are extremely accurate, which provides reliable guidance for crime control. Our model can be categorized as a deep learning regression method, which provides a better description of crime forecasting than the classification type of methods, since crime prediction is not just a simple yes-or-no problem.Nevertheless, there are many aspects to improve. On the one hand, the ad hoc grid partitioning of the spatial domain ignores demographic and geographic information. Furthermore, embedding the irregular geometry of the city into a rectangular domain leads to a huge amount of redundant computation. On the other hand, in the ST-ResNet framework, the historical dependencies need to be set explicitly and longer explicit dependencies cause the network to be extremely complex and difficult to train. Adaptive dependence is hard to incorporate into the ST-ResNet framework.There are a few lines of research worth exploring in the future. First, a better graphical representation of spatial temporal data representation will benefit both the capturing of information from historical data and efficient computation. Second, instead of explicitly pointing out the dependencies, an alternative is to use RNN to learn the dependencies automatically. Third, forecasting crime types is feasible in our framework, although challenging, since the data will be much more sparse compared to the present representation.