How Many Dissimilarity/Kernel Self Organizing Map Variants Do We Need?

Abstract
In numerous applicative contexts, data are too rich and too complex to be represented by numerical vectors. A general approach to extend machine learning and data mining techniques to such data is to really on a dissimilarity or on a kernel that measures how different or similar two objects are. This approach has been used to define several variants of the Self Organizing Map (SOM). This paper reviews those variants in using a common set of notations in order to outline differences and similarities between them. It discusses the advantages and drawbacks of the variants, as well as the actual relevance of the dissimilarity/kernel SOM for practical applications.

Introduction
Complex data are frequently too rich and too elaborate to be represented in a simple tabular form where each object is described via a fixed set of attributes/variables with numerical and/or nominal values. This is especially the case for relational data when objects of different categories are interconnected by relations of different types. For instance online retailers have interconnected customers and products databases, in which a customer can buy one or several copies of a product, and can also leave some score and/or review of said products.Adapting data mining and machine learning methods to complex data is possible, but time consuming and complex, both at the theoretical level (e.g., consistency of the algorithms is generally proved only in the Euclidean case) and on a practical point of view (new implementations are needed). Therefore, it is tempting to build generic methods that use only properties that are shared by all types of data.Two such generic approaches have been used successfully: the dissimilarity based approach and the kernel based approach  #b41 . Both are based on fairly generic assumptions: the analyst is given a data set on which either a dissimilarity or a kernel is defined. A dissimilarity measures how much two objects differs, while a kernel can be seen as a form a similarity measure, at least in the correlation sense. Dozens of dissimilarities and kernels have been proposed over the years, covering many types of complex data (see e.g.  #b14 ). Then one needs only to adapt a classical data mining or machine learning method to the dissimilarity/kernel setting in order to obtain a fully generic approach. As a dissimilarity can always be constructed from a kernel, dissimilarity algorithms are probably the more generic ones. A typical example is the k nearest neighbor method which is based only on dissimilarities.We review in this paper variants of the Self Organizing Map (SOM) that have been proposed following this line of research, that is SOM variants that operate on dissimilarity/kernel data. We discuss whether those variants are really usable and helpful in practice. The paper is organized as follows. Section 2 describes our general setting: dissimilarity data, kernel data and the Self Organizing Map. Section 3 is dedicated to the oldest dissimilarity variant of the SOM, the Median SOM, while Section 4 focuses on the modern variant, the relational SOM. Section 5 presents a different approach to SOM extensions based on the deterministic annealing principle. Section 6 describes kernel based variants of the SOM. An unifying view is provided in Section 7 which shows that the differences between the SOM variants are mainly explained by the optimization strategy rather than by the data properties. Finally Section 8 gathers our personal remarks and insights on the dissimilarity/kernel SOM variants.

General setting
The data set under study comprises N data points x 1 , . . . , x N from an abstract space X . We specify below the two options, namely dissimilarity data and kernel data. We also recall the classical SOM algorithms.

Dissimilarity data
In the dissimilarity data setting (a.k.a. the pairwise data setting), it is assumed that the data are described indirectly by a square N × N symmetric matrix D that contains dissimilarities between the data points. The convention is that D ij = d(x i , x j ), a non negative real number, is high when x i and x j are different and low when they are similar. Minimal assumptions on D are symmetry and non negativity of each element. It is also natural to assume some basic ordering, that is that D ii ≤ D ij for all i and j, but this is not used in SOM variants. Some theoretical results also need D ii = 0 (e.g.  #b19 ), but again this is not a very strong constraint. Notice that one can be given either the dissimilarity function d from X 2 to R + or directly the matrix D.

Kernel data
In the kernel data setting, one is given a kernel function k from X 2 to R which satisfies the following properties:1. k is symmetric: for all x and y in X , k(x, y) = k(y, x); 2. k is positive definite: for all m > 0, all observation set (x 1 , . . . , x m ) ∈ X m and all coefficient set(α 1 , . . . , α m ) ∈ R m , m i=1 m j=1 α i α j k(x i , x j ) ≥ 0.The most important aspect of the kernel setting lays in the Moore-Aronszajn theorem  #b2 . It states that a Reproducing Kernel Hilbert Space (RKHS) H can be associated to X and k through a mapping function φ from X to H such that φ(x), φ(y) H = k(x, y) for all x and y in X . The mapping φ is called the feature map. It enables one to leverage the Hilbert structure of H in order to build machine learning algorithms on X indirectly.This can be done in general without using φ but rather by relying on k only: this is known as the kernel trick (see e.g.  #b41 ).Notice that the kernel can be used to define a dissimilarity on X by transporting the Hilbert distance from H. Indeed, it is natural to define d k on X byd k (x, y) = φ(x) − φ(y), φ(x) − φ(y) H .(1)Elementary algebraic manipulations show thatd k (x, y) = k(x, x) + k(y, y) − 2k(x, y),(2)which is an example of the use of the kernel trick to avoid using explicitly φ.The construction of d k shows that the dissimilarity setting is more general than the kernel setting. It is always possible to use a kernel as the basis of a dissimilarity: all the dissimilarity variants of the SOM can used on kernel data. Therefore, we will focus mainly on dissimilarity algorithms, and then discuss how they relate to their kernel counterparts.Notice finally that as in the case of the dissimilarity setting, the kernel can be given as a function from X to R or as a kernel matrix K = (K ij ) = (k(x i , x j )). In the latter case, K is symmetric and positive definite and is associated to a dissimilarity matrix D K via equation (2).

SOM
To contrast its classical setting with the dissimilarity and kernel ones, and to introduce our notations, we briefly recall the SOM principle and algorithm  #b27 . A SOM is a low dimensional clustered representation of a data set.One needs first to specify a low dimensional prior structure, in general a regular lattice of K units/neurons positioned in R 2 , the (r k ) 1≤k≤K . The structure induces a time dependent neighborhood function h kl (t) which measures how much the prototype/model associated to unit r k should be close to the one associated to unit r l , at step t of the learning algorithm (from 0 for unrelated models to 1 for maximally related ones). We will not discuss here the numerous possible variants for this neighborhood function  #b27 : if the lattice is made of points r k in R 2 a classical choice ish kl (t) = exp − r k − r l 2 2σ 2 (t) ,where σ increases over time to reduce gradually the influences of the neighbors during learning. The SOM attaches to each unit/neuron r k in the prior structure a prototype/model in the data space m k . The objective of the SOM algorithm is to adapt the values of the models in such a way that each data point is as close as possible to its closest model in the data space (at standard goal in prototype based clustering). In addition if the closest model for the data point x is m k , then m l should also be close to x if r k and r l are close in the prior structure. In other words, proximities in the prior structure should reflect proximities in the data space and vice versa. The unit/neuron associated to the closest model of a data point is called the best matching unit (BMU) for this point. The set of points for which r k is the BMU defines a cluster in the data space, denoted C k . This is essentially achieved via two major algorithms (and dozens of variants). Let us assume that the data space is a classical normed vector space. Then both algorithms initialize the prototypes (m k ) 1≤k≤K in an "appropriate way" and proceed then iteratively. We will not discuss initialization strategies in this paper.In the stochastic/online SOM (SSOM), a data point x is selected randomly 1 at each iteration t. Then c ∈ {1, . . . , K} is determined as the index of the best matching unit, that isc = arg min k∈{1,...,K} x − m k (t) 2 ,(3)and all prototypes are updated viam k (t + 1) = m k (t) + ǫ(t)h kc (t)(x − m k (t)),(4)where ǫ(t) is a learning rate.In the batch SOM (BSOM), each iteration is made of two steps. In the first step, the best matching unit for each data point x i is determined as:c i (t) = arg min k∈{1,...,K} x i − m k (t) 2 .(5)Then all prototypes are updated via a weighted averagem k (t + 1) = N i=1 h kci(t) (t)x i N i=1 h kci(t) (t) .(6)Obviously, neither algorithm can be applied as is on non vector data.

The Median SOM


General principle
It is well known (and obvious) that the prototype update step of the Batch SOM can be considered as solving an optimization problem, namely∀ k ∈ {1, . . . , K}, m k (t + 1) = arg min s N i=1 h kci(t) (t) s − x i 2 .(7)This turns the vector space operations involved in equation (6) into an optimization problem that uses only the squared Euclidean norm between prototypes and observations. In an arbitrary space X with a dissimilarity, s k − x i 2 can be replaced by the dissimilarity between s k and x i which turns problem (7) into∀ k ∈ {1, . . . , K}, m k (t + 1) = arg min s∈X N i=1 h kci(t) (t)d(s, x i ),(8)which is a typical generalized median problem. However, the most general dissimilarity setting only assumes the availability of dissimilarities between observations not between arbitrary points in X . In fact, generating new points in X might be difficult for complex data such as texts. Then the most general solution consists in looking for the optimal prototypes into the data set rather than in X . The Median SOM  #b26  #b28  #b29  and its variants  #b11  #b12  are based on this principle. The Median SOM consists in iterating two steps. In the first step, the best matching unit for each data point x i is determined asc i (t) = arg min k∈{1,...,K} d(x i , m k (t)).(9)Then all prototypes are updated by solving the generalized median problem∀ k ∈ {1, . . . , K}, m k (t + 1) = arg min xj N i=1 h kci(t) (t)D ij .(10)Notice that each prototype is a data point which means that in equation  #b8  d(x i , m k (t)) is in fact a D il for some l.A variant of the Median SOM was proposed in  #b0 : rather than solving problem  #b9 , it associates to each unit the generalized median of the corresponding cluster (in other words, it does not take into account the neighborhood structure at this point). Then the BMU of a data point is chosen randomly using the neighborhood structure and the dissimilarities. This means that a data point can be moved from its natural BMU to a nearby one. As far as we know, this variant has not been studied in details.

Limitations of the Median SOM
The Median SOM has numerous problems. As a batch SOM it is expected to request more iterations to converge than a potential stochastic version (which is not possible in the present context, unfortunately). In addition, it will also exhibit sensitivity to its initial configuration.There are also problems more specific to the Median SOM. Each iteration of the algorithm has a rather high computational cost: a naive implementation leads to a cost of O(N 2 K + N K 2 ) per iteration, while a more careful one still costs O(N 2 + N K 2 )  #b9 . Numerous tricks can be used to reduce the actual cost per iteration  #b6  #b7  but the N 2 factor cannot be avoided without introducing approximations.Arguably the two main drawbacks of the Median SOM are of a more intrinsic nature. Firstly, restricting the prototypes to be chosen in the data set has some very adverse effects. A basic yet important problem comes from collisions in prototypes  #b35 : two different units can have the same optimal solution according to equation  #b9 . This corresponds to massive folding of the two dimensional representation associated to the SOM and thus to a sub-optimal data summary. In addition, equation (9) needs a tie breaking rule which will in general increase the cost of BMU determination (see  #b29  for an example of such a rule). The solution proposed in  #b35  can be used to avoid those problems at a reasonable computational cost.A more subtle consequence of the restriction of prototypes to data points is that no unit can remain empty, apart from collided prototypes. Indeed, the BMU of a data point that is used as a prototype should be the unit of which it is the prototype. This means that no interpolation effect can take place in the Median SOM  #b42  #b43  a fact that limits strongly the usefulness of visual representations such as the U-matrix  #b44  #b45 . For some specific data types such as strings, this can be avoided by introducing ways of generating new data points by some form of interpolations. This was studied in  #b42  #b43  together with a stochastic/online algorithm.A generic solution to lift the prototype restriction is provided by the relational SOM described in Section 4.

Non metric dissimilarities
The second intrinsic problem of the Median SOM is its reliance on a prototype based representation of a cluster in the dissimilarity context, while this is only justified in the Euclidean context. Indeed let us consider that the N data points (x i ) 1≤i≤N belong to a Euclidean space. Then for any vector of positive weights (β i ) 1≤i≤N , the well known König-Huygens identity states:N i=1 β i N j=1 β j x j N j=1 β j − x i 2 = 1 2 1 N i=1 β i N i=1 N j=1 β i β j x i − x j 2 .(11)This means thatmin m N i=1 β i m − x i 2 = 1 2 1 N i=1 β i N i=1 N j=1 β i β j x i − x j 2 .(12)Applied to the SOM, this means that solving 2(m(t), c(t)) = arg min m,c K k=1 N i=1 h kci (t) m k − x i 2 ,(13)where m(t) = (m 1 (t), . . . , m K (t)) denotes the prototypes and c = (c 1 , . . . , c n ) denotes the BMU mapping, is equivalent to solvingc(t) = arg min c 1 2 K k=1 1 N i=1 h kci (t) N i=1 N j=1 h kci (t)h kcj (t) x i − x j 2 .(14)This second problem makes clear that the classical SOM is not only based on quantization but is also optimizing the within pairwise distances in the clusters defined by the BMU mapping. Here h kci is considered as a form of membership value of x i to cluster k, which give the "size" N i=1 h kci to the cluster k. Then the sum of pairwise distances in each cluster measures the compactness of the cluster in terms of within variance. As the SOM minimizes the sum of those quantities, it can be seen as a clustering algorithm 3 .However, the König-Huygens identity does not apply to arbitrary dissimilarities. In other words, the natural dissimilarity version of problem (14) that isc(t) = arg min c 1 2 K k=1 1 N i=1 h kci (t) N i=1 N j=1 h kci (t)h kcj (t)d(x i , x j ),(15)is not equivalent to the Median SOM problem given by(m(t), c(t)) = arg min m∈{x1,...,xN } K ,c K k=1 N i=1 h kci (t)d(x i , m k ).(16)When the dissimilarity satisfies the triangular inequality this is not a major problem. By virtue of the triangular inequality, we have for all md(x i , x j ) ≤ d(x i , m) + d(m, x j ),(17)and therefore for all mN i=1 N j=1 h kci (t)h kcj (t)d(x i , x j ) ≤ 2 N i=1 h kci (t) N j=1 h kcj (t)d(x j , m),(18)which shows that1 2 N i=1 h kci (t) N i=1 N j=1 h kci (t)h kcj (t)d(x i , x j ) ≤ min m N j=1 h kcj (t)d(x j , m). (19)Then the Median SOM is optimizing an upper bound of the cluster oriented quality criterion for dissimilarities. In practice, this means that a good quantization will give compact clusters. However, when the dissimilarity does not satisfy the triangular inequality, the two criteria are not directly related any more. In fact, one prototype can be close to a set of data points while those points remain far apart from each other. Then doing of form of quantization by solving problem (16) is not the same thing as doing a form of clustering by solving problem  #b14 . By choosing the prototype based solution, the Median SOM appears to be a quantization method rather than a clustering one. If the goal is to display prototypes in an organized way, then this choice make sense (but must be explicit). If the goal is to display clusters in an organized way, this choice is intrinsically suboptimal. As pointed out in Section 8, dissimilarity SOMs are not very adapted to prototype display, which puts in question the interest of the Median SOM in particular and of the quantization approach in general.

The Relational SOM
The quantification of the prototypes induced by restricting them to data points has quite negative effects described in Section 3.2. The relational approach is a way to address this problem. It is based on the simple following observation  #b22 . Let the (x i ) 1,...,N be N points in a Hilbert space equipped with the inner product ., . and let y =N i=1 α i x i for arbitrary real valued coefficients α T = (α i ) 1,...,N with N i=1 α i = 1. Then x i − y, x i − y = (Dα) i − 1 2 α T Dα,(20)where D is the squared distance matrix given byD ij = x i − x j , x i − x j .This means that computing the (squared) distance between a linear combination of some data points and any of those data points can be done using only the coefficients of the combination and the (squared) distance matrix between those points.

Principle
But as shown by equation (6), prototypes in the classical SOM are exactly linear combinations of data points whose coefficients sum to one. It is therefore possible to express the Batch SOM algorithm without using directly the values of the x i , but rather by keeping the coefficients of the prototypes and using equation  #b19  and the squared distance matrix to perform all calculations.Then one can simply apply the so called relational version of the algorithm to an arbitrary dissimilarity matrix as if it were a squared euclidean one. This is essentially what is done in  #b21  #b22  for the c-means (a fuzzy variant of the kmeans) and in  #b20  for the Batch SOM (and the Batch Neural Gas  #b10 ). Using the concept of pseudo-Euclidean spaces, it was shown in  #b19  that this general approach can be given a rigorous derivation: it amounts to using the original algorithm (SOM, k-means, etc.) on a pseudo-Euclidean embedding of the data points.In practice, the Batch relational SOM proceeds by iterating two steps that are very similar to the classical Batch SOM steps. The main difference is that each prototype m k (t) (at iteration t) is given by a vector of R N , α k (t), which represents the coefficients of the linear combination of the x i in the pseudo-Euclidean embedding. Then the best matching unit computation from equation (5) is replaced byc i (t) = arg min k∈{1,...,K} (Dα k (t)) i − 1 2 α k (t) T Dα k (t) ,(21)while the prototype update becomesα k (t + 1) i = h kci(t) N l=1 h kc l (t) .(22)A stochastic/online variant of this algorithms was proposed in  #b33 . As for the classical SOM, it consists in selecting randomly a data point x i , computing its BMU c i (using equation (21)) and updating all prototypes as follows:α k (t + 1) j = α k (t) j + ǫ(t)h kci (t)(δ ij − α k (t) j ),(23)where δ ij equals 1 when i = j and 0 in other cases. Notice that is the α k are initialized so as to sum to one, this is preserved by this update. As shown in  #b33 , the stochastic variant tends to be less sensitive to the initial values of the prototypes. However  #b33  overlooks that both batch and online relational SOM algorithms share the same computational cost per iteration 4 which negates the traditional computational gain provided by online versions.

Limitations of the Relational SOM
The Relational SOM solves several problems of the Median SOM. In particular, it is not subject to the quantization effect induced by constraining the prototypes to be data points. As a consequence, it exhibits in practice the same interpolation effects as the classical SOM. The availability of a stochastic version provides also a simple way to reduce the adverse effects of a bad initialization. However, the relational SOM is very computationally intensive. Indeed, the evaluation of all the α k (t) T Dα k (t) costs O(KN 2 ) operations. Neither the dissimilarity matrix nor the prototype coefficients are sparse and there is no way to reduce this costs without introducing approximations. Notice that this cost is per iteration in both the batch and the stochastic versions of the relational SOM. This is K times larger than the Median SOM.This large cost has motivated research on approximation techniques such as  #b36 . The most principled approach consists in approximating the calculation of the matrix product via the Nyström technique  #b49 , as explored in  #b18 .

Soft Topographic Mapping for Proximity Data
As pointed out in Section 3.3, if an algorithm relies on prototypes with a general possibly non metric dissimilarity, it provides only quantization and not clustering. When organized clusters are looked for, one can try to solve problem (15) directly, that is without relying on prototypes.

A deterministic annealing scheme
However problem (15) is combinatorial and highly non convex. In particular, the absence of prototypes rules out standard alternating optimization schemes. Following the analysis done in the case of the dissimilarity version of the k-means in  #b5  #b25 , Graepel et al. introduce in  #b16  #b17  a deterministic annealing approach to address problem  #b14 . The approach introduces a mean field approximation which estimates by e ik the effects in the criterion of problem (15) of assigning the data point x i in cluster k. In addition, it computes soft assignments to the cluster/unit, denoted γ ik for the membership of x i to cluster k (γ ik ∈ [0, 1] and K k=1 γ ik = 1). The optimal mean field is given bye ik = K s=1 h ks N j=1 b js d(x i , x j ) − 1 2 N l=1 b ls d(x j , x l ) ,(24)where the b js are given byb js = K k=1 γ jk h ks N i=1 K k=1 γ ik h ks .(25)Soft assignments are updated according toγ ik = exp(−βe ik ) K s=1 exp(−βe is ) ,(26)where β is an annealing parameter. It plays the role of an inverse temperature and is therefore gradually increased at each step of the algorithm. In practice, the so-called Soft Topographic Mapping for Proximity Data (STMP) is trained in an iterative batch like procedure. Given an annealing schedule (that is a series of increasing values for β) and initial random values of the mean field, the algorithm iterates evaluating equation  #b25 , then equation  #b24  and finally equation (24) for a fixed value of β, until convergence. When this convergence is reached, β is increased and the iterations restart from the current value of the mean field.Notice in equation (25) that the neighborhood function is fixed in this approach, whereas it is evolving with time in most SOM implementations.

Limitations of the STMP
It is well known that the quality of the results obtained by deterministic annealing are highly dependent on the annealing scheme  #b34 . It is particularly important to avoid missing transition phases. Graepel et al. have analyzed transition phases in the STMP in  #b17 . As in  #b34  #b25 , the first critical temperature is related to a dominant eigenvalue of the dissimilarity matrix. As this is in general a dense matrix, the minimal cost of computing the critical temperature is O(N 2 ). In addition, each internal iteration of the algorithm is dominated by the update of the mean field according to equation  #b23 . The cost of a full update is in O(N 2 K + N K 2 ). The STMP is therefore computationally intensive. It should be noted however that an approximation of the mean field update that reduces the cost to O(N 2 K) is proposed in  #b17 , leading to the same computational cost as the relational SOM.In addition, as will appear clearly in Section 7.2, the STMP is based on prototypes, even they appear only indirectly. Therefore while it tries to optimize the clustering criterion associated to the SOM, it resorts to a similar quantization quality proxy as the relational SOM.

Kernel SOM
As recalled in Section 2.2, the kernel setting is easier to deal with than the dissimilarity one. Indeed the embedding into a Hilbert space H enables to apply any classical machine learning method to kernel data by leveraging the Euclidean structure of H. The kernel trick allows one to implement those methods efficiently.

The kernel trick for the SOM
In the case of the SOM, the kernel trick is based on the same fundamental remark that enables the relational SOM (see Section 4.1): in the Batch SOM, the prototypes are linear combinations of the data points. If the initial values of the prototypes are linear combinations of the data points (and not random points), this is also the case for the stochastic/online SOM.Then assume given a kernel k on X , with its associated Hilbert space H and mapping φ. Implementing the Batch SOM in H means working on the mapped data set (φ(x i )) 1≤i≤N with prototypes m k (t) of the form m k (t) = N i=1 α ki (t)φ(x i ). Then equation (5) becomes c i (t) = arg min k∈{1,...,K} φ(x i ) − m k (t) 2 H ,(27)withφ(x i ) − m k (t) 2 H =k(x i , x i ) − 2 N j=1 α kj (t)k(x k , x j )(28)+ N j=1 N l=1 α kj (t)α kl (t)k(x j , x l ).Equation (28) is a typical result of the kernel trick: computing the distance between a data point and a linear combination of the data points can be done using solely the kernel function (or matrix). To our knowledge, the first use of the kernel trick in a SOM context was made in  #b16 . Notice that equation (6) can also been implemented without using explicitly the mapping φ as one needs only the coefficients of the linear combination which are given byα ki (t + 1) = h kci(t) N l=1 h kc l (t) ,(29)exactly as in equation (22). While the earliest kernel SOM (STMK) in  #b16  is optimized using deterministic annealing (as the SMTP presented in Section 5), the kernel trick enables the more traditional online SOM  #b30  and batch SOM  #b4  #b31  #b48  derived from the previous equations. It should be noted for the sake of completeness that another kernel SOM was proposed in  #b1 . However, this variant assumes that X is a vector space and therefore is not applicable to the present setting.

Limitations of the kernel SOM
As it is built indirectly on a Hilbert space embedding, the kernel SOM does not suffer from constrained prototypes. The stronger assumptions made on kernels compared to dissimilarities guarantee the equivalence between finding good prototypes and finding compact clusters. Kernel SOM has also both online and batch versions.Then the main limitation of the kernel SOM is its computational cost. Indeed, as for the relational SOM, evaluating the distances in equation (28) has a O(KN 2 ) cost. The approximation schemes proposed for the relational SOM  #b18  #b36  can be used for the kernel SOM at the cost of reduced performances in terms of data representation.

Equivalences between SOM variants
It might seem at first that all the variants presented in the previous sections are quite different, both in terms of goals and algorithms. On the contrary, with the exception of the Median SOM which is very specific in some aspects, the variations between the different methods are explained by optimization strategies rather than by hypothesis on the data.

Relational and kernel methods are equivalent
We have already pointed out that relational SOM and kernel SOM share the very same principle of representing prototypes by a linear combination of the data points. Both cases use the same coefficient update formulas whose structure depends only on the type of the algorithm (batch or online).The connections are even stronger in the sense that given a kernel, the relational SOM algorithm obtained by using the dissimilarity associated to the kernel is exactly identical to the kernel SOM algorithm. Indeed if K is the kernel matrix, then the dissimilarity matrix is given byD ij = K ii + K jj − 2K ij . Then for all α ∈ R N such that N i=1 α i = 1 and for all i ∈ {1, . . . , N } (Dα) i − 1 2 α T Dα = N j=1 D ij α j − 1 2 N j=1 N l=1 α j α l D jl = N j=1 (K ii + K jj − 2K ij )α j − 1 2 N j=1 N l=1 α j α l (K jj + K ll − 2K jl ) Using N i=1 α i = 1, the first term becomes N j=1 (K ii + K jj − 2K ij )α j = K ii + N j=1 K jj α j − 2 N j=1 K ij α j .The same condition on α shows thatN j=1 N l=1 α j α l K jj = N j=1 K jj α j , and that N j=1 N l=1 α j α l K ll = N l=1 K ll α l . Therefore N j=1 N l=1 α j α l (K jj + K ll − 2K jl ) = 2 N j=1 K jj α j − 2 N j=1 N l=1 α j α l K jl .Combining those equations, we end up with(Dα) i − 1 2 α T Dα = K ii − 2 N j=1 K ij α j + N j=1 N l=1 α j α l K jl .(30)The second part of this equation is exactly φ(x i )−m 2 H when m = N j=1 α j φ(x j ) as recalled in equation  #b27 . Therefore, the best matching unit determination in the relational SOM according to equation  #b20  is exactly equivalent to the BMU determination in the kernel SOM according to equation  #b26 . This shows the equivalence between the two algorithms (in both batch and online variants).This equivalence shows that the batch relational SOM from  #b20  is a rediscovery of the batch kernel SOM from  #b31 , while the online relational SOM from  #b33  is a rediscovery of the online kernel SOM from  #b30 . Results from  #b19  show that those rediscoveries are in fact generalizations of kernel SOM variants as they extend the Hilbert embedding to the more general pseudo-Euclidean embedding. In practice, there is no reason to distinguish the kernel SOM from the relational SOM.

STMP is a prototype based approach
On the surface, the STMP described in Section 5 looks very different from relational/kernel approaches as it tries to address the combinatorial optimization problem (15) rather than the different problem (16) associated to the generalized median. However, as analyzed in details in  #b19 , the STMP differs from the relational approach only by the use of deterministic annealing, not by the absence of prototypes.A careful analysis of equations (24) and (22) clarifies this point. Indeed, let us consider α s = (b js ) T 1≤j≤N as the coefficient vector for a linear combination of the data points x j embedded in the pseudo-Euclidean space associated to the dissimilarity matrix D. ThenN j=1 b js d(x i , x j ) − 1 2 N l=1 b ls d(x j , x l ) = (Dα s ) i − 1 2 α T s Dα s .The right hand part is the distance in the pseudo-Euclidean space between the prototype associated to α s and x i . Then e ik in equation (24) is a weighted average of distances between x i and each of the α s , where the weights are given by the neighborhood function. As pointed out in  #b19 , this can be seen as a relational extension of the assignment rule proposed by Heskes and Kappen in  #b24 . However, rather than using crisp assignments to a best matching unit with the lowest value of e ik , the STMP uses a soft maximum strategy implemented by equation  #b25  to obtain assignment probabilities γ ik . Those are used in turn to update the coefficients of the prototypes in equation  #b24 .In fact the three algorithms proposed in  #b16  are all based on the same deterministic annealing scheme, with an initial implementation in R p (the STVQ) and two generalization in the Hilbert space associated to a kernel (STMK) and in the pseudo-Euclidean space associated to a dissimilarity (STMP). The discussion of the previous section shows that the kernel and the dissimilarity variants are strictly equivalent.

Summary
We summarizes in the following tables the variants of the SOM discussed in this paper. Table 1 maps a data type and an optimization strategy to a SOM variant.Relational variants include here the kernel case.  Batch SOM O(N Kp) O(N Kp) Online SOM O(Kp) O(Kp) Median SOM O(N K) O(N 2 + N K 2 ) Batch relational SOM O(N 2 K) O(N K) Online relational SOM O(N 2 K) O(N K) STVQ O(N Kp + N K 2 ) O(N Kp + N K 2 ) STMK/STMP O(N 2 K + N K 2 ) O(N K 2 )

Discussion
Even if the kernel approaches are special cases of the relational ones, we have numerous candidates for dissimilarity processing with the SOM. We discuss those variants in this section.

Median SOM
In our opinion, there is almost no reason to use the Median SOM in practice, except possibly the reduced computational burden compared to the relational SOM (O(N 2 ) compared to O(N 2 K) for the dominating terms). Indeed, the Median SOM suffers from constraining the prototypes to be data points and gives in general lower performances than the relational/kernel SOM as compared to a ground truth or based on the usability of the results (see for instance  #b18  #b33  #b48 ). The lack of interpolation capability is particularly damaging as it prevents in general to display gaps between natural clusters with u-matrix like visual representation  #b44  #b45 . For large data sets, the factor K increase in the cost of one iteration of the relational SOM compared to the median SOM could be seen as a strong argument for the latter. In our opinion, approximation techniques  #b18  #b36  are probably a better choice. This remains however to be tested as to our knowledge the effects of the Nyström approximation have only been studied extensively for the relational neural gas and the relational GTM  #b15  #b18  #b39 .

Optimization strategy
To our knowledge, no systematic study of the influence of the optimization strategy has been conducted for SOM variants, even in the case of numerical data. In this latter case, it is well known that the online/stochastic SOM is less sensitive to initial conditions than the batch SOM. It is also generally faster to converge and leads in general to a better overall topology preservation  #b13 . Similar results are observed in the dissimilarity case in  #b33 . It should be noted however that both analyses use only random initializations while it is well known (see e.g.  #b27 ) that a PCA 5 based initialization gives much better results than a random one in the case of the batch SOM. It is also pointed in  #b27  that the neighborhood annealing schedule as some strong effects on topology preservation in the batch SOM. Therefore, in terms of the final quality of the SOM, it is not completely obvious that an online solution will provide better results than a batch one.In addition, the relational setting negates the computational advantage of the online SOM versus the batch SOM. Indeed in the numerical case, one epoch of the online SOM (a full presentation of all the data points) has roughly the same cost as one iteration of the batch SOM. As the online SOM converges generally with a very small number of epochs, its complete computational cost is lower than the batch SOM. On the contrary, the cost of the relational SOM is dominated by the calculation of α T Dα in equation  #b20 . In the batch relational SOM this quantity can be computed one time per prototype and per iteration, leading to a cost of O(N 2 K) per iteration (this is overlooked in  #b33  which reports erroneously a complexity of O(N 3 K) per iteration). In the online version, it has also to be computed for each data point (because of the prototype update that takes place after each data point presentation). This means that one epoch of the online relational SOM costs N times more than one iteration of the batch relational SOM. We think therefore that a careful implementation of the batch relational SOM should outperform the online version, provided the initialization is conducted properly.Comparisons of the online/batch variants with the deterministic annealing variants is missing, as far as we know. The extensive simulations conducted in  #b19  compare the relational neural gas to the dissimilarity deterministic annealing clustering of  #b5  #b25 . Their conclusion is the one expected from similar comparisons done on numerical data  #b34 : the sophisticated annealing strategy of deterministic annealing techniques leads in general to better solutions provided the critical temperatures are properly identified. This comes with a largely increased cost, not really because of the cost per iterations but rather because the algorithm comprises two loops: an inner loop for a given temperature and an outer annealing loop. Therefore the total number of iterations is in general of an order of magnitude higher than with classical batch algorithms (see also  #b37  for similar results in the context of a graph specific variant of the SOM principle). It should be also noted that in all deterministic variants proposed in  #b16 , the neighborhood function is not adapted during learning. The effects of this choice on the usability of the final results remain to be studied.To summarize, our opinion is that one should prefer a careful implementation of the batch relational SOM, paired with a PCA like algorithm for initialization and using the Nyström approximation for large data sets. Further experimental work is needed to validate this choice.

Clustering versus quantization
As explained in Section 3.3, an algorithm that resorts (directly or indirectly) on prototypes for an arbitrary dissimilarity does in fact of form of quantization rather than a form of clustering. To our knowledge, no attempt has been made to minimize directly the prototype free criterion used in problem  #b14  and we can only speculate on this point.We should first note that in the case of classical clustering, it has been shown in  #b8  that optimizing directly the criterion from problem  #b14  in its k-means simplified form gives better results than using the relational version of the kmeans. While the computational burden of both approaches are comparable, the direct optimization of the pairwise dissimilarities criterion is based on a much more sophisticated algorithm which combines state-of-the-art hierarchical clustering  #b32  with multi-level refinement from graph clustering  #b23 .Assuming such a complex technique could be used to train a SOM like algorithm, one would obtain in the end a set of non empty clusters, organized according to a lattice in 2 dimensions, something similar to what can be obtained with the Median SOM. While the clusters would have a better quality, no interpolation between them would be possible, as in the Median SOM.

How useful are the results?
In our personal opinion, the main interest of the SOM is to provide rich and yet readable visual representations of complex data  #b46  #b47 . Unfortunately, the visualization possibilities are reduced in the case of dissimilarity data.The main limitation is that for arbitrary data in an abstract space X , one cannot assume that an element of X can be easily represented visually. Then even the Median SOM prototypes (which are data points) cannot be visualized. As the prototypes (in all the variants) do not have meaningful coordinates, component planes cannot be used.In fact, the only aspects of the results that can be displayed as in the case of numerical data are dissimilarities between prototypes (in U matrix like displays  #b44 ) as well as numerical characteristics of the clusters (size, compactness, etc.). But as pointed out in  #b45 , among others, this type of visualization is interesting mainly when the SOM uses a large number of units. While this is possible with the relational SOM, it implies a high computational because of the dominating O(N 2 K) term. The case of deterministic annealing versions of the SOM is even more problematic with the O(N K 2 ) complexity term induced by the soft memberships.In some situations, specific data visualization techniques can be built upon the SOM's results. For instance by clustering graph nodes via a kernel/dissimilarity SOM, one can draw a clustered graph representation, as was proposed in  #b4 . However, it has been shown in this case that specialized models derived from the SOM  #b37  or simpler dual approaches based on graph clustering and graph visualization  #b38  give in general better final results.To summarize, our opinion is that the appeal of a generic dissimilarity SOM is somewhat reduced by the limited visualization opportunity it offers, compared to the traditional SOM. Further work is needed to explore whether classical visualization techniques, e.g. brushing and linking  #b3  could be used to provide more interesting displays based on the dissimilarity SOM.

Conclusion
We have reviewed in this paper the main variants of the SOM that are adapted to dissimilarity data and to kernel data. Following  #b19 , we have shown that the variants differ more in terms of their optimisation strategy that in other aspects. We have recalled in particular that kernel variants are strictly identical to their relational counterpart. Taking into account computational aspects and known experimental results, our opinion is that the best solution is the batch relational SOM coupled with a structured initialization (PCA like) and with the Nyström approximation for large data sets and thus that we need one dissimilarity/kernel SOM variant only.However, as discussed above, the practical usefulness of the dissimilarity SOM is reduced compared to the numerical SOM as most of the rich visual representations associated to the SOM of not available for its dissimilarity version. Without improvement in its visual outputs, it is not completely clear if the dissimilarity SOM serves a real practical purpose beyond its elegant generality and simplicity.

Footnote
1 : or data points are looped through.
2 : The quantity optimized in equation(1
4 : the cost reported in[34] for the batch relational SOM is incorrect.
5 : PCA initialization is easily adapted to the relational case, as it was for kernel data[41].
3 :  This classical analysis mimics the one used to see the k-means algorithm both as a clustering algorithm and as a quantization algorithm.